<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Shady"><title>元编程 · Libx</title><meta name="description" content="在1024这一天，先开个坑叭。
什么是原编程（Mata Programming）很早之前就接触了元编程的一些东西，但是并没有什么很好的理解，只是觉得这个名字好牛逼，很玄幻🐸。主要还是在实际的coding中并没有直接的感触，最近又看到了相关的概念所以来简单的写点东西。
不准确的翻译在《你不知道的JS"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><h3 title=""><a href="/">Libx</a></h3><div class="description"><p>Thoughts,stories and ideas</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>© 2017 — 2018 ❤ Shady</span></a></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>元编程</a></h3></div><div class="post-content"><p>在1024这一天，先开个坑叭。</p>
<h3 id="什么是原编程（Mata-Programming）"><a href="#什么是原编程（Mata-Programming）" class="headerlink" title="什么是原编程（Mata Programming）"></a>什么是原编程（Mata Programming）</h3><p>很早之前就接触了元编程的一些东西，但是并没有什么很好的理解，只是觉得这个名字好牛逼，很玄幻🐸。主要还是在实际的coding中并没有直接的感触，最近又看到了相关的概念所以来简单的写点东西。</p>
<h3 id="不准确的翻译"><a href="#不准确的翻译" class="headerlink" title="不准确的翻译"></a>不准确的翻译</h3><p>在《你不知道的JS-ES6与未来》有这样的解释：元编程是针对程序本身的行为进行操作的编程。换句话说，它是为你程序的编程而进行的编程。 是的，很拗口。也有更详细些的这样的解释：元编程（笼统地说）是所有关于一门语言的底层机制，而不是数据建模或者业务逻辑那些高级抽象。如果程序可以被描述为 “制作程序”，元编程就能被描述为 “让程序来制作程序”。你可能已经在日常编程中不知不觉地使用到了元编程。</p>
<p>在接触了相关的概念之后，觉得似乎和想象中的不太一样，所以想到是否存在翻译的误解，首先从元这个字来理解好像有些问题，在中文的环境下元这个字在理解中有这样的理解：基本：单元，元件，元气（精气，根本），元素，元音。 而在概念中好像并不是这种意思，看到了有人解释这个meta的意思然后就有些理解了：</p>
<blockquote>
<p>Meta- 这个前缀在希腊语中的本意是「在…后，越过…的」，类似于拉丁语的 post-，比如 metaphysics 就是「在物理学之后」，这个词最开始指一些亚里士多德的著作，因为它们通常排序在《物理学》之后。但西方哲学界在几千年中渐渐赋予该词缀一种全新的意义：关于某事自身的某事。比如 meta-knowledge 就是「关于知识本身的知识」，meta-data 就是「关于数据的数据」，meta-language 就是「关于语言的语言」，而 meta-programming 也是由此而来，是「关于编程的编程」。<br>弄清了词源和字面意思，可知大陆将 meta- 这个前缀译为「元」并不恰当。台湾译为「后设」，稍微好一点点，但仍旧无法望文生义。也许「自相关」是个不错的选择，「自相关数据」、「自相关语言」、「自相关编程」——但是好像又太罗嗦了。</p>
</blockquote>
<p>这个翻译似乎有些问题。</p>
<p>这里举一个例子：</p>
<blockquote>
<p>例如，如果你为了调查对象a和另一个对象b之间的关系 —— 它们是被[[Prototype]]链接的吗？ —— 而使用a.isPrototypeOf(b)，这通常称为自省，就是一种形式的元编程。宏（JS中还没有） —— 代码在编译时修改自己 —— 是元编程的另一个明显的例子。使用for..in循环枚举一个对象的键，或者检查一个对象是否是一个“类构造器”的 实例，是另一些常见的元编程任务。</p>
</blockquote>
<h3 id="所关注的内容"><a href="#所关注的内容" class="headerlink" title="所关注的内容"></a>所关注的内容</h3><p>元编程关注以下的一点或几点：代码检视自己，代码修改自己，或者代码修改默认的语言行为而使其他代码受影响。简单的来概括，元编程中关注的方面: 代码生成(Code Generation) 反射(Reflection)</p>
<p>元编程的目标是利用语言自身的内在能力使你其他部分的代码更具描述性，表现力，和/或灵活性。由于元编程的 元 的性质，要给它一个更精确的定义有些困难。理解元编程的最佳方法是通过代码来观察它。<br>ES6在JS已经拥有的东西上，增加了几种新的元编程形式/特性。</p>
<p>Symbols 实现了的反射（Reflection within implementation）—— 你将 Symbols 应用到你已有的类和对象上去改变它们的行为。<br>Reflect 通过自省（introspection）实现反射（Reflection through introspection） —— 通常用来探索非常底层的代码信息。<br>Proxy 通过调解（intercession）实现反射（Reflection through intercession） —— 包裹对象并通过自陷（trap）来拦截对象行为。</p>
<h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h3><p>来看一个函数名的问题：这似乎是一个非常简单的不值一提的问题，但是JS就是这样，他会给你非常多的惊喜，答案会有些令人诧异地模糊。考虑如下代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">daz</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">	foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">	bar: <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">	bam: daz,</div><div class="line">	zim() &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在这前一个代码段中，“obj.foo()的名字是什么？”有些微妙。是”foo”，””，还是undefined？那么obj.bar()呢 —— 是”bar”还是”baz”？obj.bam()称为”bam”还是”daz”？obj.zim()呢？</p>
<p>另外，作为回调被传递的函数呢？就像：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line">	<span class="comment">// `cb()` 的名字是什么？</span></div><div class="line">&#125;</div><div class="line">foo( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="comment">// 我是匿名的！</span></div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<p>在程序中函数可以被好几种方法所表达，而函数的“名字”应当是什么并不总是那么清晰和明确。更重要的是，我们需要区别函数的“名字”是指它的name属性 —— 是的，函数有一个叫做name的属性 —— 还是指它词法绑定的名称，比如在function bar() { .. }中的bar。<br>词法绑定名称是你将在递归之类的东西中所使用的：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (i &lt; <span class="number">10</span>) <span class="keyword">return</span> foo( i * <span class="number">2</span> );</div><div class="line">	<span class="keyword">return</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>name属性是你为了元编程而使用的，所以它才是我们在这里的讨论中所关注的。<br>产生这种用困惑是因为，在默认情况下一个函数的词法名称（如果有的话）也会被设置为它的name属性。实际上，ES5（和以前的）语言规范中并没有官方要求这种行为。name属性的设置是一种非标准，但依然相当可靠的行为。在ES6中，它已经被标准化。</p>
<h4 id="推断"><a href="#推断" class="headerlink" title="推断"></a>推断</h4><p>但如果函数没有词法名称，name属性会怎么样呢？现在在ES6中，有一个推断规则可以判定一个合理的name属性值来赋予一个函数，即使它没有词法名称可用。<br>考虑如下代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> abc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">abc.name;				<span class="comment">// "abc"</span></div></pre></td></tr></table></figure></p>
<p>如果我们给了这个函数一个词法名称，比如abc = function def() { .. },那么name属性将理所当然地是”def”。但是由于缺少词法名称，直观上名称”abc”看起来很合适。<br>这里是在ES6中将会（或不会）进行名称推断的其他形式：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;);					<span class="comment">// name:</span></div><div class="line">(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123; .. &#125;);				<span class="comment">// name:</span></div><div class="line"><span class="built_in">window</span>.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;;		<span class="comment">// name:</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Awesome</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>() &#123; .. &#125;			<span class="comment">// name: Awesome</span></div><div class="line">	funny() &#123; .. &#125;					<span class="comment">// name: funny</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = <span class="class"><span class="keyword">class</span> <span class="title">Awesome</span> </span>&#123; .. &#125;;		<span class="comment">// name: Awesome</span></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">	foo() &#123; .. &#125;,					<span class="comment">// name: foo</span></div><div class="line">	*bar() &#123; .. &#125;,					<span class="comment">// name: bar</span></div><div class="line">	baz: <span class="function"><span class="params">()</span> =&gt;</span> &#123; .. &#125;,				<span class="comment">// name: baz</span></div><div class="line">	bam: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;,			<span class="comment">// name: bam</span></div><div class="line">	get qux() &#123; .. &#125;,				<span class="comment">// name: get qux</span></div><div class="line">	set fuz() &#123; .. &#125;,				<span class="comment">// name: set fuz</span></div><div class="line">	[<span class="string">"b"</span> + <span class="string">"iz"</span>]:</div><div class="line">		<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;,			<span class="comment">// name: biz</span></div><div class="line">	[<span class="built_in">Symbol</span>( <span class="string">"buz"</span> )]:</div><div class="line">		<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;			<span class="comment">// name: [buz]</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> x = o.foo.bind( o );			<span class="comment">// name: bound foo</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;).bind( o );		<span class="comment">// name: bound</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; .. &#125;	<span class="comment">// name: default</span></div><div class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Function</span>();				<span class="comment">// name: anonymous</span></div><div class="line"><span class="keyword">var</span> GeneratorFunction =</div><div class="line">	<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;&#125;.__proto__.constructor;</div><div class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> GeneratorFunction();	<span class="comment">// name: anonymous</span></div></pre></td></tr></table></figure></p>
<p>name属性默认是不可写的，但它是可配置的，这意味着如果有需要，你可以使用Object.defineProperty(..)来手动改变它。</p>
<h4 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h4><p>在“new.target”中，我们引入了一个ES6的新概念：元属性。正如这个名称所暗示的，元属性意在以一种属性访问的形式提供特殊的元信息，而这在以前是不可能的。<br>在new.target的情况下，关键字new作为一个属性访问的上下文环境。显然new本身不是一个对象，这使得这种能力很特殊。然而，当new.target被用于一个构造器调用（一个使用new调用的函数/方法）内部时，new变成了一个虚拟上下文环境，如此new.target就可以指代这个new调用的目标构造器。<br>这是一个元编程操作的典型例子，因为它的意图是从一个构造器调用内部判定原来的new的目标是什么，这一般是为了自省（检查类型/结构）或者静态属性访问。<br>举例来说，你可能想根据一个构造器是被直接调用，还是通过一个子类进行调用，来使它有不同的行为：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>() &#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">new</span>.target === Parent) &#123;</div><div class="line">			<span class="built_in">console</span>.log( <span class="string">"Parent instantiated"</span> );</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="built_in">console</span>.log( <span class="string">"A child instantiated"</span> );</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Parent();</div><div class="line"><span class="comment">// Parent instantiated</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Child();</div><div class="line"><span class="comment">// A child instantiated</span></div></pre></td></tr></table></figure></p>
<p>这里有一个微妙的地方，在Parent类定义内部的constructor()实际上被给予了这个类的词法名称（Parent），即便语法暗示着这个类是一个与构造器分离的不同实体。</p>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>待续</p>
<h3 id="Proxy-amp-Reflect"><a href="#Proxy-amp-Reflect" class="headerlink" title="Proxy &amp; Reflect"></a>Proxy &amp; Reflect</h3><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>从对匿名函数的函数名推断，到告诉你一个构造器是如何被调用的元属性，你可以前所未有地在程序运行期间来调查它的结构。通用Symbols允许你覆盖固有的行为，比如将一个对象转换为一个基本类型值的强制转换。代理可以拦截并自定义各种在对象上的底层操作，而且Reflect提供了模拟它们的工具。</p>
<p>参考文章：<br>[译]ES6 中的元编程 系列<br>You-Dont-Know-JS<br>MDN-元编程</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-10-24</span><i class="fa fa-tag"></i><a class="tag" href="/tags/JS/" title="JS">JS </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://stan1812.github.io/2018/10/24/Metaprogramming/,Libx,元编程,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/10/25/Burning/" title="燃烧">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/10/10/CoCo/" title="CoCo">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>