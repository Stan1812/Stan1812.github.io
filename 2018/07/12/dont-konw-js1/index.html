<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Shady"><title>我不知道的JavaScript<一>：作用域 · Libx</title><meta name="description" content="一直以来对于JS总是有一些一知半解的东西，因为这个假期没有留校，也还没有去找实习，就当给自己一些“私人时间”来对之前不求甚解的东西来梳理一遍吧。
一、作用域所有语言都有作用域，这是一种语言的基本功能之一，就是能够存储变量的值，并且能够在之后对之进行访问和修改，也正是因为这种存储和访问变量的能力将状态"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><h3 title=""><a href="/">Libx</a></h3><div class="description"><p>Thoughts,stories and ideas</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>© 2017 — 2018 ❤ Shady</span></a></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Arquivo</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>我不知道的JavaScript&lt;一&gt;：作用域</a></h3></div><div class="post-content"><p>一直以来对于JS总是有一些一知半解的东西，因为这个假期没有留校，也还没有去找实习，就当给自己一些“私人时间”来对之前不求甚解的东西来梳理一遍吧。</p>
<h3 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h3><p>所有语言都有作用域，这是一种语言的基本功能之一，就是能够存储变量的值，并且能够在之后对之进行访问和修改，也正是因为这种存储和访问变量的能力将<strong>状态</strong>带给了程序。要将变量引入程序就带来了相应的其他问题，怎么存，如何找到他们。相应的就需要一套规则来存储变量，并且之后可以方便的找到这些变量，这套规则就是作用域了。</p>
<h4 id="1-1-编译"><a href="#1-1-编译" class="headerlink" title="1.1 编译"></a>1.1 编译</h4><p>虽然JS是一门脚本语言，但是他也是一门“编译语言”，与传统C，JAVA等不同的是，他并非是提前编译的，而是在运行时进行编译（V8），JS的编译过程大概经过这几个过程：</p>
<ul>
<li>分词/词法分析（Tokenizing/Lexing）这个过程将字符串分解成对有意义的代码块，这些代码块被称为词法单元（Token）比如<code>var a = 1;</code> 这段代码会被分解为“var、a、=、1、；”</li>
<li>解析/语法分析（Parsing） 这个过程将词法单元流转换为一个由元素嵌套所构成的代表程序语法机构的抽象语法书（AST，Abstract Syntax Tree）</li>
<li>代码生成 AST树转化成可执行代码的过程。</li>
</ul>
<p>以上可以说是非常笼统概括的一个简单的编译过程，事实上，JS的编译解释过程要复杂得多，中间还要包括比如说在词法分析和代码生成阶段的特定处理步骤来对运行的性能、冗余元素进行优化等。很容易想到，因为JS的编译发生在你要运行代码前，所以引擎使用了各种方法来使编译速度能够提升上来。</p>
<h4 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h4><p> 既然作用域是根据名称查找变量的一套规则，那么在实际的使用中，就需要同时顾及几个作用域。</p>
<p> 当一个函数或块嵌套在另一个快或者函数中的时候，就发生了作用域的嵌套。因此，在当前的作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量（全局作用域为止）这其实也就是遍历嵌套作用域的规则。</p>
<p> 一个很简单的例子：<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a+b);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">foo(<span class="number">2</span>) <span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<p> 对b的RHS引用无法在函数foo内部完成，于是到上一层作用域中寻找</p>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>作用域有两种基本的工作模型：词法作用域和动态作用域。词法作用域较为普通，大多数语言都采用这种模式，而动态作用域则也仍有一些语言在使用。</p>
<h4 id="2-1-词法阶段"><a href="#2-1-词法阶段" class="headerlink" title="2.1 词法阶段"></a>2.1 词法阶段</h4><p>之前提到，大多数的语言编译器的第一个工作阶段叫做词法化，这也是词法作用域的名称来历的基础。</p>
<p>简单地说，词法作用域就是定义在词法阶段的作用域，也就是说，是由你在写代码的时候将代码放在哪里决定的，因此大部分情况下当词法分析器处理代码的时候会保持作用域不变。</p>
<p>来看一个例子；<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;            <span class="comment">// 1</span></div><div class="line">  <span class="keyword">var</span> b = a * <span class="number">2</span>;            <span class="comment">// 2</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a,b,c</span>)</span>&#123;      <span class="comment">// 3</span></div><div class="line">    <span class="built_in">console</span>.log(a,b,c);</div><div class="line">  &#125;</div><div class="line">  bar(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">&#125;</div><div class="line">foo(<span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p>我们把他理解为三层机构</p>
<ol>
<li>包含着全局作用域，只有一个标识符foo</li>
<li>包含着foo所创建的作用域，其中有 a  bar b</li>
<li>包含bar 创建的作用域， 只有c一个标识符</li>
</ol>
<p>现在暂时认为作用域尤其对应的代码块写在哪里决定，是逐级包含的</p>
<h4 id="2-2-查找"><a href="#2-2-查找" class="headerlink" title="2.2 查找"></a>2.2 查找</h4><p>作用域间的结构和位置关系给引擎提供了足够的位置信息，引擎使用这些信息来查找标识符的位置<br>作用域查找会在找到第一个匹配的标识符时停止，在多层的嵌套作用域中可以定义同名的标识符，这里叫作“遮蔽效应”</p>
<h4 id="2-3-欺骗词法"><a href="#2-3-欺骗词法" class="headerlink" title="2.3 欺骗词法"></a>2.3 欺骗词法</h4><p>既然词法作用域完全由函数的声明位置来决定，那么如何来在运行时改变词法作用域呢？<br>到了在众多风格指南中都会明令禁止使用的部分了:eval和with</p>
<ul>
<li><p>eval</p>
<p>eval接受一个字符串为参数，将其中的内容视为书写时就存在这个位置的代码。<br>也就是说，在进行词法分析的时候，eval内部的代码假装自己本来就在那里，而引擎也并不拆穿他，如常地进行词法作用域查找<br>看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str,a</span>)</span>&#123;</div><div class="line">  <span class="built_in">eval</span>(str);</div><div class="line">  <span class="built_in">console</span>.log(a,b);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">foo(<span class="string">"var b = 3;"</span>,<span class="number">1</span>) <span class="comment">//1,3</span></div></pre></td></tr></table></figure>
<p>这段代码所做的其实也就是在foo的作用域中创建了新的变量b，并遮蔽了外部的同名变量（严格模式下eval将拥有自己的词法作用域）</p>
</li>
<li><p>with<br>with通常被当作重复引用同一个对象的多个属性的快捷方式比如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">  age: <span class="number">10</span>,</div><div class="line">  weight: <span class="number">40</span>,</div><div class="line">  height: <span class="number">1.5</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">with</span>(xiaoming)&#123;</div><div class="line">  age: <span class="number">12</span>,</div><div class="line">  weight: <span class="number">45</span>,</div><div class="line">  height: <span class="number">1.6</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是在with的使用过程中可能会：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">with</span>(obj)&#123;</div><div class="line">    a = <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">a</span>:<span class="number">3</span>&#125;</div><div class="line"><span class="keyword">var</span> o2 = &#123;<span class="attr">b</span>:<span class="number">3</span>&#125;</div><div class="line">foo(o1)  <span class="comment">// o1.a = 2</span></div><div class="line">foo(o2)  <span class="comment">// o2.a = undefined window.a = 2</span></div></pre></td></tr></table></figure>
<p>尽管with块可以将一个对象处理成词法作用域，但是这个块内声明的var并不会限制在这个块的作用域，而是被添加到with所处的函数作用域中。</p>
</li>
</ul>
<h3 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h3><h4 id="3-1函数作用域"><a href="#3-1函数作用域" class="headerlink" title="3.1函数作用域"></a>3.1函数作用域</h4><p>Javascript具有基于函数的作用域吗，这意味着每声明一个函数都会为其创建作用域<br>首先看个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line">bar(); <span class="comment">// bar is not defined</span></div><div class="line"><span class="built_in">console</span>.log(a,b,c) <span class="comment">// all failed</span></div></pre></td></tr></table></figure></p>
<p>函数作用域的含义是指：属于这个函数的全部变量都可以在整个函数的范围内使用和复用（嵌套作用域也可）</p>
<h4 id="3-2-隐藏内部实现"><a href="#3-2-隐藏内部实现" class="headerlink" title="3.2 隐藏内部实现"></a>3.2 隐藏内部实现</h4><p>在写代码的时候，我们一般会遵照最小特权或最小暴漏原则，即：在软件设计中，应最小限度的暴漏必要内容，而将其他内特容都隐藏起来。</p>
<p>这个原则可以引申到如何选择作用域来包含变量和函数。</p>
<p>简单地说，通常我们写代码是先声明一个函数再向里面加上代码，但是我们也经常做一些相反的事情，我们发现一段代码可以更加独立，于是我们抽出这段代码来封装成新的函数。其实就是将这些代码隐藏了，而结果就是，在这些代码的周围创建了新的作用域，可以说，把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。</p>
<h4 id="3-3-立即执行函数"><a href="#3-3-立即执行函数" class="headerlink" title="3.3 立即执行函数"></a>3.3 立即执行函数</h4><p>我们知道在代码外添加包装函数可以将内部的变量和函数“隐藏”起来，外部作用域无法访问包装函数内部的内容，但是很显然，这还需要一个函数名（将污染其所在作用域）并且还需显式调用函数才有效。上帝说要有立即执行函数于是就有了：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">2</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">  <span class="built_in">console</span>.log(a)</div><div class="line">  &#125;)();</div><div class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;b()&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;)</div></pre></td></tr></table></figure>
<h4 id="3-4块作用域"><a href="#3-4块作用域" class="headerlink" title="3.4块作用域"></a>3.4块作用域</h4><p>先来一个非常简单的例子来引出块作用域：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i)&#125;,<span class="number">1000</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">test()</div></pre></td></tr></table></figure></p>
<p>很可惜JavaScript直接来看的话并没有块级作用域，但是其实也是有的：</p>
<ol>
<li>with</li>
<li><p>try/catch<br>在ES3中，try/catch会创建一个块作用域，其中声明的变量只有catch内部有效</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">  <span class="literal">undefined</span>();</div><div class="line">&#125;<span class="keyword">catch</span>(err)&#123;<span class="built_in">console</span>.log(err)&#125;</div><div class="line"><span class="built_in">console</span>.log(err)<span class="comment">//  err not defined</span></div></pre></td></tr></table></figure>
</li>
<li><p>ES6的出现改变了这一乱象，let const关键字可以将变量绑定到任意作用域上，也就是说，let为其声明得的变量隐式的附加在了一个已经存在的块级作用域上。</p>
<h4 id="3-5变量提升"><a href="#3-5变量提升" class="headerlink" title="3.5变量提升"></a>3.5变量提升</h4><p>Javascript的代码并不完全按照从上到下执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 1</span></div><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log(a) <span class="comment">//2</span></div><div class="line"></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(a) <span class="comment">//undefined</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>变量和函数的声明都会在代码执行之前被处理</p>
<p>比如<code>var a = 2</code>解释器会将其认为是两段代码<code>var a</code> <code>a = 2</code>,首先是声明，其后是赋值，定义声明是在编译阶段进行的，赋值会留在原地等待执行阶段。</p>
<p>也就是说：2中的代码的执行顺序是这样的：<code>var a ;console.loe(a); a = 2</code></p>
<p>这个过程好像变量和函数声明被移动到了最上面，这就叫_<em>提升</em></p>
<ul>
<li><p>函数会被提升但函数表达式不会被提升：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">foo() <span class="comment">// success</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">foo() <span class="comment">// TypeError</span></div><div class="line"><span class="keyword">var</span> foo =<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>函数优先</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">foo() <span class="comment">// 1</span></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  cosnole.log(<span class="number">2</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>先写到这里，下一篇将对闭包来进行梳理</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-07-12</span><i class="fa fa-tag"></i><a class="tag" href="/tags/JS/" title="JS">JS </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://stan1812.github.io/2018/07/12/dont-konw-js1/,Libx,我不知道的JavaScript&lt;一&gt;：作用域,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/07/13/dont-konw-JS2/" title="我不知道的JavaScript&lt;二&gt;：闭包">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/06/14/mini-redux/" title="从头实现一个mini Redux">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>