<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Shady"><title>我不知道的JavaScript<四>：原型 · Libx</title><meta name="description" content="当我们在谈论原型时，我们在谈论什么？

从对象说起
有一句话是这样说的 JS 中万物皆对象，这句话虽然不完全正确但是有些道理，毕竟 JS 中还是有很多特殊的复杂子类型比如函数，虽然函数也是可调用的对象，不过毕竟typeOf null结果都是 object [滑稽]（因为底层对象都表示为二进制，在 J"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><h3 title=""><a href="/">Libx</a></h3><div class="description"><p>Thoughts,stories and ideas</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>© 2017 — 2018 ❤ Shady</span></a></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>我不知道的JavaScript&lt;四&gt;：原型</a></h3></div><div class="post-content"><blockquote>
<p>当我们在谈论原型时，我们在谈论什么？</p>
</blockquote>
<h3 id="从对象说起"><a href="#从对象说起" class="headerlink" title="从对象说起"></a>从对象说起</h3><hr>
<p>有一句话是这样说的 JS 中万物皆对象，这句话虽然不完全正确但是有些道理，毕竟 JS 中还是有很多特殊的复杂子类型比如函数，虽然函数也是可调用的对象，不过毕竟<code>typeOf null</code>结果都是 object [滑稽]（因为底层对象都表示为二进制，在 JS 中二进制前三位都为 0 的话会被判定为 object 类型，null 的二进制表示为全零自然会是 object）</p>
<p>但是还是要好好梳理下对象相关的一些东西</p>
<h4 id="扯些关系不大的"><a href="#扯些关系不大的" class="headerlink" title="扯些关系不大的"></a>扯些关系不大的</h4><p>数组和对象的关系源远流长，以至于要区分数组和对象都要专门使用<code>Object.prototype.toString.call([])</code>或者<code>Array.isArray()</code>来判断。对象可以像数组一样使用<code>[]</code>来访问值，数组也可以使用<code>.</code>来添加属性，只是不管使用点操作符还是[]操作符来为数组添加命名属性，数组的 length 属性都不会发生变化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> a =[]</div><div class="line">a.test = <span class="string">"hello"</span></div><div class="line"><span class="built_in">console</span>.log(a)</div><div class="line"><span class="comment">//[test: "hello"] test: "hello" length: 0</span></div></pre></td></tr></table></figure>
<h4 id="对象属性描述符"><a href="#对象属性描述符" class="headerlink" title="对象属性描述符"></a>对象属性描述符</h4><p>在 ES5 之前并没有提供可以直接检测属性特性的方法,但是从 ES5 开始,属性具备了标识符：可以通过<code>Object.getOwnPropertyDescriptor({})</code>获取：<br>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> test = &#123;&#125;</div><div class="line"><span class="built_in">Object</span>.defineProperty(test,<span class="string">"a"</span>,&#123;</div><div class="line">  value: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(test,<span class="string">"a"</span>)</div><div class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure>
<p>顾名思义，writeble,enumrable,configurable。0</p>
<h4 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h4><p>在 ES5 中可以部分改写默认操作，虽然只能应用到单个属性上，当给一个属性定义 getter 和 setter 或者两者都有的时候，这个属性会被定义成“访问描述符（与数据描述符相对）”对于访问描述符来说，JS 会忽略他们的 value 和 writeable 属性，而只关心 set 和 get、configurable、enumerable 特性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  get a()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"b"</span>,&#123;</div><div class="line">  get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a*<span class="number">2</span>&#125;</div><div class="line">  enumerable:<span class="literal">true</span></div><div class="line">&#125;)</div><div class="line">obj.a <span class="comment">//1</span></div><div class="line">obj.b <span class="comment">//2</span></div></pre></td></tr></table></figure>
<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>当一个属性值为 undefined 的时候，要如何来判断是否存在？方法很多也很简单，<code>xx in obj</code>,<code>Object.getOwnProperty(&quot;xx&quot;)</code>区别在于 in 操作符会到原型链上检查，而后者不会。之后我们会详细区分。<br>Object.getOwnPropertyNames({})或者 Object.keys()返回对象的所有属性名组成的数组，这可以用来便利对象，或者使用 for in</p>
<p>数组中包含着内置的<code>@@iterator</code>因此我们 for of 可以直接应用到数组上，其实这样工作的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="keyword">var</span> it = myArray[<span class="built_in">Symbol</span>.iterator]() <span class="comment">//使用Symbol.iterator获取对象内部的@@iterator属性。</span></div><div class="line">it.next() <span class="comment">//&#123;value: 1, done: false&#125;</span></div><div class="line">it.next() <span class="comment">//&#123;value: 2, done: false&#125;</span></div><div class="line">it.next() <span class="comment">//&#123;value: 3, done: false&#125;</span></div><div class="line">it.next() <span class="comment">//&#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure>
<p>而普通的对象没有内置的@@iterator，但我们可以手写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> obj =&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</div><div class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="built_in">Symbol</span>.iterator,&#123;</div><div class="line">  enumerable:<span class="literal">false</span>,</div><div class="line">  writeable:<span class="literal">false</span>,</div><div class="line">  configurable:<span class="literal">true</span>,</div><div class="line">  value:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">this</span></div><div class="line">    <span class="keyword">var</span> idx = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> ks = <span class="built_in">Object</span>.keys(o)</div><div class="line">    <span class="keyword">return</span>&#123;</div><div class="line">      next:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">          value:o[ks[idx++]],</div><div class="line">          done:(idx&gt;ks.length)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">//手动遍历</span></div><div class="line"><span class="keyword">var</span> it = obj[<span class="built_in">Symbol</span>.iterator]();</div><div class="line">it.next()</div><div class="line"><span class="comment">//for of 遍历：</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> obj)&#123;</div><div class="line">  <span class="built_in">console</span>.log(el)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="由对象到原型"><a href="#由对象到原型" class="headerlink" title="由对象到原型"></a>由对象到原型</h3><hr>
<p>Javascript 中的对象都会有一个特殊的<code>[[Prototype]]</code>内置属性，就是对于其他属性的引用，几乎所有的对象在创建[[Prototype]]属性的时候都会赋一个非空的值，但很快我们就会看到对象的[[Prototype]]属性可以为空，虽然少见。</p>
<p>[[Prototype]]属性有什么用呢?我们之前提到过，当试图引用对象的属性的时候会触发[[get]]操作，第一步是检查对象本身是否有这个属性，如果没有就继续往原型链上寻找，整个过程会持续找到匹配的属性名，或者查找完整条原型链，如果是后者，最终会返回 undefined。</p>
<p>那么哪里是原型链的尽头呢？所有普通的原型链最终都会指向内置的 Object.prototype /由于所有的内置对象都源于这个 Object.prototype，所以这个对象会包含很多通用的功能，比如最常用的.toString,.valueOf</p>
<h4 id="属性设置与屏蔽"><a href="#属性设置与屏蔽" class="headerlink" title="属性设置与屏蔽"></a>属性设置与屏蔽</h4><p>给一个对象设置一个属性并非只是添加一个新属性或者修改一个属性而已，接下来我们来解释下这个过程：</p>
<p><code>obj.foo = &quot;bar&quot;</code></p>
<p>如果 obj 包含名为 foo 的普通数据访问属性，这条语句可以修改已有的属性值</p>
<p>如果 foo 并不包含在 obj 中那么就向原型链上寻找，如果找不到，foo 将添加到 obj</p>
<p>然而如果 foo 存在于原型链上层，那么赋值语句的行为会有些怪异:</p>
<ul>
<li>如果在原型链上存在 foo 且<code>writeable:true</code> 那么将会在 obj 添加 foo，并且是屏蔽属性。</li>
<li>如果在原型链上存在 foo 且<code>writeable:false</code> 那么不能在 obj 添加 foo，且原型链上的 foo 不会被改写，语句会被忽略，严格模式下会报错。</li>
<li>如果在原型链上存在 foo 且是一个 setter 那么将会调用这个 setter<br>我们可能认为，只要向原型链上已存在的属性赋值就一定会触发屏蔽，但是在这以上三种情况中只有一种会发生屏蔽，2，3 想要触发屏蔽的话可以使用 Object.defineProperty()<br>如果原型链上也存在，obj 也存在，那么会发生屏蔽，底层的 foo 将屏蔽链上的 foo</li>
</ul>
<p>有时候会发生隐式屏蔽:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</div><div class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(obj1)</div><div class="line">obj1.a <span class="comment">// 1</span></div><div class="line">obj2.a <span class="comment">// 1</span></div><div class="line">obj1.hasOwnProperty(<span class="string">"a"</span>) <span class="comment">//true</span></div><div class="line">obj2.hasOwnProperty(<span class="string">"a"</span>) <span class="comment">//false</span></div><div class="line">obj2.a++ <span class="comment">//发生隐式屏蔽</span></div><div class="line"></div><div class="line">obj2.a <span class="comment">//2</span></div><div class="line">obj1.a <span class="comment">//1</span></div><div class="line"></div><div class="line">obj2.hasOwnProperty(<span class="string">"a"</span>) <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>这段代码其实还蛮有意思的。</p>
<h3 id="”类“"><a href="#”类“" class="headerlink" title="”类“"></a>”类“</h3><p>众所周知 JS 和传统的面向对象的语言不同，他并没有类来作为对象的抽象，JS 只有对象，他是少有的可以不通过类直接创建对象的语言。</p>
<p>虽然没有类，但是开发者们其实一直都在模仿类的行为，其实就是利用了函数的一种特性：所有的函数都会有一个名为 prototype 的公有且不可枚举的属性，他会指向一个对象。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">Function</span> <span class="title">Foo</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">Foo.prototype <span class="comment">//&#123;&#125;</span></div></pre></td></tr></table></figure>
<p>这个对象称为 Foo 的原型，因为我们通过 Foo.prototype 来访问他，但是以学习 JS 的经验来看（滑稽），顾名思义会出大问题滴（再次滑稽）。先抛开名字不谈，这个东西到底是什么？<br>之前我们讲过 new 对象时大概会发生的四个步骤，这里就要提到第二步：执行原型连接，关联到 Foo.prototype 上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo()</div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === Foo.prototype <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>在面向对象的语言中，类可以被实例化多次，实例化一个类就意味着把类的行为复制到一个对象中，但是在 JS 中并没有类似的复制机制，你不能创建一个类的多个实例，只能创建多个对象，他们的[[Prototype]]关联到同一个对象上，因此在默认情况下，并不会发生复制，因此这些对象不会完全失去联系，他们是互相关联的。<br>但是事实上，我们可以认为 new Foo()所创建的这个链接其实是一种副作用，他并非直接创建关联。更直接的方法时：<code>Object.create()</code></p>
<p>JS 中我们并不会把一个对象（类）复制到另一个对象（实例）上，只是将他们关联起来，这个机制通常被称为原型继承，这个名称主要是为了应对面向类的语言中继承的意义，但是其实并没有表示出动态语言中对应的含义。也就是说，这里说到继承，其实算不上继承。这可能会让习惯于传统语言的开发者非常不习惯。</p>
<p>继承意味着复制操作，但 JS 默认并不会复制对象属性，只是会创建一个关联，这样一个对象可以通过<code>委托</code>来访问另一个对象的属性和函数，委托这个词更能准确描述 JS 中对象的关联机制。</p>
<p>回到之前的代码中，为神马会认为 Foo 是一个类呢？因为 new。但是事实，JS 中，对于构造函数最好的解释我认为应该是：所有带 new 的函数调用。除了这个迷惑人的东西之外，还有一个 Prototype.constructor</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Foo.prototype.constructor===Foo <span class="comment">//true</span></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo()</div><div class="line">a.constructor === Foo <span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>Foo.prototype 默认会有一个不可枚举的 constructor 属性，这个属性引用的是与对象关联的函数（Foo），而 a 竟然也有一个 constructor 属性，指向”创建这个对象的函数“，可能你已经想到，实际上，这个.constructor 是 Foo.prototype 的。</p>
<h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>先来看一段典型的原型继承的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line">Foo.prototype.myName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span> (<span class="params">name,label</span>)</span>&#123;</div><div class="line">  Foo.call(<span class="keyword">this</span>,name)</div><div class="line">  <span class="keyword">this</span>.label=label</div><div class="line">&#125;</div><div class="line">Bar.prototype=<span class="built_in">Object</span>.create(Foo.prototype)</div><div class="line"><span class="comment">// 注意这里相当于Bar.prototype 指向了一个新的对象，constructor丢失</span></div><div class="line">Bar.prototype.myLabel=funciton()&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.label</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">"a"</span>,<span class="string">"obj a"</span>)</div><div class="line">a.myName()  <span class="comment">//a</span></div><div class="line">a.myLabel() <span class="comment">//obj a</span></div></pre></td></tr></table></figure>
<p>这段代码的核心就是使用 Object.create()创建了一个新对象，并把新的对象内部的[[Prototype]]关联到指定的对象，也就是说，创建一个新的 Bar.prototype 对象并且把他关联到 Foo.prototype.<br>有两种可能会用的方法：<br><code>Bar.prototype=Fo.prototype</code> 这种是直接让 Bar.prototype 指向了 Foo.prototype,这样会在修改 Bar 的原型方法时其也修改了 Foo 的，这其实就没有 Bar 存在的意义了。</p>
<p><code>Bar.prototype=new Foo()</code>这样的确会创建一个新对象，但是可能有一些 Foo 内部的副作用。</p>
<p>因此，要创建一个合适的关联对象，使用 Object.create()是一个比较好的方法，但是也有缺点，就是我们创建了一个新对象，然后把旧的抛弃掉了。在 ES6 之前可以通过修改._proto_来修改，但这个方法并不是标准而且浏览器兼容会有问题，在 ES6 中，出现了<code>Object.setPrototypeOf(Bar.prototype,Foo.prototype)</code><br>也就是说我们现在有两种方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//ES6之前需要抛弃默认的Bar.prototype</span></div><div class="line">Bar.prototype=<span class="built_in">Object</span>.create(Foo.prototype)</div><div class="line"><span class="comment">//ES6之后可以直接修改</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(Bar.prototype,Foo.prototype)</div></pre></td></tr></table></figure>
<p>那么如何找到委托关联对象之间的关系(内省)呢？<code>a.isPrototypeOf(c)</code>,我们也可以直接获取一个对象的[[Prototype]]链:<code>Object.getPrototypeOf(c)</code>,还可以通过<code>c.__proto__ ===Foo.prototype</code>来判断 , <code>__proto__</code>的实现大概类似这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype,<span class="string">"__proto__"</span>,&#123;</div><div class="line">  get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>)</div><div class="line">  &#125;,</div><div class="line">  set:<span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">    <span class="built_in">Object</span>.setPrototypeOf(<span class="keyword">this</span>,o)</div><div class="line">    <span class="keyword">return</span> o</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-07-16</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://stan1812.github.io/2018/07/16/dont-know-JS4/,Libx,我不知道的JavaScript&lt;四&gt;：原型,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2018/08/05/esayMVVM/" title="理解Vue数据绑定">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2018/07/15/dont-know-JS3/" title="我不知道的JavaScript&lt;三&gt;：this">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>