<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>An Amazing World</title>
  
  <subtitle>前端小学生的神奇世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://stan1812.github.io/"/>
  <updated>2018-04-23T06:06:34.359Z</updated>
  <id>http://stan1812.github.io/</id>
  
  <author>
    <name>Shady</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Serious JavaScript</title>
    <link href="http://stan1812.github.io/2018/04/23/seriouslyJavascript/"/>
    <id>http://stan1812.github.io/2018/04/23/seriouslyJavascript/</id>
    <published>2018-04-23T05:43:08.000Z</published>
    <updated>2018-04-23T06:06:34.359Z</updated>
    
    <content type="html"><![CDATA[<p>总所周知，JavaScript是一门非常严谨的语言。</p><p>比如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="number">0</span> == <span class="string">"0"</span> <span class="comment">// true</span></div><div class="line"><span class="number">0</span> == []  <span class="comment">// true</span></div><div class="line"><span class="comment">//so =&gt;</span></div><div class="line"><span class="string">"0"</span> == [] <span class="comment">// ?</span></div><div class="line"><span class="comment">// false</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">parseInt</span>(<span class="number">0.000001</span>)  <span class="comment">// # =&gt; 0</span></div><div class="line"><span class="built_in">parseInt</span>(<span class="number">0.0000001</span>) <span class="comment">// # =&gt; 1</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">console</span>.log([<span class="number">1</span>] + [<span class="number">1</span>]) <span class="comment">//11</span></div><div class="line"><span class="built_in">console</span>.log([<span class="number">1</span>] + [<span class="number">1</span>] - [<span class="number">1</span>]) <span class="comment">//10</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> bool = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)</div><div class="line"><span class="keyword">if</span>(bool)</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"JS is amazing"</span>)</div><div class="line">  <span class="comment">// JS is amazing</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总所周知，JavaScript是一门非常严谨的语言。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span c
      
    
    </summary>
    
    
      <category term="-JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 枚举类型的一些理解</title>
    <link href="http://stan1812.github.io/2018/04/14/javaEnum/"/>
    <id>http://stan1812.github.io/2018/04/14/javaEnum/</id>
    <published>2018-04-13T16:15:20.000Z</published>
    <updated>2018-04-14T09:28:26.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说点废话"><a href="#说点废话" class="headerlink" title="说点废话"></a>说点废话</h3><p>  在开始学习JAVA之后，写习惯了Javascript的我，首先意识到的是好繁琐，比如在接触JAVA中的枚举类型之后，这在JS中想要实现重写一些方法，以及其他一些类似的效果其实从语法上来讲要简单的不少，虽然Javascript最初是JS之父用了10多天写出了的，甚至有一一部分直接抄的JAVA比如Date类，（虽然抄来的Date一直被吐槽不好用，好像打算要重写？）</p><p>  甚至连起名字都是为了蹭一波JAVA的名气。并且面向对象的实现方式也截然不同，一个是纯正的基于对象的继承，另一个是基于原型链的继承。甚至有人调侃真的OOP和假的OOP。。</p><p>  不过虽然实现方式不一样，但是一些设计思想感觉还是类似的，之前总有人说JAVA和Javascript的区别就是斑马和斑马线的区别，现在来想一想其实这两种语言还是类似的地方的，尤其是在ES6中的Class出现之后，Class ，extends 等等语法糖的出现，给人感觉更像了///可能JS作为一个一开始并不被看好的语言随着应用范围越来越广，使用JS、构建的项目也越来越大，想要变得更牛逼似乎有一种更适合于工程化的东西出现了吧。</p><h3 id="JAVA的枚举类型"><a href="#JAVA的枚举类型" class="headerlink" title="JAVA的枚举类型"></a>JAVA的枚举类型</h3><p>先来举个最常用的栗子🎂 ：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Colors &#123;</div><div class="line">  RED,BLUE,BLACK,YELLOW,GREEN;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 简单调用：Colors.RED</span></div></pre></td></tr></table></figure></p><p>这是最基本的使用方法。但是其实并没有展现出JAVA的枚举类型的用途，有点人才埋没。</p><p>再举一个目前用的比较多的一种使用方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Tips &#123;</div><div class="line">  WIN(<span class="string">"you win"</span>),LOSE(<span class="string">"you lose"</span>);</div><div class="line">  <span class="keyword">private</span> String tip;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Tips</span><span class="params">(String tip)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.tip = tip;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.tip;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">System.out.println(Tips.WIN)</div><div class="line"><span class="comment">// you win</span></div></pre></td></tr></table></figure><p>在这段代码中，我们简单的保存了一些基本的提示信息,重写tostring方法,这在JS里面其实可以说是很常见了，不同的是修改的原型链上的方法，不禁感到非常亲切。</p><p>在看到这种用法之后，很疑惑，WIN和LOSE，看起来很像是一个函数，但是很不理解在初始化的时候到底是怎么操作的，以至于认为在调用的时候是调用的一个名为WIN的方法，于是就反编译了编译生成的class文件：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">➜  src javap Tips.class</div><div class="line">Compiled from <span class="string">"Tips.java"</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Tips</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Tips</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tips WIN;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tips LOSE;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Tips[] values();</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tips <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</div><div class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</div><div class="line">  <span class="keyword">static</span> &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在看到了反编译的文件之后才算明白，所创建的枚举类型实例（且为final类型）继承自Java的Enum类，<br>而在内部的编译中，其实是遍历生成以所写内容命名的Tips类的实例，且生成的实例就能为final类型，不可继承，因为是static类型由Tips类所属，所以可以直接调用，比如：<code>Tips.WIN</code>.<br>因为重写了构造方法Tips(),并声明了私有变量tip，所以在生成实例的时候，初始化各个实例的tip为所传入的内容。然后重写toString方法，在调用的时候，返回tip。效果就是实现了，当然重写类的toString方法可能一般并不提倡，以为在JS里面也同样是要避免污染原型链的，这里应该是类似的。</p><p>由于WIN（以WIN为例）实质上是Tips类的一个static的对象，为全局共有,当然可以给其创建封装新的接口，比如，<br>比如：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTip</span> <span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.tip;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>需要注意的一点是，这个getTip方法是属于实例的还是属于class的？也就是说他是类方法还是实例方法？<br>再来反编译一下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">➜  src javap Tips.class</div><div class="line">Compiled from <span class="string">"Tips.java"</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Tips</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Tips</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tips WIN;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tips LOSE;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Tips[] values();</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tips <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</div><div class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</div><div class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getTip</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</div><div class="line">  <span class="keyword">static</span> &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为在JS里构造函数中所写的方法，是属于实例的，即每初始化一个实例对象就会重新声明一个属于该对象的重名方法。浪费了内存。想要使其共享，就要将函数写到prototype上，所以在这里想了一下，不过在查了一些东西之后发现，这里的方法，即使并未写在构造函数里面，只要是非静态方法其就是实例方法。。似乎在JS和JAVA中，构造函数的概念及作用并不完全相同。与JS中使用工厂模式初始化的对象相比，JAVA中的类与JS的构造函数来对比更为合适一些。</p><h3 id="Enum抽象类常见方法"><a href="#Enum抽象类常见方法" class="headerlink" title="Enum抽象类常见方法"></a>Enum抽象类常见方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">返回类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">compareTo(E o)</td><td style="text-align:left">int</td><td style="text-align:left">比较此枚举与指定对象的顺序</td></tr><tr><td style="text-align:left">equals(Object other)</td><td style="text-align:left">boolean</td><td style="text-align:left">当指定对象等于此枚举常量时，返回 true。</td></tr><tr><td style="text-align:left">name()</td><td style="text-align:left">String</td><td style="text-align:left">返回此枚举常量的名称，在其枚举声明中对其进行声明</td></tr><tr><td style="text-align:left">ordinal()</td><td style="text-align:left">int</td><td style="text-align:left">返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零）</td></tr><tr><td style="text-align:left">toString()</td><td style="text-align:left">String</td><td style="text-align:left">返回枚举常量的名称，它包含在声明中</td></tr><tr><td style="text-align:left">getDeclaringClass()</td><td style="text-align:left">Class&lt;?&gt;</td><td style="text-align:left">返回与此枚举常量的枚举类型相对应的 Class 对象</td></tr></tbody></table><p>大概就是这样叭🚀</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;说点废话&quot;&gt;&lt;a href=&quot;#说点废话&quot; class=&quot;headerlink&quot; title=&quot;说点废话&quot;&gt;&lt;/a&gt;说点废话&lt;/h3&gt;&lt;p&gt;  在开始学习JAVA之后，写习惯了Javascript的我，首先意识到的是好繁琐，比如在接触JAVA中的枚举类型之后，这在
      
    
    </summary>
    
    
      <category term="JAVA" scheme="http://stan1812.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊前端各种宽高左右</title>
    <link href="http://stan1812.github.io/2018/04/13/heightInHtml/"/>
    <id>http://stan1812.github.io/2018/04/13/heightInHtml/</id>
    <published>2018-04-13T15:35:18.000Z</published>
    <updated>2018-04-13T16:13:00.990Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>之前对DOM接口中各种height，height，scrollHeight，clientHeight，clientWidth等等概念有大概的了解，但是在想理清其概念的时候却发现了挺多的问题，概念有些模糊，在翻了写文档做了些测试之后来写一篇总结。</p><h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">offset</th><th style="text-align:left">scroll</th><th style="text-align:left">client</th></tr></thead><tbody><tr><td style="text-align:left">Height</td></tr><tr><td style="text-align:left">Left</td></tr><tr><td style="text-align:left">Top</td></tr><tr><td style="text-align:left">Width</td></tr></tbody></table><h4 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h4><ul><li><p>offsetleft:margin  + padding</p></li><li><p>offsettop:margin + padding;</p></li><li><p>offsetwidth:本身的宽度+内边距左右+边框左右;</p></li><li><p>offsetHeight:same</p><h4 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h4></li><li><p>Element.scrollHeight :只读,指一个元素内容高度，包括由于溢出导致的视图中不可见内容。没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同。包括元素的padding，但不包括元素的border和margin。scrollHeight也包括 ::before 和 ::after这样的伪元素。</p></li><li><p>Element.scrollTop: 可写 ,获取或设置一个元素的内容垂直滚动的像素数。一个元素的 scrollTop 值是这个元素的顶部到它的最顶部可见内容（的顶部）的距离的度量。当一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为0。如果一个元素不能被滚动（例如，它没有溢出，或者这个元素有一个”non-scrollable”属性）， scrollTop将被设置为0。设置scrollTop的值小于0，scrollTop 被设为0.如果设置了超出这个容器可滚动的值, scrollTop 会被设为最大值.</p></li><li><p>Element.scrollLeft 与xxtop类似</p></li><li><p>Element.scrollwidth：内容区域尺寸加上内边距加上溢出尺寸，当内容正好和内容区域匹配没有溢出时，这些属性与clientWidth和clientHeight相等</p></li></ul><h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><ul><li><p>element.clientHeight:只读，对于没有定义CSS或者内联布局盒子的元素为0，同时它是元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距。clientHeight 可以通过 CSS height + CSS padding- 水平滚动条高度 (如果存在)来计算.</p></li><li><p>clientleft:元素的内边距的外边缘和边框的外边缘的距离，实际就是边框的左边框宽度</p></li><li><p>clienttop:同理边框的上边框的宽度</p></li><li><p>clientwidth:用于描述元素内尺寸宽度，是指 元素内容+内边距 大小，不包括边框、外边距、滚动条部分</p></li></ul><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><p>无限加载：element.scrollHeight - element.scrollTop === element.clientHeight</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;之前对DOM接口中各种height，height，scrollHeight，clientHeight，clientWidth等等概念有大概的
      
    
    </summary>
    
    
      <category term="HTML" scheme="http://stan1812.github.io/tags/HTML/"/>
    
      <category term="JavaScript" scheme="http://stan1812.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>小程序&lt;宜墨&gt;开发小记</title>
    <link href="http://stan1812.github.io/2018/02/14/LearnKoa/"/>
    <id>http://stan1812.github.io/2018/02/14/LearnKoa/</id>
    <published>2018-02-14T08:44:33.000Z</published>
    <updated>2018-02-14T09:35:48.510Z</updated>
    
    <content type="html"><![CDATA[<p>在今天这个特别的日子，我，一个单身狗，感觉自己浑身散发着清香。</p><p>但是在今天，回到家就重度拖延症的我也算是终于完成了自己的第一个微信小程序的完整开发。一个想要写给妈妈的小程序。</p><p>先来说下技术栈吧：<br><figure class="highlight xl"><table><tr><td class="code"><pre><div class="line">前端：</div><div class="line">    微信小程序</div><div class="line">后端(restful api)：</div><div class="line">    <span class="built_in">NodeJS</span></div><div class="line">    koa2</div><div class="line">    monk</div><div class="line">    mongodb</div><div class="line">    corntab</div><div class="line">    PM2</div></pre></td></tr></table></figure></p><p>至于设计和产品嘛。。当然也是我啊（滑稽🙈）</p><p>小程序在之前已经大概的说过一点，这次说下后台的一些东西。</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据来源于一个app “观之”（原每日一读），在拿到他的接口之后，本来是可以直接拿来用就不用写后台，但是打算在微信上架，担心会有侵权的一些问题，期间也咨询了几个学法律的同学，但是得到的最终答案是，这个东西很模糊。于是为了避免麻烦，我决定把先写个爬虫把数据爬一下，因为内容都是各种各种杂文，所以也就不用担心侵权的问题了。</p><p>这个爬虫应该可以说是最简单的爬虫了，上去就是干，node一把梭，经过调试就开始爬，很快就爬到了从今年到2012年左右的数据，差不多够了。然后还就是使用corntab加一个定时任务，每天零点定时抓取更新的内容，存进mongodb。</p><h3 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h3><p>寒假看了一些koa的东西，然后就决定使用koa。刚开始看koa的时候着实被koa的开放吓了一跳，项目目录完全自己按需搭建。</p><p>虽然有一些开发者所搭建的generator但是为了把握一下整个的结构所以就自己搭建了项目结构:</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[root@VM_56_194_centos Wechat-BE]<span class="comment"># tree -L 1</span></div><div class="line">.</div><div class="line">|-- app.js</div><div class="line">|-- controller.js</div><div class="line">|-- controllers</div><div class="line">|-- ecosystem.config.js</div><div class="line">|-- node_modules</div><div class="line">|-- package.json</div><div class="line">`-- readme.md</div></pre></td></tr></table></figure><p>具体的技术细节的话代码地址在此<a href="https://github.com/Stan1812/Wechat-BE" target="_blank" rel="external">https://github.com/Stan1812/Wechat-BE</a></p><p>部署到服务器，然后使用PM2做进程守护。开始提供服务</p><p>现在koa只是基本的使用，开学之后学习深入些再写koa的相关东西</p><h3 id="monk"><a href="#monk" class="headerlink" title="monk"></a>monk</h3><p>monk感觉是在小项目中很好用的一个node连接mongodb的工具，相比mongose轻便精巧很多，正如他的简介“A tiny layer that provides simple yet substantial usability improvements for MongoDB usage within Node.JS.”<br>留个地址吧，官网：<a href="https://automattic.github.io/monk/" target="_blank" rel="external">https://automattic.github.io/monk/</a></p><hr><p>溜了溜了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在今天这个特别的日子，我，一个单身狗，感觉自己浑身散发着清香。&lt;/p&gt;
&lt;p&gt;但是在今天，回到家就重度拖延症的我也算是终于完成了自己的第一个微信小程序的完整开发。一个想要写给妈妈的小程序。&lt;/p&gt;
&lt;p&gt;先来说下技术栈吧：&lt;br&gt;&lt;figure class=&quot;highlig
      
    
    </summary>
    
    
      <category term="-JS -NodeJS" scheme="http://stan1812.github.io/tags/JS-NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序之不完全胡乱指东西南北</title>
    <link href="http://stan1812.github.io/2018/01/24/wechatapp/"/>
    <id>http://stan1812.github.io/2018/01/24/wechatapp/</id>
    <published>2018-01-24T13:37:33.000Z</published>
    <updated>2018-01-24T15:07:39.158Z</updated>
    
    <content type="html"><![CDATA[<p>今天考完了试，很开心，晚上没什么事，来写篇博客。</p><h3 id="先吹吹水"><a href="#先吹吹水" class="headerlink" title="先吹吹水"></a>先吹吹水</h3><p>在期末考试之前的某段时间，差不多就是跳一跳火的那段时间吧，由于无聊，去微信公众平台注册了一个账号，然后就对着文档开始了小程序的玩耍之路。之前虽然小程序挺火的，但是也一直没有什么兴趣去看。。主要还是感觉限制太多了叭，个人总感觉小程序，毕竟还是微信一家的东西。像我这种菜鸡也就玩一玩叭。</p><p>之前看到过一个有点火的小程序，是一个显示手机信息的小工具，就是比如手机的内存啊，型号什么的信息，然后就有了好几万的用户，然后在我看了小程序的文档之后发现了一个这样的API<code>wx.getSystemInfo(OBJECT)</code>。基本上就是这个API了叭。。选对了目标用户真的是能飞。</p><h3 id="开放的API"><a href="#开放的API" class="headerlink" title="开放的API"></a>开放的API</h3><p>小程序所开放的能力感觉还是很强的，非常方便的就能调用手机的各种接口，文件，设备，包括GPS，网络状态，罗盘等，甚至对于剪切板这个东西，浏览器出于安全考虑一直不肯完全放开权限，要写各种hack的东西，微信也提供了很好的封装<code>wx.getClipboardData(OBJECT)</code> <code>wx.setClipboardData(OBJECT)</code>，这是微信有点大胆？（也可能是我多想了）不错。</p><p>除此之外，小程序的媒体能力也很丰富，录音，视频，相机，甚至实时音视频接口都有提供。对于我们这种辣鸡开发者确实是些可玩性很强的东西。</p><p>网络方面，除了常规的request，还提供了websocket的接口，确实是很周到。然后也开放了设置导航条，tabBar，置顶信息的API，给了更大的客户定制能力。</p><p>至于API，其他的不多说了。文档说的不能再清楚了。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><h4 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h4><ul><li>.json  JSON 配置文件(package.json)</li><li>.wxml  WXML 模板文件(.html/.vue)</li><li>.wxss  WXSS 样式文件</li><li>.js    JS 脚本逻辑文件<h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4>这是我写的一小demo</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[root@VM_56_194_centos wechat_demo]<span class="comment"># tree -L 2</span></div><div class="line">.</div><div class="line">|-- app.js </div><div class="line">|-- app.json //当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等</div><div class="line">|-- app.wxss</div><div class="line">|-- main.js</div><div class="line">|-- main.json</div><div class="line">|-- main.wxml</div><div class="line">|-- pages</div><div class="line">|   |-- artlist</div><div class="line">|   |   |-- list.js</div><div class="line">|   |   |-- list.json</div><div class="line">|   |   |-- list.wxml</div><div class="line">|   |   `-- list.wxss</div><div class="line">|   |-- index</div><div class="line">|   |   |-- index.js</div><div class="line">|   |   |-- index.wxml</div><div class="line">|   |   `-- index.wxss</div><div class="line">|   `-- logs</div><div class="line">|       |-- logs.js</div><div class="line">|       |-- logs.json</div><div class="line">|       |-- logs.wxml</div><div class="line">|       `-- logs.wxss</div><div class="line">|-- project.config.json</div><div class="line">|-- README.md</div><div class="line">|-- utils</div><div class="line">|   `-- util.js</div><div class="line">`-- wxParse</div><div class="line">    |-- emojis</div><div class="line">    |-- html2json.js</div><div class="line">    |-- htmlparser.js</div><div class="line">    |-- showdown.js</div><div class="line">    |-- wxDiscode.js</div><div class="line">    |-- wxParse.js</div><div class="line">    |-- wxParse.wxml</div><div class="line">    `-- wxParse.wxss</div></pre></td></tr></table></figure><p>这是一个每日一文的小东西，每天随机推荐一片文章。</p><p>其实结构还是很清晰的。。wxparse是一个解析HTML的工具，因为获取的文章数据是带html标签的，需要解析，但是小程序没有像V-html这样舒服东西，所以要找其他的工具，但是使用起来需要直接把文件手动复制到目录下，没有开放的包管理器，可能这就是相对比较封闭的一些劣势吧。</p><h3 id="大概思想"><a href="#大概思想" class="headerlink" title="大概思想"></a>大概思想</h3><p>依然是如今最火的MVVM思想，数据驱动，挺多地方和Vue还是很像的，要想上手做些demo还是挺快的。基本是都是常见的数据绑定，然后各种 <strong>钩子函数</strong>。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 页面的初始数据</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  data: &#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面加载</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onLoad: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面初次渲染完成</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onReady: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面显示</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onShow: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面隐藏</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onHide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面卸载</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onUnload: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 页面相关事件处理函数--监听用户下拉动作</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onPullDownRefresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 页面上拉触底事件的处理函数</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onReachBottom: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 用户点击右上角分享</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onShareAppMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>还是比较容易理解的。</p><p>组件之间的通信，数据管理，应该是相对来说比较重要的东西了。但是文档中没有提太多，然后这里有一篇比较好的文章：<img src="https://segmentfault.com/a/1190000008895441" alt="https://segmentfault.com/a/1190000008895441"><br>比较容易想到的是，最粗暴的，使用localStorage，简单粗暴。然后比较好的方法应该是使用<code>globalData</code>来处理吧。<br>深一点的其他东西还讨论不来，就先这样吧~</p><p>溜了溜了睡觉睡觉，明天回家！！！🍭</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天考完了试，很开心，晚上没什么事，来写篇博客。&lt;/p&gt;
&lt;h3 id=&quot;先吹吹水&quot;&gt;&lt;a href=&quot;#先吹吹水&quot; class=&quot;headerlink&quot; title=&quot;先吹吹水&quot;&gt;&lt;/a&gt;先吹吹水&lt;/h3&gt;&lt;p&gt;在期末考试之前的某段时间，差不多就是跳一跳火的那段时间吧，由
      
    
    </summary>
    
    
      <category term="-JS -技术" scheme="http://stan1812.github.io/tags/JS-%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>初探parcel📦</title>
    <link href="http://stan1812.github.io/2018/01/13/parcel/"/>
    <id>http://stan1812.github.io/2018/01/13/parcel/</id>
    <published>2018-01-13T09:32:37.000Z</published>
    <updated>2018-01-13T10:58:14.082Z</updated>
    
    <content type="html"><![CDATA[<p>在期末复习的一个难受的下午，也就是现在，我突然想起了之前看到的号称零配置且最快的前端打包神器：Parcel，于是我放下数字逻辑。准备看看这货到底什么样。</p><p>github地址：<a href="https://github.com/parcel-bundler/parcel" target="_blank" rel="external">https://github.com/parcel-bundler/parcel</a></p><p>首先想要吐槽一下。。Parcel图标确实是不怎么好看哈哈。一个纸箱子。。不过可以说是直接了当的展示出了他的功能。打包嘛。</p><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>先来官网瞅一瞅（说的确实挺厉害的）</p><blockquote><p>🚀 极速打包时间<br>Parcel 使用 worker 进程去启用多核编译。同时有文件系统缓存，即使在重启构建后也能快速再编译。</p><p>📦 将你所有的资源打包<br>Parcel 具备开箱即用的对 JS, CSS, HTML, 文件 及更多的支持，而且不需要插件。</p><p>🐠 自动转换<br>如若有需要，Babel, PostCSS, 和PostHTML甚至 node_modules 包会被用于自动转换代码.</p><p>✂️ 零配置代码分拆<br>使用动态 import() 语法, Parcel 将你的输出文件束(bundles)分拆，因此你只需要在初次加载时加载你所需要的代码。</p><p>🔥 热模块替换<br>Parcel 无需配置，在开发环境的时候会自动在浏览器内随着你的代码更改而去更新模块。</p><p>🚨 友好的错误日志<br>当遇到错误时，Parcel 会输出 语法高亮的代码片段，帮助你定位问题</p></blockquote><p>官网还提供了这样一个比较</p><table><thead><tr><th style="text-align:left">打包工具</th><th style="text-align:left">时间</th></tr></thead><tbody><tr><td style="text-align:left">browserify</td><td style="text-align:left">22.98s</td></tr><tr><td style="text-align:left">webpack</td><td style="text-align:left">20.71s</td></tr><tr><td style="text-align:left">parcel</td><td style="text-align:left">9.98s</td></tr><tr><td style="text-align:left">parcel - with cache</td><td style="text-align:left">2.64s</td></tr></tbody></table><blockquote><p>基于一个合理大小的应用，包含1726个模块， 6.5M 未压缩大小. 在一台有4个物理 CPU 的 2016 MacBook Pro 上构建。</p></blockquote><p>相比的话，确实是相当的快，而且二次打包简直要起飞。。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">先安装（当然你也可以使用yarn）</div><div class="line">mkdir parceltest &amp;&amp; <span class="built_in">cd</span> parceltest &amp;&amp; npm install parcel-bundler --save</div></pre></td></tr></table></figure><p>文档中说的是Parcel 可以使用任何类型的文件作为入口，但是最好还是使用 HTML 或 JavaScript 文件。如果在 HTML 中使用相对路径引入主要的 JavaScript 文件，Parcel 也将会对它进行处理将其替换为相对于输出文件的 URL 地址。</p><p>然后，创建一个 index.html 和 index.js 文件。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">touch index.html &amp;&amp; touch index.js</div></pre></td></tr></table></figure></p><p>index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p>index.js<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"hello parcel"</span>);</div></pre></td></tr></table></figure></p><p>Parcel 内置了一个当你改变文件时能够自动重新构建应用的开发服务器，而且为了实现快速开发，该开发服务器支持热模块替换。在package.json指出即可：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="string">"scripts"</span>:&#123;</div><div class="line">  <span class="string">"start"</span>:<span class="string">"parcel index.html"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后，npm start<br>现在在浏览器中打开 <a href="http://localhost:1234/。也可以使用" target="_blank" rel="external">http://localhost:1234/。也可以使用</a> -p <port number=""> 选项覆盖默认的端口。<br>确实很快。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">built <span class="keyword">in</span> 16ms</div></pre></td></tr></table></figure></port></p><p>此外支持零配置代码拆分，也是挺舒服的。</p><p>至于sass，babel什么的，文档说的看起来于是相当的易于安装，基本无配置。支持TS，貌似还支持vue的组件和react的组件。</p><p>不过目前就看了这么多，边看文档，边简单的测试，边写这个小体验。只是接触了最基础的东西，总体给人的感觉是很轻，很快。很友好。不过据说webpack 4.0也要加入默认配置（可怜我webapck 3.0都不怎么会用。。）不知道parcel能不能真的火起来。不过一些小项目尝尝鲜还是没有问题的叭。</p><p>复习实在无聊，来看下这个东西还是很解闷的。。就先这么多吧，，复习要紧复习要紧。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在期末复习的一个难受的下午，也就是现在，我突然想起了之前看到的号称零配置且最快的前端打包神器：Parcel，于是我放下数字逻辑。准备看看这货到底什么样。&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/parcel-bundler/p
      
    
    </summary>
    
    
      <category term="-技术 -工具" scheme="http://stan1812.github.io/tags/%E6%8A%80%E6%9C%AF-%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Crontab略解🎉</title>
    <link href="http://stan1812.github.io/2018/01/12/Crontab/"/>
    <id>http://stan1812.github.io/2018/01/12/Crontab/</id>
    <published>2018-01-11T16:22:06.000Z</published>
    <updated>2018-01-13T10:35:48.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Crond-amp-amp-Crontab"><a href="#Crond-amp-amp-Crontab" class="headerlink" title="Crond&amp;&amp;Crontab"></a>Crond&amp;&amp;Crontab</h3><p>先说下他俩是干啥么的。</p><blockquote><p>crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p><p>然后，Linux下的任务调度分两类，系统任务调度和用户任务调度。</p><p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。</p><p>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致</p><h3 id="Crontab-格式："><a href="#Crontab-格式：" class="headerlink" title="Crontab 格式："></a>Crontab 格式：</h3><table><thead><tr><th style="text-align:left">分</th><th style="text-align:left">时</th><th style="text-align:left">日</th><th style="text-align:left">月</th><th style="text-align:left">周</th><th style="text-align:left">命令</th></tr></thead><tbody><tr><td style="text-align:left">minute</td><td style="text-align:left">hour</td><td style="text-align:left">day</td><td style="text-align:left">month</td><td style="text-align:left">week</td><td style="text-align:left">command</td></tr><tr><td style="text-align:left">0~59</td><td style="text-align:left">0~23</td><td style="text-align:left">0~31</td><td style="text-align:left">0~12</td><td style="text-align:left">0~7</td><td style="text-align:left">系统命令/脚本文件 </td></tr></tbody></table><p>且均为整数<br>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p></blockquote><p>在以上各个字段中，还可以使用以下特殊字符：</p><p>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</p><p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</p><p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</p><p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="crond"><a href="#crond" class="headerlink" title="crond"></a>crond</h4><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">安装crontab：</div><div class="line"></div><div class="line">yum install crontabs</div><div class="line"></div><div class="line"></div><div class="line">/sbin/service crond start //启动服务</div><div class="line"></div><div class="line">/sbin/service crond stop //关闭服务</div><div class="line"></div><div class="line">/sbin/service crond restart //重启服务</div><div class="line"></div><div class="line">/sbin/service crond reload //重新载入配置</div><div class="line"></div><div class="line">查看crontab服务状态：</div><div class="line"></div><div class="line">service crond status</div><div class="line"></div><div class="line">手动启动crontab服务：</div><div class="line"></div><div class="line">service crond start</div><div class="line"></div><div class="line">查看crontab服务是否已设置为开机启动，执行命令：</div><div class="line"></div><div class="line">ntsysv</div><div class="line"></div><div class="line">加入开机自动启动：</div><div class="line"></div><div class="line">chkconfig –level 35 crond on</div></pre></td></tr></table></figure><h4 id="Crontab"><a href="#Crontab" class="headerlink" title="Crontab"></a>Crontab</h4><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">crontab [-u user] file</div><div class="line"></div><div class="line">crontab [-u user] [ -e | -l | -r ]</div></pre></td></tr></table></figure><p>2．命令功能：</p><p>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</p><p>3．命令参数：</p><ul><li>-u user : 用来设定某个用户的crontab服务，例如，“-u xxx”表示设定xxx用户的crontab服务，此参数一般有root用户来运行.</li><li>file : file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li><li>-e : 编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</li><li>-l : 显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</li><li>-r : 从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</li><li>-i : 在删除用户的crontab文件时给确认提示。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">比如每天定时启动一个Node的爬虫（结果展示了部分数据）</div><div class="line">[root@VM_56_194_centos ~]<span class="comment">#  crontab -l</span></div><div class="line">2 0 * * * /root/.nvm/versions/node/v8.8.0/bin/node /home/art-spider/Daily-article-spider/today.js</div></pre></td></tr></table></figure><p>最后推荐一个非常好用的帮助你写crontab命令的网站：<a href="https://crontab.guru/#1_0_*_*_*" target="_blank" rel="external">https://crontab.guru/#1<em>0</em><em>_</em>_*</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Crond-amp-amp-Crontab&quot;&gt;&lt;a href=&quot;#Crond-amp-amp-Crontab&quot; class=&quot;headerlink&quot; title=&quot;Crond&amp;amp;&amp;amp;Crontab&quot;&gt;&lt;/a&gt;Crond&amp;amp;&amp;amp;Crontab
      
    
    </summary>
    
      <category term="技术" scheme="http://stan1812.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://stan1812.github.io/tags/Linux/"/>
    
      <category term="技术" scheme="http://stan1812.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>几种排序</title>
    <link href="http://stan1812.github.io/2018/01/02/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F/"/>
    <id>http://stan1812.github.io/2018/01/02/各种排序/</id>
    <published>2018-01-02T15:22:04.000Z</published>
    <updated>2018-01-04T10:04:56.921Z</updated>
    
    <content type="html"><![CDATA[<p>学习数据结构，最后接触了很多关于排序的东西。一些比较常见且使用较多的排序来总结一下。另外那些牛X的排序感觉理解还是有些难度的。。下面来写一下各种排序的JS实现。</p><p>先上一张图：<br><img src="/imgs/sort.png" alt=""></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序应该可以说是我接触的第一个排序算法，也是一种思想很容易理解的算法。</p><h4 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h4><p>相邻的数据进行两两比较，小数放在前面，大数放在后面，一趟下来，最小的数被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成</p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">//相邻元素两两对比</span></div><div class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">//元素交换</span></div><div class="line">                arr[j+<span class="number">1</span>] = arr[j];</div><div class="line">                arr[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h4 id="思想：-1"><a href="#思想：-1" class="headerlink" title="思想："></a>思想：</h4><p>先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> minIndex, temp;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</div><div class="line">        minIndex = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">//寻找最小的数</span></div><div class="line">                minIndex = j;                 <span class="comment">//将最小数的索引保存</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp = arr[i];</div><div class="line">        arr[i] = arr[minIndex];</div><div class="line">        arr[minIndex] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>将数据分为两部分，有序部分与无序部分，一开始有序部分包含第1个元素，依次将无序的元素插入到有序部分，直到所有元素有序。插入排序又分为直接插入排序、二分插入排序、链表插入等，这里只讨论直接插入排序。它是稳定的排序算法，时间复杂度为O(n^2)</p><h4 id="实现：-1"><a href="#实现：-1" class="headerlink" title="实现："></a>实现：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> preIndex, current;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        preIndex = i - <span class="number">1</span>;</div><div class="line">        current = arr[i];</div><div class="line">        <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</div><div class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex];</div><div class="line">            preIndex--;</div><div class="line">        &#125;</div><div class="line">        arr[preIndex+<span class="number">1</span>] = current;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>####　思想：<br>希尔排序是插入排序的一种更高效率的实现。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。</p><h4 id="实现：-2"><a href="#实现：-2" class="headerlink" title="实现："></a>实现：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length,</div><div class="line">        temp,</div><div class="line">        gap = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(gap &lt; len/<span class="number">3</span>) &#123;          <span class="comment">//动态定义间隔序列</span></div><div class="line">        gap =gap*<span class="number">3</span>+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (gap; gap&gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">3</span>)) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</div><div class="line">            temp = arr[i];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i-gap; j &gt; <span class="number">0</span> &amp;&amp; arr[j]&gt; temp; j-=gap) &#123;</div><div class="line">                arr[j+gap] = arr[j];</div><div class="line">            &#125;</div><div class="line">            arr[j+gap] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h4><p>快速排序是目前在实践中非常高效的一种排序算法，它不是稳定的排序算法，平均时间复杂度为O(nlogn)，最差情况下复杂度为O(n^2)。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h4 id="最基本："><a href="#最基本：" class="headerlink" title="最基本："></a>最基本：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//快速排序  </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr,left,right</span>)</span>&#123;</div><div class="line">&#123;  </div><div class="line">    <span class="keyword">if</span> (left &lt; right)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">let</span> i = left, j = right, x = arr[left];  </div><div class="line">        <span class="keyword">while</span> (i &lt; j)  </div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[j] &gt;= x) </div><div class="line">                j--;    </div><div class="line">            <span class="keyword">if</span>(i &lt; j)   </div><div class="line">                arr[i++] = arr[j];  </div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt; x)</div><div class="line">                i++;    </div><div class="line">            <span class="keyword">if</span>(i &lt; j)   </div><div class="line">                arr[j--] = arr[i];  </div><div class="line">        &#125; </div><div class="line">        arr[i] = x;  </div><div class="line">        quick_sort(arr, left, i - <span class="number">1</span>); <span class="comment">// 递归调用   </span></div><div class="line">        quick_sort(arr, i + <span class="number">1</span>, right);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="改进一"><a href="#改进一" class="headerlink" title="改进一:"></a>改进一:</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr,left,right</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(left&lt;right)&#123;</div><div class="line">    <span class="keyword">let</span> x = arr[right], i = left<span class="number">-1</span>, temp</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = left; j&lt;=right;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(arr[j]&lt;=x)&#123;</div><div class="line">        i++</div><div class="line">        temp = arr[i]</div><div class="line">        arr[i]=arr[j]</div><div class="line">        arr[j]=temp</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    quickSort(arr, left, i<span class="number">-1</span>)</div><div class="line">    quickSort(arr, i+<span class="number">1</span>, right)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> arr</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="改进二"><a href="#改进二" class="headerlink" title="改进二:"></a>改进二:</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span> (<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(arr.length &lt;=<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> arr</div><div class="line">  &#125; <span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>)</div><div class="line">    <span class="keyword">let</span> pivot =arr.splice(pivotIndex,<span class="number">1</span>)[<span class="number">0</span>]</div><div class="line">    <span class="keyword">let</span> left =[]</div><div class="line">    <span class="keyword">let</span> right =[]</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">      <span class="keyword">if</span>(arr[i]&lt;pivot)&#123;</div><div class="line">        left.push(arr[i])</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        right.push(arr[i])</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> quickSort(left).concat([pivot],quickSort(right))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习数据结构，最后接触了很多关于排序的东西。一些比较常见且使用较多的排序来总结一下。另外那些牛X的排序感觉理解还是有些难度的。。下面来写一下各种排序的JS实现。&lt;/p&gt;
&lt;p&gt;先上一张图：&lt;br&gt;&lt;img src=&quot;/imgs/sort.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>2017总结</title>
    <link href="http://stan1812.github.io/2017/12/30/2017/"/>
    <id>http://stan1812.github.io/2017/12/30/2017/</id>
    <published>2017-12-30T14:28:37.000Z</published>
    <updated>2017-12-31T18:15:16.363Z</updated>
    
    <content type="html"><![CDATA[<p>现在是2017年12月30日晚，公元2017年还有一天就要过去，公元2018年就要到来了。入坑前端正儿八经开始写代码差不多有10个月了（本来想写一年，仔细算了算还没有满一年。想来要在年度总结煽煽情都没有机会=。=），回过头来看颇有感触。虽然总觉得真正意义上的2017年还远远没有过去，但是年度总结差不多也要开始写了。关于技术，关于生活，思考事情的方式和看待问题的方式。现在先来留一个坑，可能会间隔的来写。</p><p><img src="/imgs/2017.jpg" alt=""></p><p>突然想要写点东西，那就开始写吧</p><hr><h2 id="关于技术-📐"><a href="#关于技术-📐" class="headerlink" title="关于技术 📐"></a>关于技术 📐</h2><h3 id="技术之路的开始"><a href="#技术之路的开始" class="headerlink" title="技术之路的开始"></a>技术之路的开始</h3><blockquote><p>我想我在2017年所做的最正确的事情可以说是开始学习前端并且爱上前端然后开始正儿八经的写代码。</p></blockquote><p>大概在17年初，想要尝试去加入家园工作室，在经历了第一次期末考试的突击月之后，开始了完全放松的寒假。第一个完全放松，没有一点的压力的寒假。本来计划的前端学习被抛在了脑后。可以说是很遗憾了。一个寒假很快过去，代码一点没动。可能是开学之后突然觉得自己太颓，于是在大概3月份开始正式的学习前端，并且真正的第一次意识到了写代码的乐趣。</p><p>三月份的时候过的挺有意思的，每天差不多就是看书，看mooc，敲代码。然后在腾讯云搭了个博客，开始了写博客的习惯。</p><p>有点意思。</p><p>那一段时间花了很多的时间在代码上面，学了一些东西，也写了一些东西，当时的想法也都在之前的博客里有写。</p><h3 id="家园"><a href="#家园" class="headerlink" title="家园"></a>家园</h3><p>在4月份上旬的某个周末躺尸的下午突然收到了钟伟杰老哥的一个信息，问我要不要来试下家园的笔试，于是就去参加了家园的春招。</p><p>感谢成成和子健收留了我。</p><p>家园工作室可以说是我的真正的技术启蒙的地方了。4月10日收到了家园的录用邮件，那个下午记得还挺清楚的，因为刚考完电工期中考试，嗯。</p><p>在进入家园的两个月基本上是处于放养阶段，没有写项目，就是自由的想学什么学什么。那段时间应该是学了挺多关于前端的一些挺杂的基础的东西了，然后玩些自己想玩的东西，用CSS写了一些自认为有点意思的东西。看了挺多的书，也写了一些页面，过的还算充实。</p><h3 id="暑期"><a href="#暑期" class="headerlink" title="暑期"></a>暑期</h3><p>这个时候差不多就来到了６、７月份，期末考试，然后开始了留校写项目。</p><p>暑假留校，每天７点起床，叫上老田钟伟杰等天健众基佬，然后骑去机房敲代码。到了晚上9点，天健摩拜车队浩浩荡荡从休闲骑回天健。暑假开始上车Vue，以及Vue的全家桶，然后开始接触家园的项目。这些之前的博客也有写，所以现在就不再详细写了~</p><p>在留校的那一个多月，应该是技术进步最快的一段时间了吧。</p><p>大概8月初的时候，回了家，在家养鱼了一段时间，补了留校所欠的懒觉。很舒服。然后出去玩了一段时间，也很舒服。看了一些mysql的东西，书看的倒不多。</p><h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>9月又开学了。emmm，然后开始完善云家园综测的相关模块，看了学长所搭的云家园的整个架构方面的东西，云家园算是个挺大的spa项目了，然后发现很多地方不理解=。= 除此之外对Vue的一些坑也有了一些经验。除此之外就是招新and学校运动会的尬舞。整个学院，大一到大三，一个月，浪费别人的时间就是谋财害命，但愿学院领导心中会有一丝不安（虽然知道他们不会）。一个月浪费了很多时间，很多的精力，技术方面没有看多少东西.</p><p>10月份开始接触NodeJS，跟着书敲了一些小demo，然后用node写了一些有意思的小爬虫，爬了点不可描述的东西，🙈还有些可以描述的东西，也写了点解放双手比如签到什么的小爬虫，然后去了解了下linux的定时任务，开个定时任务，很舒服。使用express写了一个小小的小东西，使用的是ejs模板，了解了后端的一些东西。之后尝试着试一下前后端分离，前端使用Vue，图方便用了MuseUI，后台使用node，写的是restful的api，然后数据库用的是mongodb。</p><p>12月份，开始写工作室的几个项目，时间过的很快，差不多就是这些了吧。</p><h2 id="关于生活-🎉"><a href="#关于生活-🎉" class="headerlink" title="关于生活  🎉"></a>关于生活  🎉</h2><p>可以说开始写代码之后，生活方式还是发生了很大的变化的。大一上学期的时候，每天看看书打打游戏睡睡觉，然后参加参加一些社团活动，按部就班，但是却总觉得差点东西。之后开始写代码，然后生活其实变化了挺多的变化的，比如睡觉时间明显的推后😂<br>然后就是在家园认识了这么多的志同道合的伙伴们。我发现了一个规律，就是开发的同志们，每次遇到基本上都会问一句话，最近在搞什么。大家一块儿吹吹水开开车很有意思。</p><p>除此之外，看了一些非技术类的书，看了好多小说and电影，各种类型。</p><p>看待事情的方式好像也有了点变化，从之前的可能有些时候很有些偏激或者片面，现在看问题可能学会了更全面一些也随和了许多，可能也归于佛系了吧。</p><p>另外，终于结束了2017年的单身生活，</p><p>迎来2018年的单身生活。</p><p>突然发现想写的挺多的，但是生活却又太复杂太零碎，就写这些吧。</p><p>新年快乐！！！🎉🎉🎉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是2017年12月30日晚，公元2017年还有一天就要过去，公元2018年就要到来了。入坑前端正儿八经开始写代码差不多有10个月了（本来想写一年，仔细算了算还没有满一年。想来要在年度总结煽煽情都没有机会=。=），回过头来看颇有感触。虽然总觉得真正意义上的2017年还远远
      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
      <category term="生活" scheme="http://stan1812.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Merry Xmas</title>
    <link href="http://stan1812.github.io/2017/12/23/Xmas/"/>
    <id>http://stan1812.github.io/2017/12/23/Xmas/</id>
    <published>2017-12-23T15:33:53.000Z</published>
    <updated>2017-12-25T11:53:20.411Z</updated>
    
    <content type="html"><![CDATA[<p>现在是2017年12月23日晚23:35分，刚看完了芳华原著，电影改编的地方还是挺多的，原著所写的很多东西比电影要不堪的多。现在听着电影芳华的配乐。因为选修的mooc明天考试截止，而我可还有很多没有刷完，想写个脚本刷一刷发现有点麻烦。。又怕控制不好被后台监测到，遂放弃。现在决定手刷。有些无聊，又不想写代码，便想着好久没有写过博客了，现在正好来写一篇。一些思考，和一些牢骚。</p><h2 id="这是第一个小标题"><a href="#这是第一个小标题" class="headerlink" title="这是第一个小标题"></a>这是第一个小标题</h2><p>想一想上一篇博客，2017.12.15，时间已经过去了很久。快十天了。而距离上一篇真正意义上的总结不知道已经距离了多长时间。不知道每天都做了些什么，想想已经很久没有完整的看过一本非技术类的书了，技术类的书也好久没有专注的研究一本，虽然也看了一些，但总觉得没有专注。除了写代码，基本处于每天放羊的阶段。这段时间总是被需求追着跑，写不完的需求。我能怎么办。我也很绝望啊。。</p><p>最近两周肝了两个晚上了，一个是要写摇一摇，一个是因为要提前保密以给大家圣诞节惊喜的小项目，所以项目组只有一个前端和一个后端。前端兼设计，后端兼产品。（UI设计很酷，但是没有一点专业知识还是挺难的，前端真的需要了解一些设计的东西）突然要上线，所以昨天晚上和小黑老哥肝到了4、5点，为什么要说4、5点呢？因为我4点睡了，而小黑5点睡。然后又有bug，然后突然来了设计要改图。。于是我们从11点又肝到了下午2点。然后小黑的女朋友来陪她吃了饭，而我则和肘子睿吃了一盆狗粮&amp;一份盖浇饭。</p><p>=。= 说起来，我什么时候才会有个女朋友。</p><h2 id="还是有一些开心的事情"><a href="#还是有一些开心的事情" class="headerlink" title="还是有一些开心的事情"></a>还是有一些开心的事情</h2><p>看了芳华的预告片，就很想看这个电影，最初对这个电影留下的最深的印象是女主角长的真的很仙儿，一种好像不属于这个年代的美。但是被项目缠身，一直拖着，终于在周三晚上的时候下定决心买了票和肘子睿在周四的晚上看了这部电影。看完之后感觉很庆幸。庆幸暂时放下了代码来看了这部电影，同时内心又很安静，不像之前看过电影时要么骂电影拍的烂，要么表面平静，内心澎湃不能自已，回味电影。看完这个电影之后，想说很多，但又不知从何说起，不如不说。芳华的配乐可以说是相当的好，氛围很好，而且之后如果你单独拿出来听，你真的会惊叹于这部电影的配乐。还有芳华的舞蹈，真的是很美，虽然我并不懂舞蹈，但还是让人感受到了舞蹈的美，可能艺术真的是来自于人们本身对美的追求，而人类本性中对美是有种本能的鉴赏和体会的吧。这个电影可能是最近最开心的一件事情了。虽然它可能间接导致了周五晚上的肝到4点。</p><h2 id="有点难受的事情"><a href="#有点难受的事情" class="headerlink" title="有点难受的事情"></a>有点难受的事情</h2><p>一件事情，最终的结果，不管是好是坏，你尽力做了和你没有尽力做或者说根本没有尝试去尽力做，最终你的感受是完全不一样的。这是一个很浅显的东西，从小就有人教育我们这个道理，但是我们依然做不好。是的，我们听了很多话，依然不容易过好这一生，是的这句话我改了一些，因为我觉得其实还是有可能过好这一生的。可能由于种种原因，一件事情你没有尽力去做，之后不管遗憾还是什么，也都这样了。遗憾请藏在心中。</p><h2 id="放在最后"><a href="#放在最后" class="headerlink" title="放在最后"></a>放在最后</h2><p>最后想分享刚刚看芳华感触最深的一句话：</p><blockquote><p>这回是我和郝淑雯笑得嘎嘎响。不快乐的人，都懂得我们这样的笑。放下了包袱，破碎了梦想，就是那种笑。笑我们曾经认真过的所有事儿。前头没有值得期盼的好事，身后也没有留下值得自豪的以往，就是无价值的流年，也所剩不多，明明破罐子，也破摔不起，摔了连破的都没了，那种笑。就是热诚情愿邀请人家摸，也没人摸了，既然最终没人摸，当时吝啬什么? 反正最终要残剩，最终是狗剩儿，当时神圣什么? 对，就那种笑。</p></blockquote><p>然后祝自己圣诞快乐</p><p><img src="/imgs/xmas2.png" alt=""></p><p>然后还有一句话：</p><blockquote><p>life runs on the code</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是2017年12月23日晚23:35分，刚看完了芳华原著，电影改编的地方还是挺多的，原著所写的很多东西比电影要不堪的多。现在听着电影芳华的配乐。因为选修的mooc明天考试截止，而我可还有很多没有刷完，想写个脚本刷一刷发现有点麻烦。。又怕控制不好被后台监测到，遂放弃。现在
      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
      <category term="生活" scheme="http://stan1812.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>我为何如此垃圾</title>
    <link href="http://stan1812.github.io/2017/12/15/why-am-i-so-laji/"/>
    <id>http://stan1812.github.io/2017/12/15/why-am-i-so-laji/</id>
    <published>2017-12-15T14:17:13.000Z</published>
    <updated>2017-12-15T14:38:57.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why-are-you-so-diao？"><a href="#Why-are-you-so-diao？" class="headerlink" title="Why are you so diao？"></a>Why are you so diao？</h2><h3 id="Why-am-i-so-laji"><a href="#Why-am-i-so-laji" class="headerlink" title="Why am i so laji?"></a><strong>Why am i so laji?</strong></h3><h3 id="That’s-a-question"><a href="#That’s-a-question" class="headerlink" title="That’s a question"></a><strong>That’s a question</strong></h3><p>只有一个问题，我为什么还是这么辣鸡。</p><p>转眼都8102年了，可是我还是这么垃圾。</p><p>值得反思了。</p><p>唉。</p><p><img src="/imgs/fuck.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Why-are-you-so-diao？&quot;&gt;&lt;a href=&quot;#Why-are-you-so-diao？&quot; class=&quot;headerlink&quot; title=&quot;Why are you so diao？&quot;&gt;&lt;/a&gt;Why are you so diao？&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
      <category term="生活" scheme="http://stan1812.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>JS运算符和类型转换</title>
    <link href="http://stan1812.github.io/2017/11/19/JSLogicalOperators/"/>
    <id>http://stan1812.github.io/2017/11/19/JSLogicalOperators/</id>
    <published>2017-11-18T16:49:58.000Z</published>
    <updated>2017-11-19T06:35:27.103Z</updated>
    
    <content type="html"><![CDATA[<p>之前真的是小瞧了JS的运算符，再看《JS高级程序设计》的时候，甚至都没有深入的了解JS的逻辑运算符，只是走马观花的边跳边看。。今天晚上闲着没事，不想写代码，就想看看一些小框架的源码学习学习。看到了大量的关于运算符骚操作之后，发现原来逻辑表达式还能这么玩，羞愧不已，于是重新搬出红宝书，又查了一些文档，对逻辑表达式来稍微深入探讨一下。因为涉及了很多类型转换，所以对类型转换也来总结一下。（虽然一个===可以解决几乎所有问题。。但还是要了解一下的~）</p><hr><h2 id="逻辑表达式基本知识补充"><a href="#逻辑表达式基本知识补充" class="headerlink" title="逻辑表达式基本知识补充"></a>逻辑表达式基本知识补充</h2><ul><li><p>逻辑非 ！</p><p>逻辑非可以用于ECMAScript中任何值，无论用于任何值都会返回一个布尔值，也就是说，他会先操作数变为一个布尔值，之后对其取反。而同时使用！！则可以达到使用Boolean()的效果了</p><ul><li><p>如果一个操作数是一个对象，返回false;</p></li><li><p>如果一个操作数是一个空字符串，返回false;</p></li><li><p>如果一个操作数是一个非空字符串，返回false;</p></li><li><p>如果一个操作数是一个数值0，返回true;</p></li><li><p>如果一个操作数是任意的非零字符，返回false;</p></li><li><p>如果一个操作数是null，返回true;</p></li><li><p>如果一个操作数是NaN，返回true;</p></li><li><p>如果一个操作数是undefined，返回true;</p></li><li>能够转换为false的表达式有:<ul><li>null;</li><li>NaN;</li><li>0;</li><li>空字符串（””）;</li><li>undefined.</li></ul></li></ul><p>(其实这些东西可以说是很好理解了，，不过还是系统的总结一下)</p></li><li><p>逻辑与</p><p>对于不是布尔值的情况则：</p><ul><li><p>如果第一个操作数是对象，则返回第二个数</p></li><li><p>如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象；</p></li><li><p>如果第两个操作数都是对象，则返回第二个数操作数</p></li><li><p>如果有一个操作数是null，则返回null</p></li><li><p>如果有一个操作数是NaN，则返回第NaN</p></li><li><p>如果第一个操作数是undefined，则返回undefined</p></li></ul><p>逻辑运算符操作对象遵循从左到右的顺序来判断，逻辑与操作符（&amp;&amp;）先判断第一个数，如果第一个数的逻辑判断是true，则还需判断第二个数，结果输出第二个操作数；同理，如果第一个数为false，则不用考虑第二个数了，直接输出第一个数的逻辑判断结果.</p></li><li><p>逻辑或</p></li></ul><p>对于不是布尔值的情况则：</p><ul><li><p>如果第一个操作数是对象，则返第一个操作数</p></li><li><p>如果第一个操作数的求值结果为false，则返回第二个操作数</p></li><li><p>如果两个操作数都是对象，则返回第一个操作数</p></li><li><p>如果两个操作数是null，则返回null</p></li><li><p>如果两个操作数是NaN，则返回NaN</p></li><li><p>如果两个操作数是undefined，则返回undefined </p></li></ul><p>逻辑或(||)的判断是如果第一个操作数的逻辑判断为true，则直接输出第一个操作数，不用再考虑第二个操作数；如果第一个操作数的逻辑判断为false，则还得去判断第二个操作数的逻辑。</p><p>尽管 &amp;&amp; 和 || 运算符能够使用非Boolean值的操作数, 但它们依然被看作是Boolean操作符，因为它们的返回值总是能够被转换为Boolean值。</p><h3 id="短路计算"><a href="#短路计算" class="headerlink" title="短路计算"></a>短路计算</h3><p>由于逻辑表达式的运算的顺序是从左到右,也可以用以下规则进行”短路”计算:</p><p>false &amp;&amp; (anything)  短路计算的结果为false.</p><p>true || (anything)  短路计算的结果为 true.</p><p>该规则确保这些计算的准确性. 注意如果上述表达式中的 anything 部分不能被计算的话,  两边都不会生效.还需要注意的是,上述表达式中的 anything 部分是任意的单个逻辑表达式(小括号中).</p><hr><h2 id="JS表达式中的类型转换"><a href="#JS表达式中的类型转换" class="headerlink" title="JS表达式中的类型转换"></a>JS表达式中的类型转换</h2><p>相信很多前端都会觉得==的设计可以说是很糟糕了，，<br>一直以来都在刻意避免使用== 只用===,就是因为其中的类型转换,但是并不理解其中的具体的原因</p><p>相等本来可以说是很简单的操作了,但是也是对于基本的字符串,数字,布尔值来说,一旦涉及到对象的比较,就复杂了,早期的es的相等和不等都会先进行类型转换.之后的解决方案是使用== and ===</p><p>先来看看红宝书是怎么具体的说的</p><h3 id="amp"><a href="#amp" class="headerlink" title="== != &amp; ===  !=="></a>== != &amp; ===  !==</h3><h4 id=""><a href="#" class="headerlink" title="== !="></a>== !=</h4><p>ECMAScript 中的相等操作符由两个等于号（==）表示，如果两个操作数相等，则返回 true。而不相等操作符由叹号后跟等于号（!=）表示，如果两个操作数不相等，则返回 true。这两个操作符都会<br>先转换操作数（通常称为强制转型），然后再比较它们的相等性。<br>在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：</p><ul><li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而true 转换为 1；</li><li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；</li><li>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类<br>型值按照前面的规则进行比较；<br>这两个操作符在进行比较时则要遵循下列规则。</li><li>null 和 undefined 是相等的。</li><li>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li><li>如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示：<br>即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则，NaN 不等于 NaN。</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，<br>则相等操作符返回 true；否则，返回 false。</li></ul><h4 id="amp-1"><a href="#amp-1" class="headerlink" title="=== &amp; !=="></a>=== &amp; !==</h4><p>除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符由 3 个等于号（===）表示，它只在两个操作数未经转换就相等的情况下返回 true.</p><p>记住：null == undefined 会返回 true，因为它们是类似的值；但 null === undefined 会返回 false，因为它们是不同类型的值</p><hr><p>这里有一篇好文:<br>作者：林建入<br>链接：<a href="https://www.zhihu.com/question/20348948/answer/19601270" target="_blank" rel="external">https://www.zhihu.com/question/20348948/answer/19601270</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h4 id="严格相等运算符"><a href="#严格相等运算符" class="headerlink" title="严格相等运算符"></a>严格相等运算符</h4><p>=== 被称为 Strict Equals Operator，假设有表达式 a === b，则它的实际运算过程如下</p><ol><li>计算出表达式 a 的结果，并存入 lref 变量</li><li>将 GetValue(lref) 的结果存入 lval 变量</li><li>计算出表达式 b 的结果，并存入 rref 变量</li><li>将 GetValue(rref) 的结果存入 rval 变量</li><li>执行 Strict Equality Comparison 算法判断 rval === lval 并将结果直接返回</li></ol><p>这里的 Strict Equality Comparison 算法很关键，假设要计算的是 x === y，则过程如下</p><ol><li>如果 Type(x) 和 Type(y) 不同，返回 false</li><li>如果 Type(x) 为 Number，则进入下面的判断逻辑<ol><li>如果 x 为 NaN，返回 false</li><li>如果 y 为 NaN，返回 false</li><li>如果 x 的数字值和 y 相等，返回 true</li><li>如果 x 是 +0 且 y 是 -0，返回 true</li><li>如果 x 是 -0 且 y 是 +0，返回 ture</li><li>返回 false</li></ol></li><li>如果 Type(x) 为 String，则当且仅当 x 与 y 的字符序列完全相同（长度相等，每个位置上的字符相同）时返回 true，否则返回 false</li><li>如果 Type(x) 为 Boolean，则若 x 与 y 同为 true 或同为 false 时返回 true，否则返回 false</li><li>如果 x 和 y 引用的是同一个对象，返回 true，否则返回 false</li></ol><h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>== 的实现好了，当你明白了 === 的实现之后，我们再来看看 == 的实现，比较一下他们有何不同？<br>== 被称为 Equals Operator （注意看没有 Strict 了），</p><p>假设有表达式 a == b，则它的实际运算过程如下</p><ol><li>计算出表达式 a 的结果，并存入 lref 变量</li><li>将 GetValue(lref) 的结果存入 lval 变量</li><li>计算出表达式 b 的结果，并存入 rref 变量</li><li>将 GetValue(rref) 的结果存入 rval 变量</li><li>执行 Abstract Equality Comparison 算法判断 rval == lval 并将结果直接返回</li></ol><p>注意，其中的前 4 个步骤是和 === 完全相同的。唯独 5 不同。对于 === 来说，调用的是 Strict Equality Comparison 算法，但是 == 则调用的是 Abstract Equality Comparison 算法。虽然仅一词之差，但是却有质的不同，我们下面就来看看到底它是怎么实现的</p><p>假设要计算的是 x == y，Abstract Equality Comparison 计算的过程如下（很冗长，但是每个步骤都很简单）</p><ol><li><p>如果 Type(x) 和 Type(y) 相同，则</p><ol><li>如果 Type(x) 为 Undefined，返回 true</li><li>如果 Type(x) 为 Null，返回 true</li><li><p>如果 Type(x) 为 Number，则</p><ol><li>如果 x 是 NaN，返回 false</li><li>如果 y 是 NaN，返回 false</li><li>如果 x 的数值与 y 相同，返回 true</li><li>如果 x 是 +0 且 y 是 -0，返回 true</li><li>如果 x 是 -0 且 y 是 +0，返回 true</li><li>返回 false</li></ol></li><li><p>如果 Type(x) 为 String，则当且仅当 x 与 y 的字符序列完全相同（长度相等，每个位置上的字符相同）时返回 true，否则返回 false</p></li><li>如果 Type(x) 为 Boolean，则若 x 与 y 同为 true 或同为 false 时返回 true，否则返回 false</li><li>如果 x 和 y 引用的是同一个对象，返回 true，否则返回 false</li></ol></li><li>如果 x 是 null 且 y 是 undefined，返回 true</li><li>如果 x 是 undefined 且 y 是 null，返回 ture</li><li>如果 Type(x) 为 Number 且 Type(y) 为 String，以 x == ToNumber(y) 的比较结果作为返回</li><li>如果 Type(x) 为 String 且 Type(y) 为 Number，以 ToNumber(x) == y 的比较结果作为返回值</li><li>如果 Type(x) 为 Boolean，以 ToNumber(x) == y 的比较结果作为返回值</li><li>如果 Type(y) 为 Boolean，以 x == ToNumber(y) 的比较结果作为返回值</li><li>如果 Type(x) 为 String 或 Number 且 Type(y) 为 Object，以 x == ToPrimitive(y) 的比较结果作为返回值</li><li>如果 Type(x) 为 Object 且 Type(y) 为 String 或 Number，以 ToPrimitive(x) == y 的比较结果作为返回值10. 返回 false</li></ol><p>从上面的算法流程可以看出，a ===  b 是最简单的。如果 a 和 b 的类型不同，那么一定会返回 false。而 a == b 则要灵活得多。JavaScript 会尝试调整 a 和 b 的类型，例如若 a 为字符串 b 为数字，则将字符串先转化为数字再与 b 比较，等等。这在很多时候简化了程序员的代码量。</p><p>还有一篇:<a href="https://segmentfault.com/a/1190000006012804" target="_blank" rel="external">https://segmentfault.com/a/1190000006012804</a></p><h2 id="JS逻辑运算符的一些骚操作"><a href="#JS逻辑运算符的一些骚操作" class="headerlink" title="JS逻辑运算符的一些骚操作"></a>JS逻辑运算符的一些骚操作</h2><p>其实也不骚hhh，很实用的操作<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//判断类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="built_in">String</span>(obj) :</div><div class="line">    [<span class="built_in">String</span>.prototype.toString.call(obj)] || <span class="string">"object"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 判断是否是 window对象（注意，w为小写）指当前的浏览器窗口，window对象的window属性指向自身。</span></div><div class="line"><span class="comment">// 即 window.window === window</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWindow</span>(<span class="params">obj</span>)</span></div><div class="line"><span class="function"></span>&#123; <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; obj == obj.window &#125;</div><div class="line"> <span class="comment">// 判断是否是数组或者对象数组</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">likeArray</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = !!obj &amp;&amp; <span class="string">'length'</span> <span class="keyword">in</span> obj &amp;&amp; obj.length,</div><div class="line">    type = $.type(obj)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">'function'</span> != type &amp;&amp; !isWindow(obj) &amp;&amp; (</div><div class="line">    <span class="string">'array'</span> == type || length === <span class="number">0</span> ||</div><div class="line">      (<span class="keyword">typeof</span> length == <span class="string">'number'</span> &amp;&amp; length &gt; <span class="number">0</span> &amp;&amp; (length - <span class="number">1</span>) <span class="keyword">in</span> obj)</div><div class="line">  )</div><div class="line">&#125;</div><div class="line"><span class="comment">//有没有要看晕了。。我也要晕了，，实际工程里要这样写的话，会被打死吧。。</span></div></pre></td></tr></table></figure><p>还有一个非常优雅的<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//形如:</span></div><div class="line"><span class="comment">//如果X则_x,如果y则_y,如果z则_z等等等</span></div><div class="line"><span class="comment">//比如一岁给1个苹果,且增长无规律</span></div><div class="line"><span class="comment">//将swictch或者链式ifelse改写</span></div><div class="line"><span class="keyword">var</span> res = (age==<span class="number">5</span> &amp;&amp; <span class="number">1</span>) || (age==<span class="number">10</span> &amp;&amp; <span class="number">2</span>) || (age==<span class="number">12</span> &amp;&amp; <span class="number">3</span>) || (age==<span class="number">15</span> &amp;&amp; <span class="number">4</span>) || <span class="number">0</span>;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前真的是小瞧了JS的运算符，再看《JS高级程序设计》的时候，甚至都没有深入的了解JS的逻辑运算符，只是走马观花的边跳边看。。今天晚上闲着没事，不想写代码，就想看看一些小框架的源码学习学习。看到了大量的关于运算符骚操作之后，发现原来逻辑表达式还能这么玩，羞愧不已，于是重新搬
      
    
    </summary>
    
      <category term="技术" scheme="http://stan1812.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS中的各种继承</title>
    <link href="http://stan1812.github.io/2017/11/06/JSOO/"/>
    <id>http://stan1812.github.io/2017/11/06/JSOO/</id>
    <published>2017-11-06T07:10:24.000Z</published>
    <updated>2017-11-06T07:20:43.347Z</updated>
    
    <content type="html"><![CDATA[<p>先留坑，回头来写</p><h3 id="Before-talking"><a href="#Before-talking" class="headerlink" title="Before talking"></a>Before talking</h3><p>自己对于JS中的原型以及各种玄乎的继承一直理解都比较模糊，感觉这一块一直都是自己的一个坑，最近在重新看《JavaScript高级程序设计》中关于原型和继承的一部分。结合着《JavaScript面向对象编程指南》对于JS中的各种继承来总结一下</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><h4 id="复习一下原型："><a href="#复习一下原型：" class="headerlink" title="复习一下原型："></a>复习一下原型：</h4><h3 id="各种继承"><a href="#各种继承" class="headerlink" title="各种继承"></a>各种继承</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先留坑，回头来写&lt;/p&gt;
&lt;h3 id=&quot;Before-talking&quot;&gt;&lt;a href=&quot;#Before-talking&quot; class=&quot;headerlink&quot; title=&quot;Before talking&quot;&gt;&lt;/a&gt;Before talking&lt;/h3&gt;&lt;p&gt;自己对于JS
      
    
    </summary>
    
      <category term="技术" scheme="http://stan1812.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>浅析struct</title>
    <link href="http://stan1812.github.io/2017/10/17/structDef/"/>
    <id>http://stan1812.github.io/2017/10/17/structDef/</id>
    <published>2017-10-17T08:47:35.000Z</published>
    <updated>2017-10-18T03:43:49.470Z</updated>
    
    <content type="html"><![CDATA[<p>先留坑，空下来来写</p><h3 id="typedef是什么"><a href="#typedef是什么" class="headerlink" title="typedef是什么"></a>typedef是什么</h3><p>typedef为C语言的关键字，作用是为一种数据类型定义一个新名字。这里的数据类型包括内部数据类型（int,char等）和自定义的数据类型（struct等）。</p><p>在编程中使用typedef目的一般有两个，一个是给变量一个易记且意义明确的新名字，另一个是简化一些比较复杂的类型声明。</p><h3 id="使用struct"><a href="#使用struct" class="headerlink" title="使用struct"></a>使用struct</h3><h4 id="结构声明"><a href="#结构声明" class="headerlink" title="结构声明"></a>结构声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></div><div class="line"><span class="keyword">int</span> age;</div><div class="line"><span class="keyword">int</span> height;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>该声明描述了一个由两个整形所组成的结构，但并未创建实际的数据对象，只是描述了该对象由什么组成（可称之为“模板”，因为他勾勒出该结构是如何存数数据的，突然想起js的构造函数。。）</p><p>下面来分析一下细节：<br>首先：关键字struct，它表明跟在后面的是一个结构，后面是一个可选的标记“S1”，稍后程序中可以使用该标记引用该结构，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">me</span>;</span></div></pre></td></tr></table></figure></p><p>这把<code>me</code>声明为一个使用<code>person</code>结构的结构变量</p><h4 id="定义结构变量"><a href="#定义结构变量" class="headerlink" title="定义结构变量"></a>定义结构变量</h4><p>结构有两层含义：一是结构布局，结构布局告诉编译器如何表示数据，但是并未让编译器为数据分配空间。 之后就是需要创建一个结构变量，即是另外一个含义。<br>在<code>struct person me;</code>中，<code>struct person</code>所起的作用就是相当于一般声明中的int float<br>可以定义两个<code>struct person</code>类型的变量，甚至是一个指向<code>struct person</code>类型结构的指针。<br><code>struct person me, xiaoming ,*xiaohong;</code></p><p>就计算机而言：<code>struct person me</code>是以下声明的简化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></div><div class="line"><span class="keyword">int</span> age;</div><div class="line"><span class="keyword">int</span> height;</div><div class="line">&#125; me;</div></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>以上，可知，声明结构的过程和定义结构变量的过程可以组合长一个步骤<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line"><span class="keyword">int</span> age;</div><div class="line"><span class="keyword">int</span> height;</div><div class="line">&#125; me;</div></pre></td></tr></table></figure></p><p>然而，如果需要多次使用，就必须使用带标记的形式，或者使用接下来要介绍的<code>typedef</code></p><p>ps：这只是定义结构变量，并未初始化结构变量</p><h3 id="使用typedef"><a href="#使用typedef" class="headerlink" title="使用typedef"></a>使用typedef</h3><h4 id="typedef与结构结合使用"><a href="#typedef与结构结合使用" class="headerlink" title="typedef与结构结合使用"></a>typedef与结构结合使用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMyStruct</span></span></div><div class="line"><span class="class">&#123;</span> </div><div class="line">　<span class="keyword">int</span> iNum;</div><div class="line">　<span class="keyword">long</span> lLength;</div><div class="line">&#125; MyStruct;</div></pre></td></tr></table></figure><p>这语句实际上完成两个操作：</p><p>1) 定义一个新的结构类型<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagMyStruct</span></span></div><div class="line"><span class="class">&#123;</span> </div><div class="line">　<span class="keyword">int</span> iNum; </div><div class="line">　<span class="keyword">long</span> lLength; </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>分析：tagMyStruct称为“tag”，即“标签”，实际上是一个临时名字，struct 关键字和tagMyStruct一起，构成了这个结构类型，不论是否有typedef，这个结构都存在。</p><p>我们可以用struct tagMyStruct varName来定义变量，但要注意，使用tagMyStruct varName来定义变量是不对的，因为struct 和tagMyStruct合在一起才能表示一个结构类型。</p><p>2) typedef为这个新的结构起了一个名字，叫MyStruct。</p><p>  <code>typedef struct tagMyStruct MyStruct;</code></p><p>因此，MyStruct实际上相当于struct tagMyStruct，我们可以使用MyStruct varName来定义变量</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">x1</span> &#123;</span> ...&#125;x1; </div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">x2</span>&#123;</span> ...&#125; x2;</div><div class="line">``` </div><div class="line">有什么不同？ </div><div class="line">其实, 前者是定义了类`_x1`和`_x1`的对象实例`x1`, 后者是定义了类`_x2`和`_x2`的类别名`x2`</div><div class="line"></div><div class="line">所以它们在使用过程中是有区别的</div><div class="line">实例：</div><div class="line">```C++</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">int</span> num;</div><div class="line"><span class="keyword">int</span> age;</div><div class="line">&#125;aaa,bbb,ccc;</div></pre></td></tr></table></figure><p>这算什么呢？<br>这相当于<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">int</span> num;</div><div class="line"><span class="keyword">int</span> age;</div><div class="line">&#125;aaa；</div><div class="line"><span class="keyword">typedef</span> aaa bbb;</div><div class="line"><span class="keyword">typedef</span> aaa ccc;</div></pre></td></tr></table></figure></p><p>也就是说aaa,bbb,ccc三者都是结构体类型。声明变量时用任何一个都可以,在c++中也是如此。但是你要注意的是这个在c++中如果无typedef关键字，那么aaa，bbb，ccc将是截然不同的三个对象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>(这个问答是在CSDN看到的，<a href="http://blog.csdn.net/haiou0/article/details/6877718" target="_blank" rel="external">链接在此</a>因为对C和C++学习的并不深入，所以直接拿来了~)<br>Q：用struct和typedef struct 定义一个结构体有什么区别？为什么会有两种方式呢？<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span></div><div class="line"><span class="class">&#123;</span> </div><div class="line"><span class="keyword">int</span> a; </div><div class="line">&#125; stu;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student2</span> </span></div><div class="line"><span class="class">&#123;</span> </div><div class="line"><span class="keyword">int</span> a; </div><div class="line">&#125;stu2;</div></pre></td></tr></table></figure></p><p>A：</p><p>事实上，这个东西是从C语言中遗留过来的，typedef可以定义新的复合类型或给现有类型起一个别名，在C语言中，如果你使用 <code>struct xxx {...};</code> 的方法，使用时就必须用<code>struct xxx var</code> 来声明变量，而使用 <code>typedef struct {...}</code>的方法 就可以写为<code>xxx var</code>;<br>不过在C++中已经没有这回事了，无论你用哪一种写法都可以使用第二种方式声明变量，这个应该算是C语言的糟粕。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先留坑，空下来来写&lt;/p&gt;
&lt;h3 id=&quot;typedef是什么&quot;&gt;&lt;a href=&quot;#typedef是什么&quot; class=&quot;headerlink&quot; title=&quot;typedef是什么&quot;&gt;&lt;/a&gt;typedef是什么&lt;/h3&gt;&lt;p&gt;typedef为C语言的关键字，作用是为一
      
    
    </summary>
    
      <category term="技术" scheme="http://stan1812.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://stan1812.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Javascript事件循环机制</title>
    <link href="http://stan1812.github.io/2017/10/17/event-loop/"/>
    <id>http://stan1812.github.io/2017/10/17/event-loop/</id>
    <published>2017-10-17T06:48:39.000Z</published>
    <updated>2017-11-13T04:43:49.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在学习Node.JS，而node实用的是单线程模型，对于所有的I/O都使用了异步式的请求方式。并使用事件驱动+异步式I/O来带来可观的性能提升。node大量使用了异步的处理方式，所以想了解下具体的原理，看了很多相关的博客以及文档，现在来总结一下。</p><h3 id="从同步与异步说起"><a href="#从同步与异步说起" class="headerlink" title="从同步与异步说起"></a>从同步与异步说起</h3><p>学过JS的估计都知道了，JS的执行环境是单线程。所谓”单线程”，就是一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。</p><p>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去.</p><ul><li>“同步任务（synchronous）”：后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；</li><li>“异步任务（asynchronous）”：则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li></ul><p>而异步编程的主要方式基本有这几种：</p><ol><li>改写回调函数</li><li>事件监听</li><li>发布/订阅（这种不了解。。好像跟设计模式有点关系，以后再去了解）</li><li>Promises对象</li><li>ES7中的await和async</li></ol><h3 id="函数调用栈与任务队列"><a href="#函数调用栈与任务队列" class="headerlink" title="函数调用栈与任务队列"></a>函数调用栈与任务队列</h3><p>主要有以下两个解释：</p><h4 id="解释一"><a href="#解释一" class="headerlink" title="解释一"></a>解释一</h4><ol><li>Javascript有一个main thread 主进程和call-stack（一个调用堆栈），在对一个调用堆栈中的task处理的时候，其他的都要等着。当在执行过程中遇到一些类似于setTimeout等异步操作的时候，会交给浏览器的其他模块(以webkit为例，是webcore模块)进行处理，当到达setTimeout指定的延时执行的时间之后，task(回调函数)会放入到任务队列之中。一般不同的异步任务的回调函数会放入不同的任务队列之中。等到调用栈中所有task执行完毕之后，接着去执行任务队列之中的task(回调函数)。</li></ol><p><img src="https://pic1.zhimg.com/v2-e902447823cf13e5a547214363233858_r.jpg" alt=""></p><p>在上图中，调用栈中遇到DOM操作、ajax请求以及setTimeout等WebAPIs的时候就会交给浏览器内核的其他模块进行处理，webkit内核在Javasctipt执行引擎之外，有一个重要的模块是webcore模块。对于图中WebAPIs提到的三种API，webcore分别提供了DOM Binding、network、timer模块来处理底层实现。等到这些模块处理完这些操作的时候将回调函数放入任务队列中，之后等栈中的task执行完之后再去执行任务队列之中的回调函数。<br>(内容来自<a href="https://www.zhihu.com/people/xia-yan-luo-47/activities" target="_blank" rel="external">@柳兮</a>)</p><h4 id="解释二"><a href="#解释二" class="headerlink" title="解释二"></a>解释二</h4><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。(stack的第二种含义是“调用栈”（call stack），表示函数或子例程像堆积木一样存放，以实现层层调用。)</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。<br>（内容来自<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">@阮一峰</a>）</li></ol><p>以上是网上比较典型的两种说法。对此我有一个不理解的地方就是:”当到达setTimeout指定的延时执行的时间之后，task(回调函数)会放入到任务队列之中。”and “等到调用栈中所有task执行完毕之后，接着去执行任务队列之中的task(回调函数)” 这两种说法看起来好像是矛盾的，如何确定到达set的时间内调用栈内的任务执行完成呢？<br>事实证明：setTimeout和setInterval的运行机制是，将指定的代码移出本次执行，等到下一轮Event Loop时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮Event Loop时重新判断。这意味着，setTimeout指定的代码，必须等到本次执行的所有代码都执行完，才会执行。<br>每一轮Event Loop时，都会将“任务队列”中需要执行的任务，一次执行完。setTimeout和setInterval都是把任务添加到“任务队列”的尾部。因此，它们实际上要等到当前脚本的所有同步任务执行完，然后再等到本次Event Loop的“任务队列”的所有任务执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。(之前听说过settimeout的时间可能会不完全准确，现在终于知道其中的原因了)<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">setTimeout(someTask,<span class="number">100</span>);</div><div class="line">veryLongTask();</div></pre></td></tr></table></figure></p><p>上面代码的setTimeout，指定100毫秒以后运行一个任务。但是，如果后面立即运行的任务（当前脚本的同步任务））非常耗时，过了100毫秒还无法结束，那么被推迟运行的someTask就只有等着，等到前面的veryLongTask运行结束，才轮到它执行。</p><p>所以说这两种说法是并不矛盾的。</p><h3 id="同步与异步运行机制"><a href="#同步与异步运行机制" class="headerlink" title="同步与异步运行机制"></a>同步与异步运行机制</h3><p>目前比较浅显的解释是:”Javascript的事件分为同步任务和异步任务，遇到同步任务就放在执行栈中执行，而碰到异步任务就放到任务队列之中，等到执行栈执行完毕之后再去执行任务队列之中的事件。”<br>以上对于函数调用栈亿级任务队列的解释已经很详细了，现在来结合实例来具体的解释一下</p><p>以settimeout为例：</p><p>首先main()函数的执行上下文入栈</p><p><img src="https://pic2.zhimg.com/v2-9e5a3e686df7e84068575121c1ec9fcd_b.jpg" alt=""></p><p>代码接着执行，遇到console.log(‘Hi’),此时log(‘Hi’)入栈，console.log方法只是一个webkit内核支持的普通的方法，所以log(‘Hi’)方法立即被执行。此时输出’Hi’。</p><p><img src="https://pic2.zhimg.com/v2-1a9a6a95c4a7d3dc45facb5b2545640d_b.png" alt=""></p><p>当遇到setTimeout的时候，执行引擎将其添加到栈中。</p><p><img src="https://pic4.zhimg.com/v2-4a8c8a73009cc73d5efdb833fdf81b03_b.png" alt=""></p><p>调用栈发现setTimeout是之前提到的WebAPIs中的API，因此将其出栈之后将延时执行的函数交给浏览器的timer模块进行处理。</p><p><img src="https://pic3.zhimg.com/v2-37a7df54154dd521ced4dae2e3470c22_b.jpg" alt=""></p><p>timer模块去处理延时执行的函数，此时执行引擎接着执行将log(‘SJS’)添加到栈中，此时输出’SJS’。</p><p><img src="https://pic3.zhimg.com/v2-800d6abf4bcdef9a354c9d60f2882a26_b.png" alt=""></p><p>当timer模块中延时方法规定的时间到了之后就将其放入到任务队列之中，此时调用栈中的task已经全部执行完毕。</p><p><img src="https://pic2.zhimg.com/v2-e804f07a0d9b0436941e3e48550349b9_b.png" alt=""></p><p>调用栈中的task执行完毕之后，执行引擎会接着看执行任务队列中是否有需要执行的回调函数。这里的cb函数被执行引擎添加到调用栈中，接着执行里面的代码，输出’there’。等到执行结束之后再出栈。</p><p><img src="https://pic4.zhimg.com/v2-c3c2686ecfa45b21ff3bc99b0252b90b_b.png" alt=""></p><p><img src="https://pic4.zhimg.com/v2-f78ad9009fd2622c139f2da66f61d19b_b.png" alt=""></p><p>内容来自<a href="https://vimeo.com/96425312" target="_blank" rel="external">Philip Roberts: Help, I’m stuck in an event-loop.</a></p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h4><p>网上有很多关于这个的面试题，其中有一道很经典的面试题：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div></pre></td></tr></table></figure></p><p>问题不大问题不大。</p><p>先来分析一下：<br>i=0时，满足条件，执行栈执行循环体里面的代码，发现是setTimeout，将其出栈之后把延时执行的函数交给Timer模块进行处理。</p><p>当i=1,2,3,4时，均满足条件，情况和i=0时相同，因此timer模块里面有5个相同的延时执行的函数。</p><p>当i=5的时候，不满足条件，for循环结束,console.log(new Date, i)入栈，此时的i已经变成了5。输出5。</p><p>此时1s已经过去，timer模块将5个回调函数按照注册的顺序返回给任务队列。</p><p>执行引擎去执行任务队列中的函数，5个function依次入栈执行之后再出栈，此时的i已经变成了5。因此几乎同时输出5个5。</p><p>因此等待的1s的时间其实只有输出第一个5之后需要等待1s，这1s的时间是timer模块需要等到的规定的1s时间之后才将回调函数交给任务队列。等执行栈执行完毕之后再去执行任务对列中的5个回调函数。这期间是不需要等待1s的。因此输出的状态就是：5 -&gt; 5,5,5,5,5，即第1个 5 直接输出，1s之后，输出 5个5；</p><p>来控制台跑一下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line"></div><div class="line">raven.b7b3066ebc21a63ef339.js:<span class="number">1</span> Tue Oct <span class="number">17</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">39</span> GMT+<span class="number">0800</span> (中国标准时间) <span class="number">5</span></div><div class="line"><span class="literal">undefined</span></div><div class="line">raven.b7b3066ebc21a63ef339.js:<span class="number">1</span> Tue Oct <span class="number">17</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">40</span> GMT+<span class="number">0800</span> (中国标准时间) <span class="number">5</span></div><div class="line">raven.b7b3066ebc21a63ef339.js:<span class="number">1</span> Tue Oct <span class="number">17</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">40</span> GMT+<span class="number">0800</span> (中国标准时间) <span class="number">5</span></div><div class="line">raven.b7b3066ebc21a63ef339.js:<span class="number">1</span> Tue Oct <span class="number">17</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">40</span> GMT+<span class="number">0800</span> (中国标准时间) <span class="number">5</span></div><div class="line">raven.b7b3066ebc21a63ef339.js:<span class="number">1</span> Tue Oct <span class="number">17</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">40</span> GMT+<span class="number">0800</span> (中国标准时间) <span class="number">5</span></div><div class="line">raven.b7b3066ebc21a63ef339.js:<span class="number">1</span> Tue Oct <span class="number">17</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">40</span> GMT+<span class="number">0800</span> (中国标准时间) <span class="number">5</span></div></pre></td></tr></table></figure></p><p>well~</p><p>那么要如何的得到想要的效果呢？</p><ul><li><p>方法一：利用匿名函数的作用域</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">9</span>; i++) &#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</div><div class="line">        setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log( j );</div><div class="line">        &#125;, <span class="number">1000</span> );</div><div class="line">    &#125;)( i );</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>方法二；使用let就好了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">9</span>; i++) &#123;</div><div class="line">   setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="built_in">console</span>.log( i );</div><div class="line">   &#125;, <span class="number">1000</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h4 id="实例二（更加深入）"><a href="#实例二（更加深入）" class="headerlink" title="实例二（更加深入）"></a>实例二（更加深入）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>)&#125;, <span class="number">0</span>);</div><div class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ ) &#123;</div><div class="line">            i == <span class="number">9999</span> &amp;&amp; resolve();</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="number">5</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</div><div class="line">&#125;)()</div></pre></td></tr></table></figure><p>promise的task会放在不同的任务队列里面，那么setTimeout的任务队列和promise的任务队列的执行顺序又是怎么的呢？</p><p>这里先把结论放出来：<br>一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。</p><ol><li><p>任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。</p></li><li><p>macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</p></li><li><p>micro-task大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)</p></li><li><p>setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// setTimeout中的回调函数才是进入任务队列的任务</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'xxxx'</span>);</div><div class="line">&#125;)</div><div class="line"><span class="comment">// setTimeout作为一个任务分发器，这个函数会立即执行，而它所要分发的任务，也就是它的第一个参数，才是延迟执行</span></div></pre></td></tr></table></figure></li><li><p>来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。</p></li><li><p>事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。</p></li><li><p>其中每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成。</p></li></ol><p>这是一个挺复杂的东西了。。写的有点累了，先放一篇好文<a href="http://www.jianshu.com/p/12b9f73c5a4f" target="_blank" rel="external">深入核心，详解事件循环机制</a>，回头再来继续。</p><p>参考文章：</p><ul><li><a href="http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/" target="_blank" rel="external">从setTimeout说事件循环模型</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">JavaScript 运行机制详解：再谈Event Loop</a></li><li><a href="https://vimeo.com/96425312" target="_blank" rel="external">Philip Roberts: Help, I’m stuck in an event-loop</a></li><li><a href="https://zhuanlan.zhihu.com/p/26229293" target="_blank" rel="external">深入浅出Javascript事件循环机制(上)</a></li><li><a href="https://zhuanlan.zhihu.com/p/26238030" target="_blank" rel="external">深入浅出Javascript事件循环机制(下)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近在学习Node.JS，而node实用的是单线程模型，对于所有的I/O都使用了异步式的请求方式。并使用事件驱动+异步式I/O来带来可观的性
      
    
    </summary>
    
      <category term="技术" scheme="http://stan1812.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>有点不爽</title>
    <link href="http://stan1812.github.io/2017/09/24/someFeelings/"/>
    <id>http://stan1812.github.io/2017/09/24/someFeelings/</id>
    <published>2017-09-24T13:51:49.000Z</published>
    <updated>2017-09-24T14:55:36.869Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到了一句话：</p><p>人生很多事，终究是会随着时间好起来的。<br>像很多人原本只是胖，久了就变好胖。</p><p><img src="/imgs/01.png" alt=""></p><p>开学了一个月，大多数时间都在划水划掉了。工作室招新，学校运动会训练。现在回想回想，有点不爽。</p><p>云家园这边老罗一直在改需求，感觉快要被折腾死了，，，临上线一个综合素质测评系统的前一天晚上突然改需求，然后就跟后端的学长窝在机房肝到四点多，然后五点多又起床去搞信工这煞笔的运动会排练。感觉走路都有点飘。。最让人难受的是什么？学院之后发了一个通知，具体的就不再放出来了，反正里面有一条大致就是你不好好搞的话奖学金什么的都没有。虽然以我的成绩根本也拿不到奖学金，但是他妈的学院真的是XXXXXXXXXXXXXXX知乎上有人在讨论这个事情，留个链接 <a href="https://www.zhihu.com/question/65664802" target="_blank" rel="external">如何评价南昌大学信工学院强制大一至大三学生参与运动会舞蹈排练?</a></p><p>在招新的时候，有两个主动问我问题的学弟，令我印象深刻，并且仿写了百度首页的静态页面但是最终还是因为种种原因被拒掉了。。本来很看好的，结果两个都没有最终留下来，也是一个很不爽的事情。</p><p>一个非常看好的感觉和自己某些地方有点相像的一个学妹最终也没能顺利地留下来，不过他们都还有机会。</p><p>这三个人里面，其实我最看好第三个</p><p>希望他们能够坚持下来。</p><p>今天晚上，是家园工作室研发部见面会，感觉和过年一样热闹，每个组的见面会是在不同的教室，然后每个组的组长带着新生到其他的各个组去自我介绍。。总给我一种过年的时候，我爸带着我，去别人家拜年的感觉。</p><p>一帮人的喧闹之后总是会留下孤独。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看到了一句话：&lt;/p&gt;
&lt;p&gt;人生很多事，终究是会随着时间好起来的。&lt;br&gt;像很多人原本只是胖，久了就变好胖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/imgs/01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;开学了一个月，大多数时间都在划水划掉了。工作室招新，学校运动会训练
      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
      <category term="生活" scheme="http://stan1812.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Learning 2</title>
    <link href="http://stan1812.github.io/2017/09/10/MySQLLearning2/"/>
    <id>http://stan1812.github.io/2017/09/10/MySQLLearning2/</id>
    <published>2017-09-10T14:08:52.000Z</published>
    <updated>2017-11-06T07:11:28.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="嗯，今天下午又看了一点MySQL。。依然是基础知识，只是在终端里面操作了一波，还没有使用一门后端语言来操作一波，之后接触了Node之后再来实际操作一波吧。👀"><a href="#嗯，今天下午又看了一点MySQL。。依然是基础知识，只是在终端里面操作了一波，还没有使用一门后端语言来操作一波，之后接触了Node之后再来实际操作一波吧。👀" class="headerlink" title="嗯，今天下午又看了一点MySQL。。依然是基础知识，只是在终端里面操作了一波，还没有使用一门后端语言来操作一波，之后接触了Node之后再来实际操作一波吧。👀"></a>嗯，今天下午又看了一点MySQL。。依然是基础知识，只是在终端里面操作了一波，还没有使用一门后端语言来操作一波，之后接触了Node之后再来实际操作一波吧。👀</h2><h3 id="依然是基本语句：🌈"><a href="#依然是基本语句：🌈" class="headerlink" title="依然是基本语句：🌈"></a>依然是基本语句：🌈</h3><h4 id="UPDATE-查询"><a href="#UPDATE-查询" class="headerlink" title="UPDATE 查询"></a>UPDATE 查询</h4><p>update命令用来修改或者更新数据表中的数据<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> field1=<span class="keyword">new</span>-value1, field2=<span class="keyword">new</span>-value2</div><div class="line">[<span class="keyword">WHERE</span> Clause]</div></pre></td></tr></table></figure></p><ul><li>同时更新一个或多个字段。</li><li>在 WHERE 子句中指定任何条件。</li><li>在一个单独表中同时更新数据。<br>实例：<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> w3cschool_tbl <span class="keyword">SET</span> w3cschool_title=<span class="string">'John Test'</span> <span class="keyword">WHERE</span> w3cschool_id=<span class="number">4</span>;</div><div class="line">Query OK, 1 row affected (0.23 sec)</div><div class="line">Rows matched: 1  Changed: 1  Warnings: 0</div></pre></td></tr></table></figure></li></ul><h4 id="DELETE-语句："><a href="#DELETE-语句：" class="headerlink" title="DELETE 语句："></a>DELETE 语句：</h4><p>使用 SQL 的 DELETE FROM 命令来删除 MySQL 数据表中的记录<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> w3cschool_tbl <span class="keyword">WHERE</span> w3cschool_id=<span class="number">3</span></div><div class="line"><span class="keyword">Query</span> OK, <span class="number">1</span> <span class="keyword">row</span> affected (<span class="number">0.33</span> sec)</div></pre></td></tr></table></figure></p><p>然后再来查询一下：<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> w3cschool_tbl</div><div class="line">+<span class="comment">--------------+------------------+------------------+-----------------+</span></div><div class="line">| w3cschool_id | w3cschool_title  | w3cschool_author | submission_date |</div><div class="line">+<span class="comment">--------------+------------------+------------------+-----------------+</span></div><div class="line">|            <span class="number">1</span> | Learn MySQL      | Abdul S          | <span class="number">2017</span><span class="number">-08</span><span class="number">-21</span>      |</div><div class="line">|            <span class="number">2</span> | <span class="keyword">test</span> about MySql | libiao           | <span class="number">2017</span><span class="number">-08</span><span class="number">-21</span>      |</div><div class="line">|            <span class="number">4</span> | John <span class="keyword">Test</span>        | John Poul        | <span class="number">2017</span><span class="number">-08</span><span class="number">-22</span>      |</div><div class="line">|            <span class="number">5</span> | Learn TS         | John Poul        | <span class="number">2017</span><span class="number">-08</span><span class="number">-22</span>      |</div><div class="line">+<span class="comment">--------------+------------------+------------------+-----------------+</span></div><div class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure></p><h4 id="LIKE语句："><a href="#LIKE语句：" class="headerlink" title="LIKE语句："></a>LIKE语句：</h4><p>“在 MySQL 中使用 SQL SELECT 命令来读取数据， 同时我们可以在 SELECT 语句中使用 WHERE 子句来获取指定的记录。<br>WHERE 子句中可以使用等号 = 来设定获取数据的条件，如 “runoob_author = ‘RUNOOB.COM’”。<br>但是有时候我们需要获取 runoob_author 字段含有 “COM” 字符的所有记录，这时我们就需要在 WHERE 子句中使用 SQL LIKE 子句。<br>SQL LIKE 子句中使用百分号 %字符来表示任意字符，类似于UNIX或正则表达式中的星号 *。<br>如果没有使用百分号 %, LIKE 子句与等号 = 的效果是一样的。”</p><p>基本语法：<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> field1, field2,...fieldN </div><div class="line"><span class="keyword">FROM</span> table_name</div><div class="line"><span class="keyword">WHERE</span> field1 <span class="keyword">LIKE</span> condition1 [<span class="keyword">AND</span> [<span class="keyword">OR</span>]] filed2 = <span class="string">'somevalue'</span></div></pre></td></tr></table></figure></p><p>实例：<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> w3cschool_tbl <span class="keyword">WHERE</span> w3cschool_title <span class="keyword">LIKE</span> <span class="string">'Learn%'</span>;</div><div class="line"> +<span class="comment">--------------+-----------------+------------------+-----------------+</span></div><div class="line">| w3cschool_id | w3cschool_title | w3cschool_author | submission_date |</div><div class="line">+<span class="comment">--------------+-----------------+------------------+-----------------+</span></div><div class="line">|            1 | Learn MySQL     | Abdul S          | 2017-08-21      |</div><div class="line">|            5 | Learn TS        | John Poul        | 2017-08-22      |</div><div class="line">+<span class="comment">--------------+-----------------+------------------+-----------------+</span></div><div class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure></p><h4 id="union"><a href="#union" class="headerlink" title="union"></a>union</h4><p>顾名思义：组合嘛==！</p><p>“MySQL UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据。”</p><p>格式：</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> expression1, expression2, ... expression_n</div><div class="line"><span class="keyword">FROM</span> <span class="keyword">tables</span></div><div class="line">[<span class="keyword">WHERE</span> conditions]</div><div class="line"><span class="keyword">UNION</span> [ALL | <span class="keyword">DISTINCT</span>]</div><div class="line"><span class="keyword">SELECT</span> expression1, expression2, ... expression_n</div><div class="line"><span class="keyword">FROM</span> <span class="keyword">tables</span></div><div class="line">[<span class="keyword">WHERE</span> conditions];</div></pre></td></tr></table></figure><h5 id="在所有语言中，排序是必不可少的，来排一波序："><a href="#在所有语言中，排序是必不可少的，来排一波序：" class="headerlink" title="在所有语言中，排序是必不可少的，来排一波序："></a>在所有语言中，排序是必不可少的，来排一波序：</h5><p><code>ORDER BY</code><br>放在一起操作一波：<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT submission_date FROM test2_tbl </div><div class="line">UNION </div><div class="line"><span class="keyword">SELECT</span> submission_date <span class="keyword">FROM</span> w3cschool_tbl </div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> submission_date;</div><div class="line">+<span class="comment">-----------------+</span></div><div class="line">| submission_date |</div><div class="line">+<span class="comment">-----------------+</span></div><div class="line">| 2017-08-21      |</div><div class="line">| 2017-08-22      |</div><div class="line">| 2017-09-10      |</div><div class="line">+<span class="comment">-----------------+</span></div><div class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.26</span> sec)</div></pre></td></tr></table></figure></p><h4 id="GROUP-BY-顾名思义：按组"><a href="#GROUP-BY-顾名思义：按组" class="headerlink" title="GROUP BY(顾名思义：按组):"></a>GROUP BY(顾名思义：按组):</h4><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"> <span class="keyword">SELECT</span> submission_date,<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> w3cschool_tbl <span class="keyword">GROUP</span> <span class="keyword">BY</span> submission_date;</div><div class="line">+<span class="comment">-----------------+----------+</span></div><div class="line">| submission_date | COUNT(*) |</div><div class="line">+<span class="comment">-----------------+----------+</span></div><div class="line">| 2017-08-21      |        2 |</div><div class="line">| 2017-08-22      |        2 |</div><div class="line">+<span class="comment">-----------------+----------+</span></div><div class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.28</span> sec)</div></pre></td></tr></table></figure><p><code>WITH ROLLUP</code> 可以实现在分组统计数据基础上再进行相同的统计（SUM,AVG,COUNT…）。<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"> <span class="keyword">SELECT</span> submission_date,<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> w3cschool_tbl <span class="keyword">GROUP</span> <span class="keyword">BY</span> submission_date <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</div><div class="line"> +<span class="comment">-----------------+----------+</span></div><div class="line">| submission_date | COUNT(*) |</div><div class="line">+<span class="comment">-----------------+----------+</span></div><div class="line">| 2017-08-21      |        2 |</div><div class="line">| 2017-08-22      |        2 |</div><div class="line">| NULL            |        4 |</div><div class="line">+<span class="comment">-----------------+----------+</span></div><div class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure></p><h4 id="select-coalesce-a-b-c"><a href="#select-coalesce-a-b-c" class="headerlink" title="select coalesce(a,b,c);"></a>select coalesce(a,b,c);</h4><p>参数说明：如果a==null,则选择b；如果b==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">coalesce</span>(submission_date,<span class="string">'total'</span>),<span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> w3cschool_tbl <span class="keyword">GROUP</span> <span class="keyword">BY</span> submission_date <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</div><div class="line">+<span class="comment">-----------------------------------+----------+</span></div><div class="line">| coalesce(submission_date,'total') | COUNT(*) |</div><div class="line">+<span class="comment">-----------------------------------+----------+</span></div><div class="line">| 2017-08-21                        |        2 |</div><div class="line">| 2017-08-22                        |        2 |</div><div class="line">| total                             |        4 |</div><div class="line">+<span class="comment">-----------------------------------+----------+</span></div><div class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure><h3 id="接下来感觉是牛逼的了。。"><a href="#接下来感觉是牛逼的了。。" class="headerlink" title="接下来感觉是牛逼的了。。"></a>接下来感觉是牛逼的了。。</h3><p>😁连表：<br>“使用 MySQL 的 JOIN 在两个或多个表中查询数据。<br>你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。<br>JOIN 按照功能大致分为如下三类：</p><ul><li>INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。</li><li>LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</li><li>RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。”</li></ul><p>先来创建一个新表并插入数据：<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tcount_tbl`</span> (   <span class="string">`w3cschool_author`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,   <span class="string">`count`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</div><div class="line">Query OK, 0 rows affected (0.53 sec)</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`tcount_tbl`</span> <span class="keyword">VALUES</span> (<span class="string">'libiao'</span>, <span class="string">'10'</span>), (<span class="string">'Abdul S'</span>, <span class="string">'20'</span>), (<span class="string">'John Poul'</span>, <span class="string">'22'</span>);</div><div class="line">Query OK, 3 rows affected (0.40 sec)</div><div class="line">Records: 3  Duplicates: 0  Warnings: 0</div></pre></td></tr></table></figure></p><p>DO IT!<br>来分别看下这两张表的数据：</p><p>tcount_tbl:</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">+<span class="comment">---------------+--------------+</span></div><div class="line">| w3cschool_author | count |</div><div class="line">+<span class="comment">---------------+--------------+</span></div><div class="line">| libiao  | 10           |</div><div class="line">| Abdul S    | 20           |</div><div class="line">| John Poul        | 22           |</div><div class="line">+<span class="comment">---------------+--------------+</span></div></pre></td></tr></table></figure><p>w3cschool_author:</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">+<span class="comment">--------------+------------------+------------------+-----------------+</span></div><div class="line">| w3cschool_id | w3cschool_title  | w3cschool_author | submission_date |</div><div class="line">+<span class="comment">--------------+------------------+------------------+-----------------+</span></div><div class="line">|            1 | Learn MySQL      | Abdul S          | 2017-08-21      |</div><div class="line">|            2 | test about MySql | libiao           | 2017-08-21      |</div><div class="line">|            4 | John Test        | John Poul        | 2017-08-22      |</div><div class="line">|            5 | Learn TS         | John Poul        | 2017-08-22      |</div><div class="line">+<span class="comment">--------------+------------------+------------------+-----------------+</span></div><div class="line"></div><div class="line">```SQL</div><div class="line"></div><div class="line">操作一波：</div><div class="line">mysql&gt; SELECT a.w3cschool_id, a.w3cschool_author, b.count FROM w3cschool_tbl a INNER JOIN tcount_tbl b ON a.w3cschool_author=b.w3cschool_author;</div><div class="line">+<span class="comment">--------------+------------------+-------+</span></div><div class="line">| w3cschool_id | w3cschool_author | count |</div><div class="line">+<span class="comment">--------------+------------------+-------+</span></div><div class="line">|            2 | libiao           |    10 |</div><div class="line">|            1 | Abdul S          |    20 |</div><div class="line">|            4 | John Poul        |    22 |</div><div class="line">|            5 | John Poul        |    22 |</div><div class="line">+<span class="comment">--------------+------------------+-------+</span></div><div class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.08</span> sec)</div></pre></td></tr></table></figure><p>PS（另外两种还没实际操作过，，先不写。。。）</p><h4 id="事务（此后单独来写一波）"><a href="#事务（此后单独来写一波）" class="headerlink" title="事务（此后单独来写一波）"></a>事务（此后单独来写一波）</h4><p>占坑</p><h4 id="ALTER"><a href="#ALTER" class="headerlink" title="ALTER"></a>ALTER</h4><p>需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令</p><p>增：<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>  w3cschool_tbl <span class="keyword">ADD</span> i <span class="built_in">INT</span>;</div><div class="line">Query OK, 0 rows affected (0.89 sec)</div><div class="line">Records: 0  Duplicates: 0  Warnings: 0</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> w3cschool_tbl;</div><div class="line">+<span class="comment">--------------+------------------+------------------+-----------------+------+</span></div><div class="line">| w3cschool_id | w3cschool_title  | w3cschool_author | submission_date | i    |</div><div class="line">+<span class="comment">--------------+------------------+------------------+-----------------+------+</span></div><div class="line">|            1 | Learn MySQL      | Abdul S          | 2017-08-21      | NULL |</div><div class="line">|            2 | test about MySql | libiao           | 2017-08-21      | NULL |</div><div class="line">|            4 | John Test        | John Poul        | 2017-08-22      | NULL |</div><div class="line">|            5 | Learn TS         | John Poul        | 2017-08-22      | NULL |</div><div class="line">+<span class="comment">--------------+------------------+------------------+-----------------+------+</span></div><div class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</div></pre></td></tr></table></figure></p><p>改：<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> w3cschool_tbl <span class="keyword">CHANGE</span> i j <span class="built_in">BIGINT</span>;</div><div class="line">Query OK, 4 rows affected (0.82 sec)</div><div class="line">Records: 4  Duplicates: 0  Warnings: 0</div><div class="line"></div><div class="line">mysql&gt; SELECT * FROM w3cschool_tbl;</div><div class="line">+<span class="comment">--------------+------------------+------------------+-----------------+------+</span></div><div class="line">| w3cschool_id | w3cschool_title  | w3cschool_author | submission_date | j    |</div><div class="line">+<span class="comment">--------------+------------------+------------------+-----------------+------+</span></div><div class="line">|            1 | Learn MySQL      | Abdul S          | 2017-08-21      | NULL |</div><div class="line">|            2 | test about MySql | libiao           | 2017-08-21      | NULL |</div><div class="line">|            4 | John Test        | John Poul        | 2017-08-22      | NULL |</div><div class="line">|            5 | Learn TS         | John Poul        | 2017-08-22      | NULL |</div><div class="line">+<span class="comment">--------------+------------------+------------------+-----------------+------+</span></div><div class="line">4 rows in <span class="keyword">set</span> (<span class="number">0.03</span> sec)</div></pre></td></tr></table></figure></p><h5 id="修改表名："><a href="#修改表名：" class="headerlink" title="修改表名："></a>修改表名：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> testalter_tbl <span class="keyword">RENAME</span> <span class="keyword">TO</span> alter_tbl;</div></pre></td></tr></table></figure><p>睡了睡了，溜了溜了~😜</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;嗯，今天下午又看了一点MySQL。。依然是基础知识，只是在终端里面操作了一波，还没有使用一门后端语言来操作一波，之后接触了Node之后再来实际操作一波吧。👀&quot;&gt;&lt;a href=&quot;#嗯，今天下午又看了一点MySQL。。依然是基础知识，只是在终端里面操作了一波，还没
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://stan1812.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Learning</title>
    <link href="http://stan1812.github.io/2017/09/08/MySqlLearning/"/>
    <id>http://stan1812.github.io/2017/09/08/MySqlLearning/</id>
    <published>2017-09-08T11:26:04.000Z</published>
    <updated>2017-09-10T15:17:00.488Z</updated>
    
    <content type="html"><![CDATA[<p>最近除了摸鱼躺尸，就是看了一点关于MySQL的东西。开学这么多天什么也没干，，发现把之前看的都忘得差不多了，先来写篇博客把之前学的基本的啥东西梳理一下。</p><p>看的是深入浅出系列的《深入浅出SQL》，正如这个系列其他书籍一样，依然是看起来相当的轻松。一个晚上看了大概有100页（羞愧的是之后就没有怎么看，这段时间忙完之后要重新捡起来了）不说废话了。。</p><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><p><code>sudo apt-get install mysql-sever mysql-client</code></p><p>安装过程中就是一路输密码然后Y，安装成功之后SQL拂去就会自动开启</p><ul><li>手动停止： <code>sudo stop mysql</code></li><li>手动开启： <code>sudo start mysql</code></li><li>查看是否开启： <code>pgrep mysqld</code> (进程开启则返回进程ID)</li></ul><p>（网络畅通且权限正常的话安装就是分分种的事）</p><h3 id="简单管理操作："><a href="#简单管理操作：" class="headerlink" title="简单管理操作："></a>简单管理操作：</h3><p>首先当然要进入MySQL啦：</p><ul><li><code>mysql -u -root -p</code> 输密码</li><li><p><code>SHOW DATABASES</code> 列出列出 MySQL 数据库管理系统的数据库列表<br>mysql&gt; SHOW DATABASES;</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">+<span class="comment">--------------------+</span></div><div class="line">| Database           |</div><div class="line">+<span class="comment">--------------------+</span></div><div class="line">| information_schema |          |</div><div class="line">| cdcol              |</div><div class="line">| mysql              |</div><div class="line">| performance_schema |</div><div class="line">| phpmyadmin         |</div><div class="line">| test               |</div><div class="line">+<span class="comment">--------------------+</span></div><div class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</div></pre></td></tr></table></figure></li><li><p><code>USE TEST</code>选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">Database changed</div></pre></td></tr></table></figure></li><li><p><code>SHOW TABLES</code> 显示指定数据库的所有表</p><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">+<span class="comment">------------------+</span></div><div class="line">| Tables_in_test |</div><div class="line">+<span class="comment">------------------+</span></div><div class="line">| test0_tbl     |</div><div class="line">| test1_tbl       |</div><div class="line">| test2_tbl       |</div><div class="line">+<span class="comment">------------------+</span></div><div class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</div></pre></td></tr></table></figure></li><li><p><code>SHOW COLUMNS FROM 数据表</code>:显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。</p></li><li><code>SHOW INDEX FROM 数据表</code>:显示数据表的详细索引信息</li></ul><h3 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h3><ul><li><code>mysqladmin -u root -p create TEST</code> 创建TEST数据库</li><li><code>mysqladmin -u root -p drop TEST</code> (删库。。跑路？(这个不用跑^^))</li><li>创建新表：<ul><li>表名</li><li>表字段名</li><li>定义每个表字段</li></ul></li></ul><p>通用语法<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (column_name column_type);</div></pre></td></tr></table></figure></p><p>终端操作：<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">mysql&gt; CREATE TABLE runoob_tbl(</div><div class="line">   -&gt; runoob_id INT NOT NULL AUTO_INCREMENT,</div><div class="line">   -&gt; runoob_title VARCHAR(100) NOT NULL,</div><div class="line">   -&gt; runoob_author VARCHAR(40) NOT NULL,</div><div class="line">   -&gt; submission_date DATE,</div><div class="line">   -&gt; PRIMARY KEY ( runoob_id )</div><div class="line">   -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;</div><div class="line">Query OK, 0 rows affected (0.16 sec)</div></pre></td></tr></table></figure></p><ul><li>删表：<br>通用语法：<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name ;</div></pre></td></tr></table></figure></li></ul><p>实例：<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">mysql&gt; DROP TABLE test1_tbl</div><div class="line">Query OK, 0 rows affected (0.8 sec)</div></pre></td></tr></table></figure></p><ul><li>插入数据：<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name ( field1, field2,...fieldN )</div><div class="line">                       <span class="keyword">VALUES</span></div><div class="line">                       ( value1, value2,...valueN );</div></pre></td></tr></table></figure></li></ul><p>实例（直接Copy来自菜鸟教程）：<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">mysql&gt; INSERT INTO runoob_tbl </div><div class="line">    -&gt; (runoob_title, runoob_author, submission_date)</div><div class="line">    -&gt; VALUES</div><div class="line">    -&gt; ("PHP", "菜鸟教程", NOW());</div><div class="line">Query OK, 1 rows affected, 1 warnings (0.01 sec)</div><div class="line">mysql&gt; INSERT INTO runoob_tbl</div><div class="line">    -&gt; (runoob_title, runoob_author, submission_date)</div><div class="line">    -&gt; VALUES</div><div class="line">    -&gt; (" MySQL", "菜鸟教程", NOW());</div><div class="line">Query OK, 1 rows affected, 1 warnings (0.01 sec)</div><div class="line">mysql&gt; INSERT INTO runoob_tbl</div><div class="line">    -&gt; (runoob_title, runoob_author, submission_date)</div><div class="line">    -&gt; VALUES</div><div class="line">    -&gt; ("JAVA", "RUNOOB.COM", '2016-05-06');</div><div class="line">Query OK, 1 rows affected (0.00 sec)</div></pre></td></tr></table></figure></p><h3 id="查询数据："><a href="#查询数据：" class="headerlink" title="查询数据："></a>查询数据：</h3><p>MySQL 数据库使用SQL SELECT语句来查询数据<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> column_name,column_name</div><div class="line"><span class="keyword">FROM</span> table_name</div><div class="line">[<span class="keyword">WHERE</span> Clause]</div><div class="line">[<span class="keyword">OFFSET</span> M ][<span class="keyword">LIMIT</span> N]</div></pre></td></tr></table></figure></p><ul><li>查询语句中使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。</li><li>SELECT 命令可以读取一条或者多条记录。</li><li>使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据</li><li>使用 WHERE 语句来包含任何条件。</li><li>通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。</li><li>使用 LIMIT 属性来设定返回的记录数。</li></ul><h4 id="WHERE语句"><a href="#WHERE语句" class="headerlink" title="WHERE语句"></a>WHERE语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> field1, field2,...fieldN <span class="keyword">FROM</span> table_name1, table_name2...</div><div class="line">[<span class="keyword">WHERE</span> condition1 [<span class="keyword">AND</span> [<span class="keyword">OR</span>]] condition2.....</div></pre></td></tr></table></figure><p>实例：<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> runoob_tbl <span class="keyword">WHERE</span> runoob_author=<span class="string">'FUCKER'</span>;</div></pre></td></tr></table></figure></p><p>貌似目前就看了这些，，之后边看边写吧 ==！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近除了摸鱼躺尸，就是看了一点关于MySQL的东西。开学这么多天什么也没干，，发现把之前看的都忘得差不多了，先来写篇博客把之前学的基本的啥东西梳理一下。&lt;/p&gt;
&lt;p&gt;看的是深入浅出系列的《深入浅出SQL》，正如这个系列其他书籍一样，依然是看起来相当的轻松。一个晚上看了大概
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://stan1812.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>JS深浅拷贝</title>
    <link href="http://stan1812.github.io/2017/09/04/JS-depth1/"/>
    <id>http://stan1812.github.io/2017/09/04/JS-depth1/</id>
    <published>2017-09-04T14:07:53.000Z</published>
    <updated>2018-02-02T16:44:27.045Z</updated>
    
    <content type="html"><![CDATA[<p>对JS的深浅拷贝比较常用的方法来做一下总结。</p><h3 id="代码来说话"><a href="#代码来说话" class="headerlink" title="代码来说话"></a>代码来说话</h3><p>举个例子就差不多能懂这两个东西是什么了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> me =&#123;</div><div class="line">  <span class="string">'name'</span>:<span class="string">'xiaoming'</span>,</div><div class="line">  <span class="string">'age'</span>:<span class="string">'18'</span>,</div><div class="line">  <span class="string">'girlFriend'</span>:<span class="literal">null</span>,</div><div class="line">  <span class="string">'skill'</span>:&#123;</div><div class="line">    <span class="string">'eat'</span>:<span class="literal">true</span></div><div class="line">    <span class="string">'sleep'</span>:<span class="literal">true</span>,</div><div class="line">    <span class="string">'hitBeans'</span>:<span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是一个比较典型一点的对象，现在然后来做一下测试：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">src</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> dst = &#123;&#125;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> src) &#123;</div><div class="line">    <span class="keyword">if</span> (src.hasOwnProperty(prop)) &#123;</div><div class="line">        dst[prop] = src[prop];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dst;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">src</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> dist = &#123;&#125;</div><div class="line">    <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(src),</div><div class="line">     temp = <span class="literal">null</span>,</div><div class="line">     key = <span class="literal">null</span>,</div><div class="line">     leng = keys.length</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">      key = keys[i]</div><div class="line">      temp = src[key]</div><div class="line">      <span class="keyword">if</span>(temp &amp;&amp; <span class="keyword">typeof</span> temp===<span class="string">'Object'</span>)&#123;</div><div class="line">        dist[key] = deepCopy(temp)</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">         dist[key]=temp </div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">let</span> he = me;</div><div class="line">  <span class="keyword">let</span> she = shallowCopy(me);</div><div class="line">  <span class="keyword">let</span> emm = deepCopy(me)</div></pre></td></tr></table></figure></p><p>来分别进行几个简单的操作：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="number">1</span> he.name = <span class="string">"xiaogang"</span>;</div><div class="line"><span class="number">2</span> she.age = <span class="string">"20"</span>;</div><div class="line"><span class="number">3</span> she.skill.eat= <span class="literal">false</span></div><div class="line"><span class="number">4</span> emm.skill.eat = <span class="literal">false</span></div></pre></td></tr></table></figure></p><ul><li><p>he只是me的一个引用，也就是会改变me的值：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">me.name === xiaogang <span class="comment">//true</span></div></pre></td></tr></table></figure></li><li><p>she是一层浅拷贝，she.age = 20 此时she的age是新开辟的内存，so </p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">me.age=== <span class="number">18</span> <span class="comment">//true</span></div></pre></td></tr></table></figure></li><li><p>she.skill.eat 涉及到了me的一个对象属性skill而上面的一个浅拷贝方法并没有进行递归的操作，只是将第一层的属性复制一遍，而skill对象依然是保存的一个引用，所以就很明显了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">me.skill.eat === <span class="literal">false</span> <span class="comment">//true</span></div></pre></td></tr></table></figure></li><li><p>emm.skill.eat emm就是深拷贝得来的了，skill对象均是新开辟内存，所以就很明显了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">me.skill.eat === <span class="literal">false</span> <span class="comment">//false</span></div></pre></td></tr></table></figure></li></ul><p>突然觉得命名有些不合适。。怪怪的。。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>这里总结一下常见的几种浅拷贝的方法：</p><ul><li><p>直接遍历一遍</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">src</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> dst = &#123;&#125;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> src) &#123;</div><div class="line">    <span class="keyword">if</span> (src.hasOwnProperty(prop)) &#123;</div><div class="line">        dst[prop] = src[prop];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dst;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></li><li><p>使用 <code>Object.assign()</code>，其会拷贝源对象自身且可枚举的属性到目标对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> obj = &#123;xxxxx&#125;</div><div class="line"><span class="keyword">const</span> copyObj = <span class="built_in">Object</span>.assign(&#123;&#125;,obj)</div></pre></td></tr></table></figure></li></ul><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ul><li>我万万没有想到的是，JSON.stringfy(),和JSON.parse()竟然是最简单且执行效率最高的方法？？</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">const</span> dist = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringfy(obj))</div><div class="line">  <span class="keyword">return</span> dist</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>正常点的方法(适用于纯对象)<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">src</span>)</span>&#123;</div><div class="line">   <span class="keyword">let</span> dist = &#123;&#125;</div><div class="line">   <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(src),</div><div class="line">    temp = <span class="literal">null</span>,</div><div class="line">    key = <span class="literal">null</span>,</div><div class="line">    leng = keys.length</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</div><div class="line">     key = keys[i]</div><div class="line">     temp = src[key]</div><div class="line">     <span class="keyword">if</span>(temp &amp;&amp; <span class="keyword">typeof</span> temp===<span class="string">'Object'</span>)&#123;</div><div class="line">       dist[key] = deepCopy(temp)</div><div class="line">     &#125;<span class="keyword">else</span>&#123;</div><div class="line">        dist[key]=temp </div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></li></ul><p>在实际使用时，其实还是要注意Array，Date，RegExp的处理。。这里祭出一段Zepto的源码实现<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* 内部方法：用户合并一个或多个对象到第一个对象</span></div><div class="line"><span class="comment">* target 目标对象  对象都合并到target里</span></div><div class="line"><span class="comment">* source 合并对象</span></div><div class="line"><span class="comment">* deep 是否执行深度合并</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target, source, deep</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> source)</div><div class="line">        <span class="keyword">if</span> (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123;</div><div class="line">            <span class="keyword">if</span> (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key]))</div><div class="line">                target[key] = &#123;&#125;</div><div class="line">            <span class="keyword">if</span> (isArray(source[key]) &amp;&amp; !isArray(target[key]))</div><div class="line">                target[key] = []</div><div class="line">            <span class="comment">// 递归</span></div><div class="line">            extend(target[key], source[key], deep)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (source[key] !== <span class="literal">undefined</span>) target[key] = source[key]</div><div class="line">&#125;</div><div class="line"><span class="comment">// Copy all but undefined properties from one or more</span></div><div class="line"><span class="comment">// objects to the `target` object.</span></div><div class="line">$.extend = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> deep, args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="comment">//第一个参数为boolean值时，表示是否深度合并</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target == <span class="string">'boolean'</span>) &#123;</div><div class="line">        deep = target;</div><div class="line">        <span class="comment">//target取第二个参数</span></div><div class="line">        target = args.shift()</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 遍历后面的参数，都合并到target上</span></div><div class="line">    args.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123; extend(target, arg, deep) &#125;)</div><div class="line">    <span class="keyword">return</span> target</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>以及各种奇淫巧技<a href="https://dassur/.ma/things/deep-copy" target="_blank" rel="external">https://dassur/.ma/things/deep-copy</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对JS的深浅拷贝比较常用的方法来做一下总结。&lt;/p&gt;
&lt;h3 id=&quot;代码来说话&quot;&gt;&lt;a href=&quot;#代码来说话&quot; class=&quot;headerlink&quot; title=&quot;代码来说话&quot;&gt;&lt;/a&gt;代码来说话&lt;/h3&gt;&lt;p&gt;举个例子就差不多能懂这两个东西是什么了：&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>如何监听js中变量的变化</title>
    <link href="http://stan1812.github.io/2017/08/30/%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    <id>http://stan1812.github.io/2017/08/30/中变量的变化/</id>
    <published>2017-08-30T10:08:00.000Z</published>
    <updated>2017-08-31T07:13:03.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原生JS监听变量的变化"><a href="#原生JS监听变量的变化" class="headerlink" title="原生JS监听变量的变化"></a>原生JS监听变量的变化</h2><p>今天在刷知乎的时候遇到了这样的一个问题:<a href="https://www.zhihu.com/question/44724640?sort=created" target="_blank" rel="external">如何侦听JS中变量的变化</a>首先想到的是在Vue中的数据绑定，但是上车时间不长，是直接拿来用的。。并不知道实现原理，想了又想，没有好的解决方案。看到有大佬的答案后依然很迷，遂google一番，总结一下。</p><h2 id="几种解决方案："><a href="#几种解决方案：" class="headerlink" title="几种解决方案："></a>几种解决方案：</h2><h3 id="ES5的getter与setter"><a href="#ES5的getter与setter" class="headerlink" title="ES5的getter与setter"></a>ES5的getter与setter</h3><p>主要使用的是：<code>Object.defineProperty(obj, prop, descriptor)</code></p><p> <strong>参数</strong> ：</p><ul><li>obj 需要被操作的目标对象</li><li>prop 目标对象需要定义或修改的属性的名称。</li><li>descriptor 将被定义或修改的属性的描述符。</li></ul><p><strong>返回值</strong> :</p><ul><li>被传递给函数的对象</li></ul><p>以下是MDN的相关定义：</p><blockquote><p>该方法允许精确添加或修改对象的属性。一般情况下，我们为对象添加属性是通过赋值来创建并显示在属性枚举中（for…in 或 Object.keys 方法）， 但这种方式添加的属性值可以被改变，也可以被删除。而使用 Object.defineProperty() 则允许改变这些额外细节的默认设置。例如，默认情况下，使用  Object.defineProperty() 增加的属性值是不可改变的。</p><p>对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个拥有可写或不可写值的属性。存取描述符是由一对 getter-setter 函数功能来描述的属性。描述符必须是两种形式之一；不能同时是两者。</p><p>数据描述符和存取描述符均具有以下可选键值：</p><blockquote><ul><li>configurable<br>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</li><li>enumerable<br>当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</li></ul></blockquote><p>数据描述符同时具有以下可选键值：</p><blockquote><p>value<br>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。<br>writable<br>当且仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变。默认为 false。</p></blockquote><p>存取描述符同时具有以下可选键值：</p><blockquote><ul><li>get:<br>一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。</li><li>set<br>一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。</li></ul></blockquote></blockquote><p>定义看起来感觉有点复杂，而如果深入的讨论的话更加复杂，完全当手册用了，我们在此只关注基本的setter和getter</p><p>下面的例子说明了如何实现自我存档的对象。当 temperature 属性设置时，archive 数组会得到一个 log<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Archiver</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> temperature = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">var</span> archive = [];</div><div class="line"></div><div class="line">  <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'temperature'</span>, &#123;</div><div class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'get!'</span>);</div><div class="line">      <span class="keyword">return</span> temperature;</div><div class="line">    &#125;,</div><div class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">      temperature = value;</div><div class="line">      archive.push(&#123; <span class="attr">val</span>: temperature &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.getArchive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> archive; &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arc = <span class="keyword">new</span> Archiver();</div><div class="line">arc.temperature; <span class="comment">// 'get!'</span></div><div class="line">arc.temperature = <span class="number">11</span>;</div><div class="line">arc.temperature = <span class="number">13</span>;</div><div class="line">arc.getArchive(); <span class="comment">// [&#123; val: 11 &#125;, &#123; val: 13 &#125;]</span></div></pre></td></tr></table></figure></p><p>另一个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pattern = &#123;</div><div class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'I alway return this string,whatever you have assigned'</span>;</div><div class="line">    &#125;,</div><div class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.myname = <span class="string">'this is my name string'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestDefineSetAndGet</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'myproperty'</span>, pattern);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TestDefineSetAndGet();</div><div class="line">instance.myproperty = <span class="string">'test'</span>;</div><div class="line"></div><div class="line"><span class="comment">// 'I alway return this string,whatever you have assigned'</span></div><div class="line"><span class="built_in">console</span>.log(instance.myproperty);</div><div class="line"><span class="comment">// 'this is my name string'</span></div><div class="line"><span class="built_in">console</span>.log(instance.myname);</div></pre></td></tr></table></figure><p>这两个例子很好。</p><p>另外：IE8及更低版本IE是无法使用的，而且这个特性是没有polyfill的，无法在不支持的平台实现。</p><h3 id="Object-observe"><a href="#Object-observe" class="headerlink" title="Object.observe()"></a>Object.observe()</h3><p>Object.observe() 方法用于异步地监视一个对象的修改。当对象属性被修改时，方法的回调函数会提供一个有序的修改流。然而，这个接口已经被废弃并从各浏览器中移除。但是在我看了这几种解决方案之后，反而觉得这是种很好的解决方案。。</p><p>简单的介绍一下</p><p><code>Object.observe(obj, callback[, acceptList])</code></p><ul><li>obj 被监控的对象.</li><li><p>callback 当对象被修改时触发的回调函数，其参数为: </p><ul><li><p>changes 一个数组，其中包含的每一个对象代表一个修改行为。每个修改行为的对象包含: </p><ul><li>name: 被修改的属性名称。</li><li>object: 修改后该对象的值。</li><li>type: 表示对该对象做了何种类型的修改，可能的值为”add”, “update”, or “delete”。</li><li>oldValue: 对象修改前的值。该值只在”update”与”delete”有效。</li></ul></li><li><p>acceptList 在给定对象上给定回调中要监视的变化类型列表。如果省略， [“add”, “update”, “delete”, “reconfigure”, “setPrototype”, “preventExtensions”] 将会被使用。</p></li></ul></li></ul><p>数据绑定的示例：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 一个数据模型</span></div><div class="line"><span class="keyword">var</span> user = &#123;</div><div class="line">  id: <span class="number">0</span>,</div><div class="line">  name: <span class="string">'Brendan Eich'</span>,</div><div class="line">  title: <span class="string">'Mr.'</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 创建用户的greeting</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateGreeting</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  user.greeting = <span class="string">'Hello, '</span> + user.title + <span class="string">' '</span> + user.name + <span class="string">'!'</span>;</div><div class="line">&#125;</div><div class="line">updateGreeting();</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.observe(user, <span class="function"><span class="keyword">function</span>(<span class="params">changes</span>) </span>&#123;</div><div class="line">  changes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">change</span>) </span>&#123;</div><div class="line">    <span class="comment">// 当name或title属性改变时, 更新greeting</span></div><div class="line">    <span class="keyword">if</span> (change.name === <span class="string">'name'</span> || change.name === <span class="string">'title'</span>) &#123;</div><div class="line">      updateGreeting();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h3 id="使用ES6中的proxy"><a href="#使用ES6中的proxy" class="headerlink" title="使用ES6中的proxy"></a>使用ES6中的proxy</h3><p>proxy可以说是一个比较庞大的东西了，他可以做的事情有很多</p><p><code>let p = new Proxy(target, handler);</code></p><p><strong>参数</strong>: </p><ul><li>target 一个目标对象(可以是任何类型的对象，包括本机数组，函数，甚至另一个代理)用Proxy来包装。</li><li>handler  一个对象，其属性是当执行一个操作时定义代理的行为的函数。 <figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">通过代理，你可以轻松地验证向一个对象的传值。</div><div class="line"></div><div class="line">以下例子使用了 set 处理器（set handler）。</div><div class="line"></div><div class="line"><span class="keyword">let</span> validator = &#123;</div><div class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop, value</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (prop === <span class="string">'age'</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The age is not an integer'</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'The age seems invalid'</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// The default behavior to store the value</span></div><div class="line">    obj[prop] = value;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, validator);</div><div class="line"></div><div class="line">person.age = <span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(person.age); </div><div class="line"><span class="comment">// 100</span></div><div class="line"></div><div class="line">person.age = <span class="string">'young'</span>; </div><div class="line"><span class="comment">// 抛出异常: Uncaught TypeError: The age is not an integer</span></div><div class="line"></div><div class="line">person.age = <span class="number">300</span>; </div><div class="line"><span class="comment">// 抛出异常: Uncaught RangeError: The age seems invalid</span></div></pre></td></tr></table></figure></li></ul><p>这是一个在官方文档上的实例：它使用了set handler，监听了数据的改变。</p><p>暂时就这些吧</p><p>参考文章：</p><ul><li><a href="https://www.zhihu.com/question/44724640?sort=created" target="_blank" rel="external">如何侦听JS中变量的变化</a>中<a href="https://www.zhihu.com/people/daraw/answers" target="_blank" rel="external">@月迷津渡</a>的回答</li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="external"> MDN Object.defineProperty()</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/observe" target="_blank" rel="external">MDN Object.observe()</a></p></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="external">MDN Proxy</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原生JS监听变量的变化&quot;&gt;&lt;a href=&quot;#原生JS监听变量的变化&quot; class=&quot;headerlink&quot; title=&quot;原生JS监听变量的变化&quot;&gt;&lt;/a&gt;原生JS监听变量的变化&lt;/h2&gt;&lt;p&gt;今天在刷知乎的时候遇到了这样的一个问题:&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="技术" scheme="http://stan1812.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
</feed>
