<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Libx</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://stan1812.github.io/"/>
  <updated>2020-03-05T09:10:12.093Z</updated>
  <id>http://stan1812.github.io/</id>
  
  <author>
    <name>Shady</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【译】micor services</title>
    <link href="http://stan1812.github.io/2020/03/05/micor-services/"/>
    <id>http://stan1812.github.io/2020/03/05/micor-services/</id>
    <published>2020-03-05T09:06:18.000Z</published>
    <updated>2020-03-05T09:10:12.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MicorServices"><a href="#MicorServices" class="headerlink" title="MicorServices"></a>MicorServices</h1><blockquote><p>原文：MicorServices by Martin FLower <a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="external">原文</a><br>翻译： libx</p></blockquote><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>有关这个新的技术架构术语的定义：<br>“微服务架构”这个术语最近几年横空出世，来描述一种特定的软件设计方法：以若干组可以独立部署的服务进行软件应用系统的设计。虽然这种架构风格还没有较为准确的定义，但其在下述方面还是存在一定的共性：即围绕业务功能的组织、自动化部署、端点智能、和在编程语言和数据方面进行去中心化的控制。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a><em>目录</em></h3><ul><li><em>微服务体系结构的特征</em><ul><li><em>通过服务（Services）的组件化（Componentization）</em></li><li><em>围绕业务功能来组织团队</em></li><li>‘做产品’而非’做项目’</li><li><em>智能终端和傻瓜管道</em></li><li><em>去中心化治理技术</em></li><li><em>数据去中心化</em></li><li><em>基础设施自动化</em></li><li><em>容错设计</em></li><li><em>演进式设计</em></li></ul></li><li><em>微服务是未来的趋势吗?</em></li></ul><p>“微服务”– 这是在软件架构这条拥挤的大街上出现的又一个新词。虽然我们自然会倾向用轻蔑的眼光忽略这些东西，但是他所描述的软件系统风格，越来越吸引我们的注意。在过去几年中，我们可以看到许多项目开始使用这种风格，以至于我们身边的同事在构建企业级的应用时，会把它认为是一种理所应当的默认开发形式。但很不幸的是：微服务风格到底是什么，应该怎么开发，详细的理论描述却并不多。</p><p>简而言之：微服务架构风格【1】，就像是把一个单独的应用程序开发为一组小的服务来开发的方法。每个小服务都在自己的进程中运行，并且使用轻量级机制（通常是http的api）来进行通信。这些服务是围绕着业务功能构建的，可以通过完全自动化的部署机制进行独立的部署。这些服务的集中管理很少，可能使用不同的编程语言，使用不同的数据存储技术。</p><blockquote><p><em> 我的微服务资源指南提供了关于微服务的最佳文章、书籍、视频、和博客的链接。</em></p></blockquote><p>为了开始解释微服务风格，将其与单块（monolithic）风格进行比较是很有必要的：一个单块应用系统是以一个单个单元的方式来构建的。企业应用系统通常包括三个重要部分：:客户端用户界面(由在用户机器上的浏览器中运行的HTML页面和javascript组成)、数据库(由插入到公共(通常是关系的)数据库管理系统中的许多表组成)和服务器端应用程序。服务器端应用程序将处理HTTP请求、执行域逻辑、从数据库检索和更新数据，并选择和填充要发送到浏览器的HTML视图。这个服务器端应用程序是一个整体——逻辑可执行的[2]。对系统的任何更改都涉及到构建和部署服务器端应用程序的新版本。</p><p>这样的单块服务是构建这样一个系统的很自然的方式。处理请求的所有逻辑都在单个进程中运行，可以使用语言层面的基本特性来把程序划分类、函数、和命名空间。你可以小心的在开发人员身边运行和测试应用程序，并且通过部署管道来确定能够正确的测试更改并且将其部署到生产环境。通过在LB后面运行多个实例，可以水平的扩展整体。</p><p>单片应用程序可以获得成功，但是人们越来越对它们感到失望——尤其是越来越多的应用程序被部署到云上。更改周期被捆绑在一起——对应用程序的一小部分进行更改，需要重新构建和部署整个整体。随着时间的推移，通常很难保持一个良好的模块结构，这使得某个更改的影响范围越来越大，很难控制在某个模块内。当对系统进行扩展时，不得不扩展整个应用系统，而不能仅扩展该系统中需要更多资源的那些部分。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/153970/1583303549619-28b4e20a-05e7-48b7-b061-fe2cc8f0927c.png#align=left&amp;display=inline&amp;height=456&amp;name=sketch.png&amp;originHeight=520&amp;originWidth=850&amp;size=69171&amp;status=done&amp;style=none&amp;width=746" alt="sketch.png"></p><p>单块应用和微服务</p><p>这些问题导致了微服务架构风格的诞生：将应用程序构建为服务套件（一组服务）。除了服务是可以独立部署和可扩展之外。每个服务还提供了一个可靠的模块边界。甚至能够允许使用不同的编程语言来编写不同的服务，这些服务也能够被不同的团队来管理。</p><p>我们并不认为微服务风格是创新的。他的根源至少可以追述到Unix的设计原则。但是我们认为确实没有足够多的人在考虑使用微服务架构，如果加以使用，很多软件在开发起来会好很多。</p><h2 id="微服务体系结构的特性"><a href="#微服务体系结构的特性" class="headerlink" title="微服务体系结构的特性"></a>微服务体系结构的特性</h2><p>虽然我们还不能说微服务体系结构风格有一个正式的定义，但是我们可以尝试去描述我们所看到的符合这个标签的体系结构的共同特征。与任何概述公共特征的定义一样，并非所有微服务体系结构都具有所有特征，但我们确实希望大多数微服务体系结构都具有大多数特征。虽然我们作者一直是这个相当松散的社区的活跃成员，但我们的意图是尝试描述我们在自己的工作和我们所知道的团队的类似工作中看到的内容。特别需要指出的是，我们并不会制定一些大家都需要遵循的微服务的定义。</p><h3 id="通过服务（Services）的组件化（Componentization）"><a href="#通过服务（Services）的组件化（Componentization）" class="headerlink" title="通过服务（Services）的组件化（Componentization）"></a>通过服务（Services）的组件化（Componentization）</h3><p>自从我们开始涉足软件行业以来，大家都有一种把组件连接在一起来构建系统的愿望，就像我们为您在现实世界看到的东西一样。在过去的几十年里，我们可以看到相当大的进步，一些公共软件库是大多数编程语言平台的组成部分。</p><p>在讨论组件时，我们会遇到关于组件定义的难题。我们的定义是：组件是一个可以独立更换和升级的软件单元。</p><p>微服务架构也会使用软件库，但组件化软件的主要方式是把它拆分成服务。我们把库（libraries）定义为组件，这些组件被链接到程序，并通过内存中函数调用（in-memory function calls）来调用，而服务（services ）是进程外组件（out-of-process components），他们利用某个机制通信，比如 WebService 请求，或远程过程调用（remote procedure call）。组件和服务在很多面向对象编程中是不同的概念。</p><p>以使用服务而不是组件库来实现组件化的主要原因是：服务可以独立部署。如果应用程序【4】是由一个在单个进程中的多个软件库组成，那么对其任何一个组件进行修改，都需要重新部署整个应用系统。但是如果把应用程序分解为多个服务，那就可以预期到单个服务的更改，并且只需要重新部署该服务。这并不是绝对的，一些更改可能也会更改接口，需要多个服务进行协调。但是良好的微服务体系结构的目标是通过内聚服务边界和演化机制来最小化这些接口。</p><p>使用服务作为组件的另一个结果是更显式的组件接口。大多数语言都没有定义显示发布接口的良好机制。通常，通常情况下，这样的接口仅仅是文档声明和团队纪律，来避免客户端破坏组件的封装，从而导致组件间出现过度紧密的耦合。通过使用显式的远程调用机制，服务能更容易地避免这种情况发生。</p><p>使用这样的服务也确实有不足之处。比起进程内的调用，远程调用的成本更加昂贵，因此远程调用API必须是粗粒度的，而使用粗粒度的API通常会更困难。如果你需要更改组件之间的职责分配，则此类行为的改动会更加难以实现。</p><p>近似情况下，我们可以观察到服务映射到运行时流程，但这只是第一个近似情况。一个服务可能包含多个总是一起开发和部署的进程，例如一个应用程序流程和一个只由该服务使用的数据库。</p><h3 id="围绕“业务功能”组织团队"><a href="#围绕“业务功能”组织团队" class="headerlink" title="围绕“业务功能”组织团队"></a><strong>围绕“业务功能”组织团队</strong></h3><p>**在考虑将大型应用程序分割成多个部分时，管理层通常关注于技术层，从而导致组建UI团队、服务器端团队和数据库团队。当团队沿着这些线分开时，即使是简单的变更也会导致跨团队的项目需要时间和预算的批准。聪明的团队将围绕这一问题进行优化，并选择两害相权取其轻——只需将逻辑应用到他们能够访问的任何应用程序中。换句话说，逻辑无处不在。这是康威定律[5]的一个例子。</p><blockquote><p><em>任何设计（广义上的）系统的组织，都会产生这样一个设计，即该设计的结构与该组织的沟通结构相一致。</em><br>                                            ——梅尔文•康威（Melvyn Conway）, 1967年</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/153970/1583306945599-ab9daf67-8bd5-49d7-b2a7-52fbbe9493f8.png#align=left&amp;display=inline&amp;height=463&amp;name=conways-law.png&amp;originHeight=463&amp;originWidth=560&amp;size=58182&amp;status=done&amp;style=none&amp;width=560" alt="conways-law.png"></p><p>图二：Conway’s Law在起作用</p><p>微服务的划分方法是不同的，它根据业务能力将服务组织起来。此类服务采用该业务领域软件的宽堆栈实现，包括用户界面、持久存储和任何外部协作。因此，团队是跨功能的，包括开发所需的全部技能:用户体验、数据库和项目管理。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/153970/1583306950775-8785e0bf-6085-4667-a558-2f06144d5156.png#align=left&amp;display=inline&amp;height=430&amp;name=PreferFunctionalStaffOrganization.png&amp;originHeight=430&amp;originWidth=748&amp;size=78854&amp;status=done&amp;style=none&amp;width=748" alt="PreferFunctionalStaffOrganization.png"><br>图3:由团队边界加强的服务边界</p><p>以上述方式来组织团队的公司是www.comparethemarket.com。跨职能团队负责构建和运维每个产品，而每个产品被拆分为多个独立的服务，彼此通过一个消息总线来通信。</p><blockquote><p>一个微服务应该有多大？<br>虽然“微服务”已经成为这种体系结构风格的一个流行名称，但它的名称确实导致了对服务大小的关注，以及关于什么构成“微”的争论。在与微服务从业人员的对话中，我们看到了各种规模的服务。据报道，最大尺寸的披萨符合亚马逊的概念，即两个披萨团队(即整个团队可以吃两个披萨)：不超过12人。在规模较小的情况下，我们已经看到了一个6人的团队将支持6个服务。<br>这就引出了一个问题:在这个规模范围内是否存在足够大的差异，以至于不应该将每12人服务和每人服务的规模集中在一个微服务标签下。目前我们认为最好将它们组合在一起，但随着我们进一步探索这种风格，我们当然有可能改变主意。</p></blockquote><p>有一个这样组织的一个公司是www.comparethemarket.com。跨功能团队负责构建和操作每个产品，每个产品被分解为许多通过消息总线进行通信的单个服务。</p><p>大型单片应用程序也可以围绕业务功能进行模块化，尽管这并常见。当然，我们会敦促大型团队构建一个独立的应用程序，并将其按照业务线进行划分。这里的主要问题是，它们往往是围绕着太多的上下文来组织的。如果一个整体跨越了许多这样的模块边界，那么团队中的个别成员就很难将它们放入他们的短期记忆中。此外，我们看到，模块化的路线需要大量的纪律执行。服务组件必需的更显式的分离使得保持团队边界清晰更容易。</p><h3 id="“做产品”而非”做项目”"><a href="#“做产品”而非”做项目”" class="headerlink" title="“做产品”而非”做项目”"></a>“做产品”而非”做项目”</h3><p>我们看到的大多数应用程序开发工作都使用项目模型: 其中的目标是交付一些软件，然后认为这些软件已经完成。完成之后，软件将被移交给维护团队，而构建它的项目团队将被解散。</p><p>微服务的支持者倾向于避免这种模式，他们更倾向于认为一个团队应该在其整个生命周期内拥有一个产品。这一点来自Amazon的“谁构建，谁运行”的概念，在这个概念中，开发团队对生产中的软件承担全部责任。这将使开发人员与他们的软件在生产中的行为进行日常联系，并增加与用户的联系，因为他们必须承担一部分支持工作。</p><p>这样的’产品’心态，是与业务能力联系在一起的。他不是将软件视为一组要完成的功能，而是将其视为一种持续的关系：软件如何帮助其用户持续增强业务能力。</p><p>同样的方法也可以用于单片应用程序，但是较小粒度的服务可以更容易地在服务开发人员和他们的用户之间创建个人关系。</p><h3 id="“智能端点”与“傻瓜管道”"><a href="#“智能端点”与“傻瓜管道”" class="headerlink" title="“智能端点”与“傻瓜管道”"></a><strong>“智能端点”与“傻瓜管道”</strong></h3><p>当在不同的进程之间构建通信结构时，已经有了许多产品和方法，来强调将大量的智能特性纳入通信机制本身。一个典型例子就是“企业服务总线”(Enterprise Service Bus, ESB)。ESB产品经常包括高度智能的工具，来进行消息的路由、编制(choreography)、转换，并应用业务规则。</p><p>微服务社区主张采用另一种做法：智能端点(smart endpoints)和傻瓜管道(dumb pipes)。采用单独的业务逻辑，表现的更像经典Unix意义上的过滤器一样，接受请求、处理业务逻辑、返回响应。它们更喜欢简单的REST风格，而不是复杂的协议，如WS或者BPEL或者集中式框架。</p><blockquote><p>Microservices和SOA</p><p>当我们谈到微服务时，一个常见的问题是：这是否是我们十年前看到的面向服务的体系结构(SOA)。这一点是有讨论价值的，因为微服务风格与一些SOA倡导者所支持的非常相似。然而，问题在于SOA有着太多不同的东西，而且大多数时候我们遇到的所谓的“SOA”与我们在这里描述的风格有很大的不同，这通常是由于对用于集成单一应用程序的esb的关注。</p><p>特别是我们已经看到这么多糟糕的实现面向服务——从倾向于隐藏复杂性在ESB的[6],多年的计划失败,数以百万计的成本和交付没有价值,集中治理模式,积极抑制变化,有时很难看到过去的这些问题。</p><p>当然，微服务社区中使用的许多技术都来自于在大型组织中集成服务的开发人员的经验。容忍阅读器模式就是一个例子。使用web的努力是有贡献的，使用简单的协议是从这些经验中得到的另一种方法——一种远离中心标准的反应，坦率地说，已经达到了令人惊叹的复杂性。(任何时候你需要一个本体论来管理你的本体论，你知道你有大麻烦了。)&gt;<br>SOA的这种常见表现已经导致一些微服务倡导者完全拒绝了SOA的标签，尽管其他人认为微服务是SOA[7]的一种形式，可能是正确的面向服务。不管怎样，SOA意味着如此不同的东西，这一事实意味着有一个更明确定义这种体系结构风格的术语是有价值的。</p></blockquote><p>微服务最常用的两种协议是：带有资源API的HTTP“请求－响应”协议，和轻量级的消息发送协议[6]。对于前一种协议的最佳表述是：</p><blockquote><p>善于利用网络，而不是限制（Be of the web, not behind the web）。<br>——Ian Robinson</p></blockquote><p>微服务团队使用的是构建万维网时所使用的原则和协议（并且在很大程度上，这些原则和协议也是在构建Unix系统时所使用的）。那些被使用过的HTTP资源，通常能被开发或运维人员轻易地缓存起来。</p><p>第二种常用的方法是通过轻量级消息总线进行消息传递。基础设施的选择通常是傻瓜型的(仅仅像是充当消息路由器)——简单的实现如RabbitMQ或ZeroMQ，除了提供一个可靠的异步机制以外不需要做其他的事情——主要的功能只存在于生产和消费的端点中，也即在各个服务中。</p><p>在一个单块系统中，组件是在一个进程中执行的，它们之间的通信是通过方法调用或函数调用进行的。把一个庞然大物变成微服务的最大问题在于改变通信模式。从内存中方法调用到RPC的简单转换会导致通信混乱，性能不佳。相反，您需要将细粒度的通信替换为粗粒度的方法</p><h3 id="去中心化治理技术"><a href="#去中心化治理技术" class="headerlink" title="去中心化治理技术"></a>去中心化治理技术</h3><p>集中化治理的后果之一酒是在单一技术平台上标准化的趋势。经验表明，这种方法是有局限性的——不是所有的问题都是钉子，也不是所有的解决方案都是锤子。我们更喜欢使用正确的工具来完成工作，虽然单块程序可以在一定程度上利用不同的语言，但这并不常见。</p><p>如果能将单块应用的的组件拆分成多个服务，那么在构建每个组件时都有选择不同技术栈的机会。您想使用Node.js来建立一个简单的报告页面吗?就去做吧。一个近实时组件的c++ ?很好。您想要交换一个不同风格的数据库，以更好地适应一个组件的读取行为吗?可以重建。</p><p>当然，可以做并不意味着应该这样，但是以微服务来拆分系统意味着您有这个选项。</p><p>相比使用业界常见的技术，构建微服务的团队更喜欢采用不同的方法。与其使用一组写在纸上的定义标准，他们更喜欢开发一些有用的工具，并且让其他开发者能够使用。这些工具通常源自于微服务实施过程中，并与更广泛的组共享，但不完全使用内部开源模型。现在git和github已经成为事实上的版本控制系统的选择，开源实践在企业内部也变得越来越普遍。</p><p>Netflix就是遵循这一理念的一个很好的例子。共享有用的、最重要的、经过实战测试的代码，能鼓励其他开发人员以类似的方式解决类似的问题，如果需要，也可以选择不同的方法。共享库往往集中在数据存储、进程间通信以及基础设施自动化等常见问题上。</p><p>微服务社区中，成本问题特别引人注意。这并不是说，社区不认为服务交互的价值。相反，正是因为发现到它的价值。这使得他们在寻找各种方法来解决它们。如<a href="http://martinfowler.com/bliki/TolerantReader.html" target="_blank" rel="external">Tolearant Reader</a>和<a href="http://martinfowler.com/articles/consumerDrivenContracts.html" target="_blank" rel="external">Consumer-Driven Contracts</a>这样的设计模式就经常被微服务使用。模式通常应用于微服务。这些援助服务合同是独立发展的。作为构建的一部分执行消费者驱动的契约可以增强开发团队的信心，并提供关于所依赖的服务是否正常运行的快速反馈。 实际上，我们了解到澳大利亚有一个团队利用<a href="http://martinfowler.com/articles/consumerDrivenContracts.html" target="_blank" rel="external">Consumer-Driven Contracts</a>模式来推动新服务的构建。他们使用简单的工具来定义服务的契约。在编写新服务的代码之前，这就成为自动构建的一部分。然后，服务只构建到满足契约的那一点上——这是在构建新软件时避免“YAGNI”[9]困境的一种优雅方法。这些技术和围绕它们发展起来的工具通过减少服务之间的时间耦合来限制对中央契约管理的需求。</p><p>或许，亚马逊(Amazon)普及的“构建it /运行it”(build it / run it)精神，才是去中心化治理的顶点。团队对他们构建的软件的所有方面负责，包括24/7的软件操作。这种级别的责任下放绝对不是常态，但我们确实看到越来越多的公司将责任推给开发团队。Netflix是另一家采纳了这种精神的公司【11】。在编写代码时，每天凌晨3点被寻呼机叫醒无疑是关注代码质量的强大动力。这些想法与传统的集中式治理模型相去甚远。</p><h3 id="数据管理去中心化"><a href="#数据管理去中心化" class="headerlink" title="数据管理去中心化"></a>数据管理去中心化</h3><p>去中心化地管理数据，其表现形式多种多样。在最抽象的层次上来看，这意味着各个系统对客观世界所构建的概念模型，将各不相同。这是大型企业进行系统集成时的常见问题，客户的销售视角和将与支持者的视角不同。有些在sales视图中称为customers的东西可能根本不会出现在support视图中。这样做可能会有不同的属性和具有微妙不同语义的公共属性。</p><p>这个问题在应用程序之间很常见，但也可能发生在应用程序内部，特别是当应用程序被划分为单独的组件时。考虑这个问题的一个有用方法是领域驱动的有界上下文设计概念。DDD将一个复杂的域划分为多个有界的上下文，并映射出它们之间的关系。此过程对于单片和微服务体系结构都很有用，但是服务和上下文边界之间存在一种自然的关联，这有助于澄清，并且正如我们在业务功能一节中所描述的那样，这种关联加强了分离。</p><blockquote><p><strong>“实战检验”的标准与“强制执行”的标准</strong></p><p>微服务团队倾向于避开由企业架构组制定的严格执行的标准，而乐于使用甚至宣传使用开放标准，如HTTP、ATOM和其他微格式，这有点矛盾。<br>关键的区别在于标准是如何制定和如何执行的。像IETF这样的组织管理的标准只有在更广泛的世界中有几个实时实现的情况下才会成为标准，而且这些标准通常来自成功的开源项目。<br>这些标准与企业世界中的许多标准截然不同，企业世界中的许多标准通常是由最近几乎没有编程经验或过度受供应商影响的团队开发的。</p></blockquote><p>如同在概念模型上进行去中心化的决策一样，微服务也在数据存储上进行去中心化的决策。尽管各个单块应用更愿意在逻辑上各自使用一个单独的数据库来持久化数据，但企业通常更喜欢跨一系列应用程序使用单个数据库——其中许多决策是由供应商围绕许可的商业模型驱动的。微服务更喜欢让每个服务管理自己的数据库，要么是相同数据库技术的不同实例，要么是完全不同的数据库系统——这种方法称为多语言持久性。您可以在一个整体中使用polyglot持久性，但是它在微服务中出现得更频繁。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/153970/1583309411779-73fc4e35-8543-42cc-af62-5e31942080f7.png#align=left&amp;display=inline&amp;height=430&amp;name=PreferFunctionalStaffOrganization.png&amp;originHeight=430&amp;originWidth=748&amp;size=78854&amp;status=done&amp;style=none&amp;width=748" alt="PreferFunctionalStaffOrganization.png"><br>将数据的责任分散到各个微服务上对管理更新有一定的影响。处理更新的常用方法是在更新多个资源时使用事务来保证一致性。这种方法通常用于单块系统。</p><p>使用这样的事务有助于保持一致性，但会带来重大的时间耦合，这在多个服务之间是有问题的。众所周知，分布式事务是非常难以实现的，因此微服务体系结构强调服务之间的无事务协调，明确地认识到一致性可能只是要求数据最终的一致性，并且一致性问题是通过补偿操作来处理的。</p><p>对于许多开发团队来说，选择以这种方式管理数据的不一致性是一个新的挑战，但它通常与业务实践相匹配。通常，企业处理一定程度的不一致性是为了快速响应需求，同时使用某种反转过程来处理错误。只要修复错误的成本小于在更大的一致性下丢失业务的成本，这种权衡就是值得的。</p><h3 id="“基础设施”自动化"><a href="#“基础设施”自动化" class="headerlink" title="“基础设施”自动化"></a>“基础设施”自动化</h3><p>基础设施自动化技术在过去几年里有了巨大的发展——特别是云计算和AWS的发展降低了构建、部署和运行微服务的操作复杂性。</p><p>许多使用微服务构建的产品或系统都是由具有丰富的持续交付和持续集成经验的团队构建的。以这种方式构建软件的团队广泛使用了基础设施自动化技术。<img src="https://cdn.nlark.com/yuque/0/2020/png/153970/1583309671166-32d0800c-ffff-4973-ad21-67b657bade25.png#align=left&amp;display=inline&amp;height=200&amp;name=basic-pipeline.png&amp;originHeight=200&amp;originWidth=667&amp;size=46005&amp;status=done&amp;style=none&amp;width=667" alt="basic-pipeline.png"></p><p>图5: basic build pipeline</p><p>因为这不是一篇关于持续交付的文章，所以我们在这里只关注几个关键特性。我们希望尽可能地确信我们的软件能够正常工作，因此我们运行了大量的自动化测试。工作软件的升级意味着我们将自动部署到每个新环境。</p><blockquote><p>让做正确的事情变得容易</p><p>作为持续交付和部署的结果，我们发现自动化程度提高的一个副作用是创建了有用的工具来帮助开发人员和操作人员。用于创建人工制品、管理代码库、支持简单服务或添加标准监视和日志记录的工具现在非常常见。网络上最好的例子可能是Netflix的一套开源工具，但也有其他的，包括我们广泛使用的Dropwizard。</p></blockquote><p>一个单块应用程序将会在这些环境中非常随意地构建、测试和发布。事实证明，一旦你打算为一个整体实现生产路径的自动化，那么部署更多的应用程序就不再那么可怕了。请记住，CD的目标之一是让部署变得乏味，因此无论它是一个还是三个应用程序，只要它仍然是乏味的，[12]都没有关系。</p><p>我们看到一些团队使用广泛的基础设施自动化的另一个领域是在生产中管理微服务。与我们上面的断言不同，只要部署是乏味的，那么单体和微服务之间就没有那么大的差别，每种服务的操作环境都可能是截然不同的。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/153970/1583309902866-fcb33a9a-f3dc-4c9e-bbeb-8b937782f3c6.png#align=left&amp;display=inline&amp;height=363&amp;name=micro-deployment.png&amp;originHeight=363&amp;originWidth=778&amp;size=52116&amp;status=done&amp;style=none&amp;width=778" alt="micro-deployment.png"><br>图6:模块部署通常是不同的</p><h3 id="容错设计"><a href="#容错设计" class="headerlink" title="容错设计"></a>容错设计</h3><p>将服务作为组件使用的一个结果是：需要将应用程序设计为能够容忍服务的失败。如果供应商不可用，任何服务调用都可能失败，客户端必须尽可能优雅地响应。与单块应用的设计相比，这是一个劣势，因为它引入了额外的复杂性来处理它。其结果是，微服务团队不断地反思服务故障如何影响用户体验。Netflix的测试工具Simian Army会在工作日中会导致服务甚至数据中心出现故障，来测试应用程序的弹性和监控。</p><p>由于服务可能在任何时候出现故障，因此能够快速检测故障并在可能的情况下自动恢复服务非常重要。微服务应用程序非常强调应用程序的实时监控，检查体系结构元素(数据库每秒获得多少请求)和业务相关指标(例如每分钟接收多少订单)。语义监视可以提供出错的早期预警系统，从而触发开发团队进行跟踪和调查。</p><p>这对于微服务体系结构尤其重要，因为微服务对编排和事件协作的偏好会导致紧急行为。虽然许多权威人士对偶发事件的价值持积极态度，但事实是，突发性为有时可能是一件坏事。对于快速发现不良的紧急行为是至关重要的，这样才能对其进行修复。</p><blockquote><p>被认为有害的同步调用<br>任何时候，只要服务之间有大量的同步调用，就会遇到停机的乘法效应。简单地说，这就是系统的停机时间变成各个组件停机时间的产物的时候。您面临一个选择，是异步调用还是管理停机时间。在www.guardian.co.uk，他们在新平台上实现了一个简单的规则——每个用户请求一个同步调用;而在Netflix，他们重新设计的平台API已经在API结构中构建了异步性。</p></blockquote><p>单块系统可以被建造得像微服务一样透明——事实上，它们应该是透明的。不同之处在于，您绝对需要知道在不同进程中运行的服务何时断开连接。如果库在相同的过程中，这种透明性就不太可能有用。</p><p>微服务团队希望看到每个单独服务的复杂监视和日志设置，比如显示显示/关闭状态的仪表板以及各种操作和业务相关的度量。关于断路器状态、电流吞吐量和延迟的详细信息都是我们经常遇到的例子。</p><h3 id="演进式设计"><a href="#演进式设计" class="headerlink" title="演进式设计"></a>演进式设计</h3><p>微服务的实践者，通常来自于演进式设计的背景，并将服务分解看作是使应用程序开发人员能够控制其应用程序中的更改而不减慢更改的进一步工具。控制变更并不一定意味着减少变更——通过正确的态度和工具，可以对软件进行频繁、快速和控制良好的变更。</p><p>当试图将一个软件系统分解成多个组件时，就会面临着如何分割这些组件的决定——决定分割应用程序时所依据的原则是什么?组件的关键属性是独立替换和可升级性[13]的概念——这意味着我们要寻找这些点，集想象着在不影响其协作者的情况下重写组件。实际上，许多微服务团队会更进一步，他们会明确给出许多服务会被废弃的预期，而不是守着这些服务做长期的演进。</p><p>卫报网站是一个很好的例子，它被设计和构建为一个单块系统，但一直在朝着微服务的方向发展。单体仍然是网站的核心，但他们更喜欢通过使用单体的API构建微服务来增加新功能。这种方法对于本质上是临时的特性(比如处理体育赛事的专门页面)特别方便。使用快速开发语言可以快速地将网站的这一部分整合在一起，并在活动结束后将其删除。我们在一家金融机构看到过类似的做法，为了抓住市场机会而增加新服务，但几个月甚至几周后就放弃了。</p><p>这种强调可替换性的特点，是模块化设计普遍原则的一个特例，即通过”变化模式”[14]来驱动模块化。您希望将同时更改的内容保存在同一个模块中。一个系统中很少变化的部分应该放在在不同的服务中，以区别那些正经历着大量变化的服务。如果您发现自己反复地同时更改两个服务，那么就说明应该合并它们。</p><p>将组件放入服务为更细粒度的发布计划提供了机会。对于一个整体来说，任何更改都需要对整个应用程序进行完整的构建和部署。但是，对于微服务，您只需要重新部署您修改的服务。这可以简化和加速发布过程。缺点是您必须担心某个服务的更改会破坏其使用者。传统的集成方法是尝试使用版本控制来处理这个问题，但是在微服务世界中，倾向于只使用版本控制作为最后的手段。我们可以通过设计服务来尽可能地容忍其供应商的更改，从而避免大量的版本控制。</p><h2 id="微服务是未来的趋势吗"><a href="#微服务是未来的趋势吗" class="headerlink" title="微服务是未来的趋势吗?"></a>微服务是未来的趋势吗?</h2><blockquote><p>Microservice权衡<br>许多开发团队发现微服务体系结构风格是一种优于单一体系结构的方法。但是其他的团队发现他们是一个生产力消耗的负担。与任何建筑风格一样，微服务也带来了成本和收益。为了做出明智的选择，你必须理解这些并将它们应用到你的特定环境中。<br>由马丁 2015年7月1日</p></blockquote><p>我们写这篇文章的主要目的是解释微服务的主要思想和原则。通过花时间来做这件事，我们清楚地认为微服务体系结构风格是一个重要的思想——一个值得企业应用程序认真考虑的思想。我们最近已经构建了几个使用这种风格的系统，并且了解了其他使用过并喜欢这种方法的人。</p><p>据我们所知，在某种程度上引领这种建筑风格的公司包括亚马逊(Amazon)、Netflix、《卫报》(the Guardian)、英国政府数字服务公司realestate.com.au、Forward和comparethemarket.com。2013年的会议上到处都是公司转向微服务的例子，包括Travis CI。此外，有许多组织长期以来一直在做我们称之为微服务的事情，但从未使用过这个名称。(这通常被称为SOA——尽管正如我们所说，SOA有许多相互矛盾的形式。[15])</p><p>尽管有这些积极的经验，但是，我们并不认为微服务是软件架构的未来方向。虽然到目前为止，我们的经验与单片应用程序相比是积极的，但我们意识到，没有足够的时间让我们做出充分的判断。</p><p>通常，您的架构决策的真正后果只在您做出它们的几年后才显现出来。我们曾经看到过这样的项目:一个优秀的团队，带着对模块化的强烈渴望，构建了一个经过多年衰落的整体架构。许多人认为，微服务不太可能出现这种衰退，因为服务边界是明确的，而且很难修补。然而，直到我们看到足够多的系统和足够长的时间，我们才能真正评估微服务体系结构的成熟程度。</p><p>当然，我们有理由认为微服务的成熟程度会很低。在任何组件化的努力中，成功取决于软件在多大程度上适合于组件。很难确定组件边界的确切位置。进化式设计认识到获得正确边界的困难，从而认识到重构它们的重要性。但是，如果您的组件是带有远程通信的服务，那么重构要比使用进程内库困难得多。跨服务边界移动代码是困难的，任何接口更改都需要在参与者之间进行协调，需要添加向后兼容层，测试也变得更加复杂。</p><p>我们的同事山姆·纽曼(Sam Newman) 2014年的大部分时间都在写一本书，这本书捕捉了我们构建微服务的经验。如果你想更深入地研究这个话题，这应该是你的下一步。</p><p>另一个问题是，如果组件不能干净地组合，那么您所做的就是将复杂性从组件内部转移到组件之间的连接上。这不仅仅是将复杂性转移，它还将复杂性转移到一个不那么明确和难以控制的地方。当您查看一个小的、简单的组件的内部，而忽略了服务之间混乱的连接时，很容易认为情况会更好。</p><p>最后，还有团队技能的因素。新技术往往被更熟练的团队采用。但是，对于技术更熟练的团队来说更有效的技术不一定适用于技术较差的团队。我们已经看到了很多不太熟练的团队构建混乱的单体架构的例子，但是我们需要时间来了解当这种混乱发生在微服务上时会发生什么。一个糟糕的团队总是会创造出一个糟糕的系统——很难判断微服务在这种情况下是减少了混乱还是使它变得更糟。</p><p>我们听到的一个合理的观点是，不应该从微服务体系结构开始。相反，从一个整体开始，保持它的模块化，一旦这个整体成为一个问题，就把它分割成微服务。(尽管这个建议并不理想，因为良好的进程内接口通常不是良好的服务接口。)</p><p>因此，我们怀着谨慎的乐观态度来写这篇文章。到目前为止，我们已经对微服务风格有了足够的了解，我们觉得这是一条值得走的路。我们不能确定我们将在哪里结束，但是软件开发的挑战之一是，您只能根据当前必须提供的不完善的信息做出决策。</p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>1: 2011年5月，威尼斯附近的一个软件架构师研讨会上讨论了“微服务”这个术语，以描述参与者所看到的一种共同的架构风格，他们中的许多人最近都在探索这种风格。2012年5月，该组织决定将“微服务”作为最合适的名称。2012年3月，James在Krakow的第33届微服务课程(Java, Unix方式)上提出了一些想法，并将其作为一个案例进行了研究，当时Fred George也是这样做的。Netflix的Adrian Cockcroft将这种方法描述为“细粒度的SOA”，正如本文中提到的其他许多人—Joe Walnes、Daniel Terhorst-North、Evan Botcher和Graham Tackley—一样，在web范围内开创了这种风格。</p><p>2: Unix社区使用monolith这个术语已经有一段时间了。它出现在Unix编程艺术中，用来描述变得太大的系统。</p><p>3:许多面向对象的设计人员，包括我们自己在内，在领域驱动设计的意义上使用术语服务对象来表示一个对象，该对象执行一个不与实体绑定的重要过程。这与我们在本文中使用“服务”是一个不同的概念。遗憾的是，“服务”这个词有两个含义，我们不得不忍受一词多义的情况。</p><p>4:我们认为应用程序是一个社会结构，它将代码库、功能组和资金体绑定在一起。原文可以在梅尔文·康威的网站上找到。他说:我们不得不提到Jim Webber说的ESB代表“令人震惊的意大利面盒子”。</p><p>7: Netflix明确了这个链接——直到最近才把他们的架构风格称为细粒度的SOA。</p><p>8:在极端情况下，组织经常转向二进制协议——例如protobufs。使用这些技术的系统仍然表现出智能端点、哑管道的特点，并且以透明度换取规模。大多数的网站和绝大多数的企业都不需要做这样的权衡——透明度可以是一个巨大的胜利。</p><p>9：“YAGNI”或“您不需要它”是XP的原则，并告诫您在知道需要它们之前不要添加特性。</p><p>10:我们有点不相信所谓的单一语言——为了在今天的web上构建系统，您可能需要了解JavaScript和XHTML、CSS、您选择的服务器端语言、SQL和ORM方言。不是单一的语言，但你知道我们的意思。</p><p>11：在2013年11月的Flowcon大会上，Adrian Cockcroft特别提到了“开发者自助服务”和“开发者运行他们写的东西”(原文如此)。</p><p>12：我们在这里有点不礼貌。显然，在更复杂的拓扑中部署更多的服务要比部署单一的实体更困难。幸运的是，模式降低了这种复杂性——但是在工具上的投资仍然是必须的。</p><p>13:事实上，Daniel Terhorst-North将这种风格称为可替换的组件架构，而不是微服务。因为这似乎是针对后者的一个子集，我们更喜欢后者。</p><p>14：Kent Beck强调这是他在实现模式中的设计原则之一。</p><p>15: SOA并不是这段历史的根源。我记得当SOA这个术语在本世纪初出现时，人们说“我们已经做了很多年了”。有一种观点认为，这种风格的根源在于COBOL程序在早期企业计算中通过数据文件进行通信的方式。从另一个角度来看，可以认为微服务与Erlang编程模型是一回事，但应用于企业应用程序上下文。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://blogs.msdn.com/b/clemensv/" target="_blank" rel="external">Clemens Vasters’ blog on cloud at microsoft</a></li><li><a href="http://davidmorgantini.blogspot.com/2013/08/micro-services-introduction.htm" target="_blank" rel="external">David Morgantini’s introduction to the topic on his blog</a></li><li><a href="http://12factor.net/" target="_blank" rel="external">12 factor apps from Heroku</a></li><li><a href="https://www.gov.uk/design-principles" target="_blank" rel="external">UK Government Digital Service design principles</a></li><li><a href="http://jimmynilsson.com/blog/" target="_blank" rel="external">Jimmy Nilsson’s blog</a><a href="http://www.infoq.com/articles/CCC-Jimmy-Nilsson" target="_blank" rel="external">and article on infoq about Cloud Chunk Computing</a></li><li><a href="http://alistair.cockburn.us/Hexagonal+architecture" target="_blank" rel="external">Alistair Cockburn on Hexagonal architectures</a></li></ul><p>Books</p><ul><li><a href="https://www.amazon.com/gp/product/0978739213?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0978739213" target="_blank" rel="external">Release it</a></li><li><a href="https://www.amazon.com/gp/product/0596805829?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0596805829" target="_blank" rel="external">Rest in practice</a></li><li><a href="https://pages.apigee.com/web-api-design-ebook.html" target="_blank" rel="external">Web API Design (free ebook)</a>. Brian Mulloy, Apigee.</li><li><a href="https://www.amazon.com/gp/product/0321200683?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321200683" target="_blank" rel="external">Enterprise Integration Patterns</a></li><li><a href="https://www.amazon.com/gp/product/0131429019?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0131429019" target="_blank" rel="external">Art of unix programming</a></li><li><a href="https://www.amazon.com/gp/product/0321503627?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321503627" target="_blank" rel="external">Growing Object Oriented Software, Guided by Tests</a></li><li><a href="https://www.amazon.com/gp/product/0198293755?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0198293755" target="_blank" rel="external">The Modern Firm: Organizational Design for Performance and Growth</a></li><li><a href="https://www.amazon.com/gp/product/0321601912?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321601912" target="_blank" rel="external">Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation</a></li><li><a href="https://www.amazon.com/gp/product/0321125215?ie=UTF8&amp;tag=martinfowlerc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0321125215" target="_blank" rel="external">Domain-Driven Design: Tackling Complexity in the Heart of Software</a></li></ul><p>Presentations</p><ul><li><a href="https://www.youtube.com/watch?v=qVyt3qQ_7TA" target="_blank" rel="external">Architecture without Architects</a>. Erik Doernenburg.</li><li><a href="http://www.infoq.com/presentations/soa-without-esb" target="_blank" rel="external">Does my bus look big in this?</a>. Jim Webber and Martin Fowler, QCon 2008</li><li><a href="http://www.infoq.com/presentations/webber-guerilla-soa" target="_blank" rel="external">Guerilla SOA</a>. Jim Webber, 2006</li><li><a href="http://vimeo.com/43659070" target="_blank" rel="external">Patterns of Effective Delivery</a>. Daniel Terhorst-North, 2011.</li><li><a href="http://www.slideshare.net/adrianco" target="_blank" rel="external">Adrian Cockcroft’s slideshare channel</a>.</li><li><a href="http://vimeo.com/28608667" target="_blank" rel="external">Hydras and Hypermedia</a>. Ian Robinson, JavaZone 2010</li><li><a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="external">Justice will take a million intricate moves</a>. Leonard Richardson, Qcon 2008.</li><li><a href="http://vimeo.com/74452550" target="_blank" rel="external">Java, the UNIX way</a>. James Lewis, JavaZone 2012</li><li><a href="http://yow.eventer.com/yow-2012-1012/micro-services-architecture-by-fred-george-1286" target="_blank" rel="external">Micro services architecture</a>. Fred George, YOW! 2012</li><li><a href="http://gotocon.com/video#18" target="_blank" rel="external">Democratising attention data at guardian.co.uk</a>. Graham Tackley, GOTO Aarhus 2013</li><li><a href="http://gotocon.com/video#6" target="_blank" rel="external">Functional Reactive Programming with RxJava</a>. Ben Christensen, GOTO Aarhus 2013 (registration required).</li><li><a href="http://www.infoq.com/presentations/Breaking-the-Monolith" target="_blank" rel="external">Breaking the Monolith</a>. Stefan Tilkov, May 2012.</li></ul><p>Papers</p><ul><li>L. Lamport, “The Implementation of Reliable Distributed Multiprocess Systems”, 1978 http:// research.microsoft.com/en-us/um/people/lamport/pubs/implementation.pdf</li><li>L. Lamport, R. Shostak, M. Pease, “The Byzantine Generals Problem”, 1982 (available at) http:// www.cs.cornell.edu/courses/cs614/2004sp/papers/lsp82.pdf</li><li>R.T. Fielding, “Architectural Styles and the Design of Network-based Software Architectures”, 2000 <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="external">http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</a></li><li>E. A. Brewer, “Towards Robust Distributed Systems”, 2000 <a href="http://www.cs.berkeley.edu/" target="_blank" rel="external">http://www.cs.berkeley.edu/</a> ~brewer/cs262b-2004/PODC-keynote.pdf</li><li>E. Brewer, “CAP Twelve Years Later: How the ‘Rules’ Have Changed”, 2012, http:// www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MicorServices&quot;&gt;&lt;a href=&quot;#MicorServices&quot; class=&quot;headerlink&quot; title=&quot;MicorServices&quot;&gt;&lt;/a&gt;MicorServices&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原文：MicorServi
      
    
    </summary>
    
    
      <category term="技术" scheme="http://stan1812.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>《计算广告》阅读笔记(在线广告市场与背景)</title>
    <link href="http://stan1812.github.io/2020/03/04/computational-ads/"/>
    <id>http://stan1812.github.io/2020/03/04/computational-ads/</id>
    <published>2020-03-04T09:17:12.000Z</published>
    <updated>2020-03-05T09:26:24.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-在线广告市场与背景"><a href="#第一部分-在线广告市场与背景" class="headerlink" title="第一部分 在线广告市场与背景"></a>第一部分 在线广告市场与背景</h1><h2 id="Capter1-在线广告综述"><a href="#Capter1-在线广告综述" class="headerlink" title="Capter1 在线广告综述"></a>Capter1 在线广告综述</h2><h3 id="1-1-大数据与广告的关系"><a href="#1-1-大数据与广告的关系" class="headerlink" title="1.1.大数据与广告的关系"></a>1.1.大数据与广告的关系</h3><h3 id="1-2-广告的定义与目的"><a href="#1-2-广告的定义与目的" class="headerlink" title="1.2.广告的定义与目的"></a>1.2.广告的定义与目的</h3><h3 id="1-3-在线广告创意类型"><a href="#1-3-在线广告创意类型" class="headerlink" title="1.3.在线广告创意类型"></a>1.3.在线广告创意类型</h3><h3 id="1-4-在线广告简史"><a href="#1-4-在线广告简史" class="headerlink" title="1.4.在线广告简史"></a>1.4.在线广告简史</h3><h3 id="1-5-泛广告商业产品"><a href="#1-5-泛广告商业产品" class="headerlink" title="1.5.泛广告商业产品"></a>1.5.泛广告商业产品</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一部分-在线广告市场与背景&quot;&gt;&lt;a href=&quot;#第一部分-在线广告市场与背景&quot; class=&quot;headerlink&quot; title=&quot;第一部分 在线广告市场与背景&quot;&gt;&lt;/a&gt;第一部分 在线广告市场与背景&lt;/h1&gt;&lt;h2 id=&quot;Capter1-在线广告综述&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Reading" scheme="http://stan1812.github.io/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>2019-我想和这个世界谈谈</title>
    <link href="http://stan1812.github.io/2019/12/21/2019/"/>
    <id>http://stan1812.github.io/2019/12/21/2019/</id>
    <published>2019-12-21T09:10:30.000Z</published>
    <updated>2020-03-03T08:52:42.351Z</updated>
    
    <content type="html"><![CDATA[<p>照常该写一下今年的总结了，想要尝试想一个听起来就很牛逼的名字，想了半天也没想到什么好的题目，然后突然想起来高中时代非常喜欢的一句话：“无论你解不解我的风情，无论我解不解你的衣扣，在此刻，我是如此地想念你，不带们。” 那就用韩寒这本书的名字当题目吧。</p><h2 id="像少年啦飞驰"><a href="#像少年啦飞驰" class="headerlink" title="像少年啦飞驰"></a>像少年啦飞驰</h2><h3 id="在被锤的年龄"><a href="#在被锤的年龄" class="headerlink" title="在被锤的年龄"></a>在被锤的年龄</h3><blockquote><p>那一年我二十一岁，在我一生的黄金时代，我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云，后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消逝，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。 –《黄金时代》</p></blockquote><p><img src="https://libx-1253438335.cos.ap-chengdu.myqcloud.com/pics/thread_133183324137598_20190613165645_s_59340_w_930_h_511_6838.jpg" alt=""></p><p>和王小波在黄金时代里写的一样，我也觉得没有人能锤得了我，甚至在同班漂亮女生面前的时候我觉得能锤任何人。可是在小学时代被老师和家长锤过之后这种感觉就消失了，更不幸的是我还遇不到像陈清扬一样的女子来培养一下革命友谊。</p><p>总的来说，自我感觉19年是被锤的一年。</p><p>上半年除了偶尔回学校考考试，摸摸鱼，基本都还是在公司度过。每天算是两点一线的生活，公司-&gt; 住处，住处-&gt;公司。在每个工作日的10点、11点回到住的地方，开启自闭模式，打游戏或者看书玩手机到一两点睡觉。第二天10点起床去上班，刷牙洗脸洗头发然后一路狂蹬自行车到公司，刚洗的头发总是会被风吹的异常飘逸，恨不得让我长到和姚明一样高。总是会在办公区门口碰到隔壁精致的运营小姐姐们从茶水间端着咖啡出来准备开始一天的工作，就像是善良可爱的地球人遇到了UFO，而我刚从飞碟上下来。</p><p>这种生活大概持续了半年，生活虽然像是一团乱麻，但是工作方面，每天写需求+学习，每一件事情都抱着学习的心态去做，主要是在跟着一位非常优秀的同学（其实是前辈）一块做事情，还是非常开心的。自己也在努力从单纯的写代码到会去关注设计关注产品，并且去尝试读了一些关于产品和设计运营的一些书。收获颇丰；当然这些其实在写大三总结的时候已经提过了，这里就不再特别写了。</p><p>在这个部门还是挺开心的，所以和leader提了转正，沟通之后去申请了转正答辩，过程还算顺利，答辩之后就确定可以转正了。</p><p>确认了可以在字节转正之后，秋招也差不多开始了。所谓“饱暖思淫欲”，自己就想出去看看，看看业界其他大厂面试是什么体验，于是就找学长内推了一波阿里淘系前端岗位，然后就又开始了一段被锤的旅程。</p><p>和前两面的面试官聊的都还不错，一面侧重知识面广度，聊到的知识点挺多的，万幸学到的东西都还有印象；二面聊了很多项目方面的；三面就很让人郁闷了，上来开始跟我谈理想谈规划，于是就跟他吹了前端的一些自我修养，接着就开始跟我聊产品聊团队管理聊对技术的敏感度，在云里雾里的一番交流之后他告诉我“嗯好的，之后有消息会联系你”。然后就把我扔到了池子里排队，在一个月之后告诉我挂了。当时感觉非常的郁闷，感觉挂的稀里糊涂的，后来想了想，也不冤。</p><p>按照劣质电视剧或者小说的情节发展，我应该通过不懈努力然后斩获阿里offer，并慢慢走上人生巅峰。可当你有美好憧憬的时候，生活就变成了文艺片。</p><p>生活嘛，就是要不断的被锤。</p><p>在确认阿里被挂了之后，想了一下，既然不能跟马老师学吹牛逼，那就去看看能不能跟东哥做兄弟吧。于是就找了个跟手淘类似的部门：京东🐵。但是看到京东的校招投递时间已经过了，于是直接给凹凸实验室发了封邮件吹了一波凹凸也吹了波自己，然后就开始了凹凸的面试之旅。但是凹凸的效率有点慢，在他们联系我二面的时候我已经结束了假期回到了字节（顺便说一下，这里的假期其实指的是呆在学校给自己放假的时间😂）。联系我二面的师兄说没关系之后还可以联系，师兄人真的不错。</p><div div="" align="center"><img src="https://libx-1253438335.cos.ap-chengdu.myqcloud.com/pics/007uilLnly1g4i64hlhcjj30fy0g0dhv.jpg" width="300"></div><p>看了看外面的世界，之后最终还是回到了头条，还是在字节继续务实的浪漫主义吧。现在想想，人们会埋怨一成不变，但也会埋怨居无定所，其实都无所谓，只是要给日子找点岔子而已，似乎只有违背现在的生活，才真正懂得了生活。</p><h3 id="尝试好好生活"><a href="#尝试好好生活" class="headerlink" title="尝试好好生活"></a>尝试好好生活</h3><blockquote><p>生活就是一个婊子、一个戏子、一个你能想到的一切，你所有的比喻就往里面扔吧，你总是对的。</p></blockquote><p>在没有真正一个人生活过的时候觉得自己很懂生活，以为不管多有趣的生活最终都会归于平淡，似乎自己已饱经沧桑，看透了这世间的所有冷暖。事实并不出乎人意料，我很快就意识到自己并不懂生活，并且似乎已经跳过了有趣的阶段，当然我更倾向于是自己还没找到有趣的阶段。</p><p>有一个场景让我印象深刻，大概是春天的某个周末，因为窗外可以看到柳树长的非常好，不像南昌这个地方，北京的四季还是很有特点的。在那个生命力旺盛得甚至要从窗外涌进我卧室的下午，我靠着窗在英雄联盟峡谷里厮杀得暗无天日。在一把游戏结束准备开下一把的时候我往窗外看了下，看到下面球场有好多人在打球，也有很多人带着小孩在球场旁边草地玩，突然感觉到无法言状的孤独和悲伤。我一度以为自己是种子，被风吹来吹去，但是我终于意识到，我不是种子，我就是连着根的植物，至于我是一棵什么样的植物，我看不到我自己，那得问其他的植物。</p><p>打游戏终究是劳神费力没收获，当然也可以说有一点收获，就是简单粗暴的爽。虽然并不是说任何事情都要带着目的去做，但把大把的时间花在游戏上确实不太值得。有一天突然想起来自己之前也是有读书的习惯的，但是在开始写代码之后就不怎么读跟技术无关的书了。于是幡然醒悟，买了好多书来读，所幸的是，我发现我还是读的进去书的。于是在每天下班之后也没有那么自闭了，多读读书总归是好的。有句话叫“矫情是因为书读的太少而想的太多”，确实。但是突然又想到了另外一句话：“你觉得矫情是因为主角不是你”。算了算了，都行。</p><p>晚上下班回到住的地方之后，躺在沙发上看看书，还是挺惬意的。把主要的休闲项目从打游戏换成读书，一年下来，算了算也还是读了一些书的。</p><p>大概有这些：</p><div div="" align="center"><img src="https://libx-1253438335.cos.ap-chengdu.myqcloud.com/pics/mubu.com_list(iPhone%206_7_8)%20(1).png" width="400"></div><p>当然这些都是非技术的书，技术类的也没记录，就不列了。</p><p>虽然在很多时候还是会觉得内心的孤独，并且时不时会陷入小小的焦虑，但是生活嘛，。</p><p>2019年算是一篇故事，这个故事平淡无奇，平铺直述，既没有曲折，也没有高潮。就如同走在路上看见一盏红绿灯一样稀松平常，但若驻足，你会发现，它永远闪着黄灯。我就一直看着这盏信号灯，在灯下等了很久，始终不知道黄灯结束以后将要亮起的是红色还是绿色，一直等成了一个红绿色盲。</p><h3 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h3><p>大概在前一段时间，在加班到12点然后打车回到住处的时候，突然想到了一个问题：“如果突然有一天自己对技术完全失去了热情，并且一点都不想做互联网相关的工作的话，自己要去做什么？”</p><p>然后那个晚上我就失眠了。</p><p>其实一直以来都有做一定的职业规划，但是到头来也没有离开技术，没有离开互联网。如果说真的有一天我对做技术厌恶到想吐，我不知道自己能做什么。</p><p>于是我去问了一个非常优秀并且人又非常nice的北大本硕学姐，我问她如果她有一天对运营完全失去了热情，会去做什么。学姐很诧异，说为啥大半夜的要讨论这么严肃的话题，然后学姐又说，“到时候可能存了一些钱了吧，可以去创业了？可能会去开一个火锅店？哈哈哈哈”。</p><p>然后我又想了一下，这似乎是一个非常虚无并且扯淡的问题。</p><p>但是我还是没有放弃思考这个问题，于是我去和玉杰也就是我现在的mentor聊了聊。在我说出我最近的困惑之后，玉杰直接说了这样一句话：‘你觉得我想写代码吗？’，之后大概是这么回答我的，“你看公司里现在做技术的有这么多人，做技术超过3年5年的不在少数，你觉得他们有多少是依然保持着当初对技术的热情的呢？我觉得不多。对技术感兴趣并且能够作为自己的工作已经非常幸运了，你的其他专业的同学都不一定能从事本专业的工作。当兴趣变成了工作，除了少数人，慢慢得都会厌烦。但是你要承担起你需要承担的责任。”</p><p>那次大概跟玉杰聊了一个多小时，自己心里大概有了答案。</p><p>就像之前说的，这个问题确实很扯淡，并且矫情。如果要虚无飘渺的回答那会有很多答案，但是踏踏实实的踩在地上，答案就很简单：“如果有了家庭，有了妻子和孩子，那就承担起你的责任，把这些问题当成小学时考虑上北大还是上清华一样处理就好；如果还是一个人（那我好惨啊），那似乎可以去追求一下这些虚无缥缈的东西，比如自由啊什么的。”</p><p>现在想想我提出这个问题并且想要去得到一个答案的原因其实在于，这么多年来，一直是我脚下的流沙裹着我，决定着我要往哪走，它也不淹没我，它只是时不时提醒我，你没有别的选择，否则你就被风吹走了。我就这么浑浑噩噩地度过了我所有热血的岁月，被裹到东，被裹到西。可能我内心深处是有一个其他答案的吧。我也不知道。</p><h2 id="不如我们重新来过"><a href="#不如我们重新来过" class="headerlink" title="不如我们重新来过"></a>不如我们重新来过</h2><p>2020，不如我们重新来过，算是对自己说的吧。2019年还是有着诸多遗憾和不甘，但最终它们会像2018年或者2017年的遗憾不甘一样，消失在记忆里，无意或者有意的去忘记。</p><p>2019年其实并没有立什么Flag，因为我确实也不是一个喜欢立Flag的人。如果非要说立了什么flag，那就是幻想自己能够练出来几块腹肌吧🐶。还是不要立flag比较好。</p><p>2020，这个数字让人很喜欢，要做的事情心里大概也有了一些规划，这篇总结为主，就不怎么展望了，希望一切都好。</p><p>在我年少时曾经幻想过无数次这样的旅行，夜晚的国道里，我带着自己梦寐以求的女子，开着自己梦寐以求的车，去往未知旅程的终点。未知旅程怎么会有终点。旅途上没有疲劳和困意，我们聊着电影和音乐，穿越群山和丛林，最终停在一泓无人的湖水旁边，有一个没有任何经济头脑的人开的酒店，干净便宜。</p><p>但是估计没戏了，还是找🐳老田去青海湖熄灭爱情吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;照常该写一下今年的总结了，想要尝试想一个听起来就很牛逼的名字，想了半天也没想到什么好的题目，然后突然想起来高中时代非常喜欢的一句话：“无论你解不解我的风情，无论我解不解你的衣扣，在此刻，我是如此地想念你，不带们。” 那就用韩寒这本书的名字当题目吧。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Puppeteer优化实录</title>
    <link href="http://stan1812.github.io/2019/12/12/puppeteer/"/>
    <id>http://stan1812.github.io/2019/12/12/puppeteer/</id>
    <published>2019-12-12T09:36:35.000Z</published>
    <updated>2020-03-03T08:52:42.419Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写关于Puppeteer的服务，其中一些思路大概梳理一下。</p><h2 id="截图服务的大致流程"><a href="#截图服务的大致流程" class="headerlink" title="截图服务的大致流程"></a>截图服务的大致流程</h2><ol><li>Puppeteer打开Browser，准备好对应的Tab。</li><li>调用Puppeteer服务，Puppeteer处理来源的原始HTML或者跳转到相应的页面</li><li>截图</li><li>把结果返回，如果中间有错误，把错误返回。</li><li>关闭这个Tab。</li><li>关闭这个Browser。</li></ol><p>看起来流程非常的简洁美好，启动一个简单的Node服务，我们就可以按照这6个步骤完成开发，但是现实其实并不是这么美好：</p><ol><li>频繁的开关browser和tab，效率很低。</li><li>Puppeteer异常一次后，browser就不受控制，无法关闭，导致内存泄露，QPS高时，内存暴涨，QPS低时，内存不释放。</li><li>在Page中evaluate脚本的时候，线上极度难以调试，调试需要case by case，上线后JS报错很难追踪和复现。</li><li>Puppeteer自身很慢，并发非常低，处理任务一秒一个都做不到。</li><li>截图服务中间的流程均是低效率流程，其中更是包含了上传tos的操作，非常耗时</li></ol><p>在使用最原始的方式，不包含任何调度的时候：截取本地模版 接口调用平均时延大概在1.2s左右（本地测试）（由于截取线上网站很大程度取决于线上网页的加载速度，对服务来说不可控，所以暂时不讨论线上地址截图）</p><p>下面就要开始我们的一些优化了：</p><h2 id="连接池设计"><a href="#连接池设计" class="headerlink" title="连接池设计"></a>连接池设计</h2><h3 id="生产Page资源"><a href="#生产Page资源" class="headerlink" title="生产Page资源"></a>生产Page资源</h3><p>连接到一个页面大概有以下几种方法：</p><ol><li>一个请求-&gt;打开一个浏览器-&gt;打开页面-&gt;截图-&gt;关闭页面-&gt;关闭浏览器<ol><li>这当然是最简单的方法，如果可以接受长达几秒的响应时间，那其实这也是最可靠的，不会有任何crash、内存泄漏、浏览器崩溃之类的风险。但这显然得不偿失。</li></ol></li><li>一个浏览器 =&gt; 对应多个tab<ol><li>复用tab，但一个浏览器的crash风险较高。</li></ol></li><li>多个浏览器 =&gt; 每个浏览器都对应多个tab<ol><li>不需要每次请求都进行打开浏览器、打开页面的操作，响应时间大幅缩短</li><li>相对规避了浏览器崩溃之后app完全不可用的风险</li></ol></li></ol><p>按照上面的思路，Puppeteer自身非常慢，所以考虑把一些比较耗时的操作尽可能在每次请求前置进行，目前可以前置做的事情有：</p><ol><li>启动浏览器</li><li>启动多个tab</li></ol><p>先按照这个思路实现一个可用版本：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">async</span>  createAll() &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.browserMax; i++) &#123;</div><div class="line">    <span class="keyword">let</span> browser = <span class="keyword">await</span> <span class="keyword">this</span>.createBrowser();</div><div class="line">    <span class="keyword">this</span>.browsers[i] = &#123; browser, <span class="attr">pages</span>: [] &#125;;</div><div class="line">    <span class="keyword">let</span> [defaultPage] = <span class="keyword">await</span> browser.pages();</div><div class="line">    defaultPage = <span class="keyword">await</span> <span class="keyword">this</span>.setPage(defaultPage);</div><div class="line">    <span class="keyword">this</span>.browsers[i].pages[<span class="number">0</span>] = &#123;</div><div class="line">      page: defaultPage,</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; <span class="keyword">this</span>.pageMax; k++) &#123;</div><div class="line">      <span class="keyword">let</span> page = <span class="keyword">await</span> <span class="keyword">this</span>.createPage(browser);</div><div class="line">      <span class="keyword">this</span>.browsers[i].pages[k] = &#123;</div><div class="line">        page</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.browsers;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>按照这个数据结构，每个browser对应了多个page</p><p>看起来已经是一个可用版本了，但是还有一些细节：</p><ol><li>在启动Browser的时候，只需要启动启动一个最小化可用的浏览器实例，不需要的功能都禁用掉，具体的实践之后：<ol><li>部分功能disable掉，比如GPU、Sandbox、插件等，减少内存的使用和相关计算。</li></ol></li></ol><p>在启动参数优化之后，应用启动速度大概提升200ms，收益非常可观。</p><h3 id="连接Page资源"><a href="#连接Page资源" class="headerlink" title="连接Page资源"></a>连接Page资源</h3><p>可用的page生产完了，接下来需要思考如何高效的拿到可用的page：<br>获取产生的page，需要有一定的调度，这里用到的规则是：</p><ol><li>先找到一个空闲的page单位，然后给这个page单位加锁，</li><li>使用次数累加</li><li>返回可用page，执行使用</li><li>使用完之后归还page给资源池，如果使用次数超过5次，就关闭这个page（这里也是为了降低page崩溃的几率）创建新的page实例，补上这个page单位。</li><li>最后解锁page。</li></ol><p>在分配page的时候也进行了一定的设计：也比较简单，首先从我们存储的browsers对象中进行查找，找到下面没有被used的page，判断是否有异常被关闭了，如果异常被关闭了，我们需要重新建立补上，然后使用次数归0，最后我们这个选中的page的存储排序挪到数组最后，让其他的没有被used的page能在下次更快被拿到。<br>获取page的时候还会遇到一个问题就是资源不够用了。目前在项目中每个请求会给10s的等待调度时间，如果5s之后依然没有可用page，返回超时 （后续可以根据机器的内存情况来动态增加浏览器和page池）。2C4G的机器大概可以支撑的qps待测试（需要注意在机器内存占用80%以上的时候是不太安全的，内存空间需要留足够的buffer）</p><h3 id="Page的维护"><a href="#Page的维护" class="headerlink" title="Page的维护"></a>Page的维护</h3><p>实际测试之后发现使用tab方式渲染后请求速度提升了200ms左右，带来的收益也非常可观。不过这里要注意，官方并不建议这样做，因为一个tab页阻塞或者内存泄露会导致整个浏览器阻塞并Crash。但是我们为了追求速度，只能在可控的情况尽可能的实现复用，虽然我们用了多个浏览器来规避服务完全不可用的情况，但万全的解决办法是定期重启程序。</p><h4 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h4><p>重启很简单，把所有浏览器关了就行了，但是需要注意的是当页面在使用的时候我们把它给关了那就GG了，所以需要加一步检查页面是否在用：this.browsers[i].pages[k].used  如果在使用就sleep1s之后再来检查。在执行关闭前是先生产一组新的browser list，把旧的替换，然后去关旧的。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>目前的重启调度逻辑其实和Node的内存回收中所用到的新生代垃圾回收算法非常像：新生代中的对象主要通过Scavenge算法进行垃圾回收，这是一种采用复制的方式实现内存回收的算法。Scavenge算法将新生代的总空间一分为二，只使用其中一个，另一个处于闲置，等待垃圾回收时使用。在进行浏览器重启的时候其实会造成一定的空间浪费；</p><h2 id="一些思路"><a href="#一些思路" class="headerlink" title="一些思路"></a>一些思路</h2><ol><li><p>存在部分同样的图片，可根据请求参数生成hash 当作key放到redis，当下次有相同的请求时直接返回redis里存的图片。并且如果两次page的内容是完全一致的话，截图来的ImageArray也会是完全相同的，这其实也不难理解。</p></li><li><p>既然要把耗时的操作前置，那其实可以直接把模版内容提前set到page里，请求来的时候只需要渲染数据。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在写关于Puppeteer的服务，其中一些思路大概梳理一下。&lt;/p&gt;
&lt;h2 id=&quot;截图服务的大致流程&quot;&gt;&lt;a href=&quot;#截图服务的大致流程&quot; class=&quot;headerlink&quot; title=&quot;截图服务的大致流程&quot;&gt;&lt;/a&gt;截图服务的大致流程&lt;/h2&gt;&lt;ol&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>直播技术初探</title>
    <link href="http://stan1812.github.io/2019/10/06/video-tech/"/>
    <id>http://stan1812.github.io/2019/10/06/video-tech/</id>
    <published>2019-10-06T13:00:48.000Z</published>
    <updated>2020-03-03T08:52:42.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当说起音频和视频，作为一个前端开发者可能最先想到的是<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>，但具体都用了什么技术呢？最近突然想起来这个问题，于是去翻了一些文档和博客，现在来做一个总结</p><p>先来谈谈视频</p><p>首先从我们的日常生活来看一下表象，我们目前所看的视频视频分为两种，<strong>直播</strong>和<strong>录播</strong>。 这个大家实际都接触过，比如用直播看比赛什么的，比赛结束你去看回放那就是录播了，看电影/短视频也是一样的道理。录播可以通过下载完整个视频后再看，或者通过流媒体边下边看。看直播只能通过流媒体看最新的画面。</p><h3 id="直播"><a href="#直播" class="headerlink" title="直播"></a>直播</h3><p><img src="https://user-gold-cdn.xitu.io/2018/3/26/162600253848d22c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>具体在实践中的流程，以腾讯云直播为例：<br><img src="https://user-gold-cdn.xitu.io/2018/3/26/162601f0836f2cb7?imageslim" alt=""></p><p>先来谈谈在直播中常用的几种协议:</p><ul><li>RTMP: 底层基于TCP，在浏览器端依赖Flash。</li><li>HTTP-FLV: 基于HTTP流式IO传输FLV，依赖浏览器支持播放FLV。</li><li>WebSocket-FLV: 基于WebSocket传输FLV，依赖浏览器支持播放FLV。WebSocket建立在HTTP之上，建立WebSocket连接前还要先建立HTTP连接。</li><li>HLS: Http Live Streaming，苹果提出基于HTTP的流媒体传输协议。HTML5可以直接打开播放。<br>RTP: 基于UDP，延迟1秒，浏览器不支持。</li></ul><h4 id="HLS协议"><a href="#HLS协议" class="headerlink" title="HLS协议"></a>HLS协议</h4><p><strong>HLS</strong>(Http Live Streaming)，是由苹果提出基于HTTP的流媒体传输协议。HLS包括来一个m3u(8)的索引文件、TS媒体分片文件和key加密串文件。HLS有一个非常大的优点：HTML5可以直接打开播放；这个意味着可以把一个直播链接通过微信等转发分享，不需要安装任何独立的APP，有浏览器即可，所以流行度很高。社交直播，HLS可以说是刚需 。HLS 主要是一个 m3u8 的文件，每个文件都是一些 ts 小片段组合在一起。具体文档<a href="https://developer.apple.com/streaming/" target="_blank" rel="external">在此</a></p><p>这里就出现了一个名词：<strong>m3u8</strong>  </p><p>先从M3U说起，M3U是一种播放多媒体列表的文件格式，它的设计初衷是为了播放音频文件，比如MP3，但是越来越多的软件现在用来播放视频文件列表。很多播放器和软件都支持M3U文件格式。M3U8是用UTF-8编码的M3U，。<code>M3U</code>和<code>M3U8</code>文件都是HLS的基础，简而言之，M3U8就是一个播放列表。</p><p>我这里也找了一个m3u8的文件来测试，<code>https://iptv-org.github.io/iptv/channels/cn.m3u</code>文件的内容格式是这样的：</p><h5 id="主索引文件"><a href="#主索引文件" class="headerlink" title="主索引文件"></a>主索引文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">EXTM3U  每个M3U文件第一行必须是这个tag，起标示作用</span></div><div class="line"><span class="meta">#</span><span class="bash">EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=409037,RESOLUTION=416x234,CODECS=<span class="string">"mp4a.40.2, avc1.42001e"</span></span></div><div class="line">Gear1/prog_index.m3u8</div></pre></td></tr></table></figure><p><code>#EXT-X-STREAM-INF</code>标签的属性列表中直接指明当前流是VIDEO还是AUDIO<br>包含属性 :</p><ul><li>BANDWIDTH 指定码率</li><li>PROGRAM-ID 唯一ID</li><li>CODECS 指定流的编码类型</li><li>RESOLUTION：分辨率<h5 id="子索引文件"><a href="#子索引文件" class="headerlink" title="子索引文件"></a>子索引文件</h5><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line"><span class="selector-id">#EXTM3U</span>                     m3u文件头，必须放在第一行</div><div class="line"><span class="selector-id">#EXT-X-MEDIA-SEQUENCE</span>       第一个TS分片的序列号</div><div class="line"><span class="selector-id">#EXT-X-TARGETDURATION</span>       每个分片TS的最大的时长</div><div class="line"><span class="selector-id">#EXT-X-ALLOW-CACHE</span>          是否允许cache</div><div class="line"><span class="selector-id">#EXT-X-ENDLIST</span>              m3u8文件结束符</div><div class="line"><span class="selector-id">#EXTINF</span>                     extra info，分片TS的信息，如时长，带宽等</div><div class="line">#EXTM3U</div><div class="line"><span class="selector-id">#EXT-X-TARGETDURATION</span>:<span class="number">11</span><span class="selector-id">#EXT-X-VERSION</span>:<span class="number">3</span><span class="selector-id">#EXT-X-MEDIA-SEQUENCE</span>:<span class="number">0</span><span class="selector-id">#EXT-X-PLAYLIST-TYPE</span>:VOD</div><div class="line"><span class="selector-id">#EXTINF</span>:<span class="number">10.133333</span>,</div><div class="line">fileSequence0.ts</div><div class="line">xxx</div><div class="line">#EXT-X-ENDLIST</div></pre></td></tr></table></figure></li></ul><p>主索引文件与子索引文件的区别：</p><ul><li>主索引文件和子索引文件都是.M3U8的playlist</li><li>主索引文件只需下载一次，但对于直播节目子索引文件定期重新加载</li></ul><p><strong>ts 文件</strong>，就是存放视频的文件：每一个 .m3u8 文件，分别对应若干个 ts 文件，这些 ts 文件才是真正存放视频的数据，m3u8 文件只是存放了一些 ts 文件的配置信息和相关路径</p><p>HLS只请求基本的HTTP报文，与实时传输协议（RTP)不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。</p><p>大致流程：<br><img src="https://user-gold-cdn.xitu.io/2018/3/26/1626023bd565d932?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h4 id="RTMP-协议"><a href="#RTMP-协议" class="headerlink" title="RTMP 协议"></a>RTMP 协议</h4><p><a href="https://chenlichao.gitbooks.io/rtmp-zh_cn/content/" target="_blank" rel="external">文档</a></p><p>RTMP（Real Time Messaghing Protocal）协议，是由Adobe为Flash推出的音视频和数据传输开发的协议，基于TCP。首先、强依赖于Flash在更早的一段时间还是非常好的特性,web平台基本都会支持Flash,这给开发者带来了非常多的便利.但是目前Flash在被抛弃的边缘,所以就会出现比较尴尬的局面.</p><p>协议中的基本数据单元为消息（Message），传输的过程中消息会被拆分为更小的消息块（Chunk）单元。最后将分割后的消息块通过 TCP 协议传输，接收端再反解接收的消息块恢复成流媒体数据。</p><p>RTMP 主要有以下几个优点：RTMP 是专为流媒体开发的协议，对底层的优化比其它协议更加优秀，同时它 Adobe Flash 支持好，基本上所有的编码器（摄像头之类）都支持 RTMP 输出。</p><p>但是目前来讲一方面是它是基于 TCP 传输，非公共端口，可能会被防火墙阻拦；另一方面，也是比较坑的一方面是 RTMP 为 Adobe 私有协议，很多设备无法播放，特别是在 iOS 端，需要使用第三方解码器才能播放。</p><h4 id="HTTP-FLV"><a href="#HTTP-FLV" class="headerlink" title="HTTP-FLV"></a>HTTP-FLV</h4><p><strong>HTTP-FLV</strong>: 基于<code>HTTP</code>流式IO传输FLV，依赖浏览器支持播放FLV。其结合了 RTMP 的低延时，并且可以复用现有 HTTP 分发资源的流式协议。将音视频数据封装成FLV，然后通过HTTP协议传输给客户端。</p><h4 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h4><p>部分浏览器直接支持,目前存在的架构是在推流端将视频推向Server的阶段使用WebRTC.而在服务器分发直播视频时,依然使用RTMP、FLV等传统方案进行处理.</p><h4 id="常见直播协议延迟与性能数据以下数据只做对比参考-数据来源于-https-github-com-gwuhaolin-blog-edit-master-source-posts-使用flv-js做直播-md"><a href="#常见直播协议延迟与性能数据以下数据只做对比参考-数据来源于-https-github-com-gwuhaolin-blog-edit-master-source-posts-使用flv-js做直播-md" class="headerlink" title="常见直播协议延迟与性能数据以下数据只做对比参考,数据来源于(https://github.com/gwuhaolin/blog/edit/master/source/_posts/使用flv.js做直播.md)"></a>常见直播协议延迟与性能数据<sub><sup>以下数据只做对比参考,数据来源于(<a href="https://github.com/gwuhaolin/blog/edit/master/source/_posts/使用flv.js做直播.md" target="_blank" rel="external">https://github.com/gwuhaolin/blog/edit/master/source/_posts/使用flv.js做直播.md</a>)</sup></sub></h4><table><thead><tr><th>传输协议</th><th>播放器</th><th>延迟</th><th>内存</th><th>CPU</th></tr></thead><tbody><tr><td>RTMP</td><td>Flash</td><td>1s</td><td>430M</td><td>11%</td></tr><tr><td>HTTP-FLV</td><td>Video</td><td>1s</td><td>310M</td><td>4.4%</td></tr><tr><td>HLS</td><td>Video</td><td>20s</td><td>205M</td><td>3%</td></tr></tbody></table><h3 id="流媒体加密"><a href="#流媒体加密" class="headerlink" title="流媒体加密"></a>流媒体加密</h3><p>为什么要加密视频？</p><p>付费观看视频的模式是很多平台的核心业务，因此对视频服务进行加密的技术变得尤为重要。<br>两种加密方式：<br><strong>防盗链</strong>：通过验证的用户才能访问到没有加密的视频内容，但视频很容易就被下载的风险，严格来说这不属于加密。本质是资源访问授权。<br><strong>加密视频本身</strong>：通过对称加密算法加密视频内容本身，用户获得加密后的视频内容，通过验证的用户可以获取解密视频的密钥，在客户端解密后播放。这种方式实现起来流程复杂，带来更多的计算量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当说起音频和视频，作为一个前端开发者可能最先想到的是&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;audio&amp;g
      
    
    </summary>
    
    
      <category term="-技术" scheme="http://stan1812.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>大三一年</title>
    <link href="http://stan1812.github.io/2019/06/30/Junior/"/>
    <id>http://stan1812.github.io/2019/06/30/Junior/</id>
    <published>2019-06-30T09:03:29.000Z</published>
    <updated>2020-03-03T08:52:42.364Z</updated>
    
    <content type="html"><![CDATA[<p>时间过的很快，大三又结束了。回想上次大二结束仿佛就在一年前（狗头</p><p>只有在学校的时候才会觉得自己还是一个学生。在外面实习时不时会有一种身份缺失的感觉，感觉自己在逐渐脱离学生的角色，但又没有完全脱离。终于又在学校呆了一个月，感受到了在公司时候就期待已久的悠闲大学生活，熟悉并且舒适。期末考试考完了之后又回到了公司，感叹自己的大三就已经结束了，这是学生生涯最后一个暑假。</p><p>坐在这里想要回顾大三上学期都做了什么竟然都回想不起来，这说明我大三上压根没有做什么有意思的事情。或者做了什么有意思的事情但最终也如过眼云烟，消失在记忆中，无处寻觅。对于个人而言，遗忘是可怕的。</p><p>但总还是有些值得回忆的事情</p><h2 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h2><p>开始决定出去实习大概是大二暑假决定的事情，大三上的时候梳理了自己的技术栈和做过的项目，在大概十一月份的时候开始了找实习之旅。因为确实没有啥经验，开始找实习的时间点比较尴尬，只能找找日常实习了。找了几个家园的学长大概了解了下他们找实习时候的经历，然后跟他们交流了一波。当时也算是抱着碰运气的想法，写了下简历，就开始在实习僧上面海投了一波简历，各种公司都投递了简历，年轻人的第一次求职就开始了。但是就比较尴尬，最终只收到了几家公司的面试要求，当然，这是后话了。</p><p>算起来，第一次正式求职的面试是微博的。回想起来面试前的时候真是贼紧张，还好一面的老哥还是挺8错的，问的问题也算是中规中矩，大多是基本知识，不过具体问了什么东西我现在也确实想不起来了，印象中没有特别难的，然后聊了聊项目，就告诉我让我先休息会等下可能二面。二面应该是一面的leader吧，估计因为面试官想着是大三上的学生预期没那么高，所以问的比较简单吧。然后二面结束后就告诉我后续会有HR联系我。第二天早上就收到了HR的电话，简单的聊了聊，最后口头给了Offer。</p><p>当时还是挺想去微博的，毕竟是第一家面试成功的公司，然后自己平时也会用微博，（虽然对微博的产品经理好感度不怎么高🐶当时一直觉得微博的PM没有一点理想）</p><p>然后在纠结要不要去微博的时候收到了字节的面试邀请的邮件，当时在自己招聘官网投了简历，但过了好久也没有反馈，觉得自己已经凉了，然后又在实习僧投了一波，很幸运被捞了起来，然后就开始了头条的面试之旅。</p><p>头条的面试难度是众所周知的，以至于我在一面面的过程中就觉得自己要凉了，当时就感觉问的知识点特别细，一直往下问，问到你模棱两可，当时也确实感觉自己为什么这么菜。不过万万没想到一面过了，，然后就是二面三面HR面。然后就过了🐶🐶🐶。头条面试效率真的特别高，面试体验极佳。</p><p>然后我就来到了头条。</p><h2 id="Change"><a href="#Change" class="headerlink" title="Change"></a>Change</h2><p>决定来字节也做了一些抉择。自己对公司的选择一方面自己肯定得觉得这家公司很厉害，然后就是希望公司做的是一些有意义的事情，是在改变这个社会，让世界更美好。字节跳动也在积极的做这些，在开始慢慢的承担起大公司应承担的社会责任。然后正好运气不错就进去了。</p><p>和去了西瓜的🐳，买了一起去北京的票，考完期末考试，拖着行李就踏上了北京之旅，在车上一直在听英雄联盟当时出的新CG主题曲Awaken 和Imagine Dragons的Warriors，听的自己突然有种使命感，内心充满了对探索未知的渴望，又带着一点小紧张，想起来还真是挺有意思的。</p><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>入职后认识新同事，熟悉流程之后很快就开始了开发，但是在工作室做项目时候保留的一些不好的习惯带来了一些case，不过还好有mentor和其他同学的帮助，技术方面当然会有成长，但是目前来看，对自己来说可能更重要一些的算是是在一些“软实力”方面的的提升吧，包括对流程的关注，面对问题的处理方式，如何有效的沟通，等等。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="平衡"><a href="#平衡" class="headerlink" title="平衡"></a>平衡</h4><p>自己算是一个比较喜欢平衡状态的人。在实习的时候，面对着很多矛盾，也感觉到自己在慢慢的失去很多平衡。工作和生活，自身的成长和较为繁重的业务之间的矛盾。跟学长还有leader也有交流这些问题，寻求他们的经验，自己也一直在<br>慢慢的思考和消化。实际上来说，应该很多人会面临这些问题。</p><h5 id="工作和生活"><a href="#工作和生活" class="headerlink" title="工作和生活"></a>工作和生活</h5><p>有一次跟leader交流的时候，leader问我觉得来北京之后遇到的最大的难题是啥，我说感觉生活的孤独和无趣是遇到最大的难题，感觉自己一个人真是太无趣了。leader说的话让我印象深刻，他说很多时候不是这个世界无趣，这个世界非常有趣，只是你自己不愿意或者说没能力去找到乐趣，比如说你看到其他人天南地北旅游，去潜水冲浪，可是你却连游泳都不会。你看别人每天健身晒健身照，你觉得别人好充实，你却动都不想动。之前确实没有从这个角度想过这个问题，总觉得丰富多彩的生活是大部分由环境决定的，比如你住到一个风景很好的地方，有山有水有树林，傍晚泛舟湖上，当然这是很难达到的外部条件，不知道能有多少人能拥有这种条件。事实上，如果你是个无比宅的人，可能就算你住到很舒服的环境，在过了一段时间腻味了之后，自己还是每天宅在家里。丰富多彩是自己决定的，或许生活状态从某个角度上是自身内心状态的一个反映。</p><p>leader一直跟我说不要给自己设太多的边界，要去积极的探索新事物，不管是技术上还是生活上，兴趣不是天生的，要去尝试培养兴趣。成长是自己的事情，google也有一句话说你是你自己的职业经理人，这句话的重点在“你”和’你自己‘。慢慢来，给自己一点时间。</p><h3 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h3><h4 id="学到了什么"><a href="#学到了什么" class="headerlink" title="学到了什么"></a>学到了什么</h4><ul><li>自身学习<ul><li>对问题边界的理解更清晰</li><li>沟通效率提升</li><li>学会合理排期</li><li>能独自owner完整项目，进行跨部门的协调合作</li><li>对于各种技术以及工具的场景有更深的理解</li><li>关注流程，人不是机器一定会犯错，但严格而规范的流程可以有效的减少犯错</li></ul></li><li>思考<ul><li>要更加客观、更加包容的看待问题</li><li>多读书</li></ul></li></ul><h4 id="之后应该做的"><a href="#之后应该做的" class="headerlink" title="之后应该做的"></a>之后应该做的</h4><ul><li>业务方面<ul><li>能独立 owner 中型项目，从前期技术方案设计、产品需求讨论到后期维护</li><li>能快速定位问题，对数据更敏感</li><li>提升业务敏感程度，对需求有判断力</li></ul></li><li>技术方面<ul><li>扩展技术视野，做技术工具提高团队效率</li><li>多读源码，提升代码质量</li><li>多做技术分享，更积极地和其他同学沟通技术</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时间过的很快，大三又结束了。回想上次大二结束仿佛就在一年前（狗头&lt;/p&gt;
&lt;p&gt;只有在学校的时候才会觉得自己还是一个学生。在外面实习时不时会有一种身份缺失的感觉，感觉自己在逐渐脱离学生的角色，但又没有完全脱离。终于又在学校呆了一个月，感受到了在公司时候就期待已久的悠闲大学生
      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
  </entry>
  
  <entry>
    <title>回校见闻录</title>
    <link href="http://stan1812.github.io/2019/06/09/backschool/"/>
    <id>http://stan1812.github.io/2019/06/09/backschool/</id>
    <published>2019-06-09T09:44:14.000Z</published>
    <updated>2020-03-03T08:52:42.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="回校见闻"><a href="#回校见闻" class="headerlink" title="回校见闻"></a>回校见闻</h2><p>现在是在端午节回学校的高铁上，车外还是熟悉的景色，大片大片已经收割过的麦田。从小语文老师和父母就告诉我，现在是收获的季节。正好在车上没什么事情，又正好带了电脑，所以决定来写点东西。</p><p>经过在外面的实习之后，终于在5月底回到了学校。现在已经是大四的离校季了，昨天高考也已经结束，这也宣告着我的大三下学期即将过去，快要大四了。</p><h2 id="毕业照🎓"><a href="#毕业照🎓" class="headerlink" title="毕业照🎓"></a>毕业照🎓</h2><p>在大一的时候看到当时拍毕业照的学长学姐时，只是为他们感到高兴，终于要结束大学生活，真正作为一个独立的个体踏入社会了。很多人说大学是一个微型的社会，这句话的重点除了社会，更关键的在于前面的那个修饰词：微型。在大学里虽然你会看到学生组织里各种装模作样的社会习惯，但大学总归还是有象牙塔之称的，同学之间的利益关系也并没有那么复杂。扯远了。在真正看到你熟悉的人离开，而当你也已经即将面临着离开时，你才会意识到，这并没有想象中的那么单纯的兴奋。除了兴奋，可能还会带着一点对未知的恐惧？</p><h2 id="寝室🛏️"><a href="#寝室🛏️" class="headerlink" title="寝室🛏️"></a>寝室🛏️</h2><p>寝室依然是在我看来大学里最令人放松愉悦的地方。在大一的时候，我还是一个好少年，立志要努力认真，回报祖国。当时听到过无数次“寝室是堕落的温床”。于是尝试去了几次图书馆，但是在南昌室外的恶劣天气的劝退下，我又成了床上的雕像，夜夜皆然。还好之后爱上了写代码，然后搞了个外接显示器+青轴键盘，这让我更不可能去图书馆学习了。之后的故事就很容易想象了，在寝室疯狂看文档，敲代码，夜夜皆然。</p><p>回到寝室之后，感觉无比的放松。之前回到租的地方的时候总是会觉得自己并不属于那里，想要积极的去培养“房子是租来的但生活不是”这种认知，但是面对一间不到10平的房子我是在不能拥有这种觉悟。但回到寝室却觉得，自己像是回到了第二个家一样。后来想了一下，想明白了因为那里住着你熟悉的人，宿舍楼的旁边都是你所熟悉的事物，一切都没有改变。</p><p>回到学校在寝室的第一个晚上，和室友们在那谈天说地，隔壁的两个老哥来我们寝室玩然后也加入到了吹牛逼阵营。</p><p>在大家吹牛逼的过程中，大概也对学校的一些事情和同学们的状态有了大概的了解，在吹牛逼的几个人中，有保研的、考研的、准备工作已经找到了暑期实习和准备工作但还没有找到实习的，几乎包括了这个时候大三所有的状态。那天晚上大家侃到了大概晚上快三点，用一句话来总结的话大概就是，迷茫可能是大家目前最相似的状态。</p><h2 id="家园🏠"><a href="#家园🏠" class="headerlink" title="家园🏠"></a>家园🏠</h2><p>其实大三就已经差不多离开了家园，虽然自己的名字还在家园的名单上，但是几乎已经没有再为家园做过什么事情了。没能为家园留下更多东西是非常遗憾的一件事情。</p><p>在周六的中午大家聚餐了一次，但是我有点事没能去。下午的研发座谈会大家又做到了一起，见到了好久没见过的学长们，和他们也聊了挺多。他们即将要离开了，我们也快了。</p><p>And ，家园目前的状态令人担忧。</p><p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;回校见闻&quot;&gt;&lt;a href=&quot;#回校见闻&quot; class=&quot;headerlink&quot; title=&quot;回校见闻&quot;&gt;&lt;/a&gt;回校见闻&lt;/h2&gt;&lt;p&gt;现在是在端午节回学校的高铁上，车外还是熟悉的景色，大片大片已经收割过的麦田。从小语文老师和父母就告诉我，现在是收获的季节。正
      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
  </entry>
  
  <entry>
    <title>跑路实习不完全指东西南北-信工篇</title>
    <link href="http://stan1812.github.io/2019/06/02/internship/"/>
    <id>http://stan1812.github.io/2019/06/02/internship/</id>
    <published>2019-06-02T14:00:25.000Z</published>
    <updated>2020-03-03T08:52:42.411Z</updated>
    
    <content type="html"><![CDATA[<p>泻药，人在寝室，刚下床。（逃</p><hr><p>众所周知，在信工，想要出去实习，需要面临多方面的压力。除了课程方面，最主要的压力来自于学院政策的阻碍，想要解决这些问题，非常的困难，甚至可以说需要运气支撑，但是也还是可以做一些努力来苟一波。</p><h2 id="代课"><a href="#代课" class="headerlink" title="代课"></a>代课</h2><p>如果你的辅导员要求你的学习委员每节课签到，并且要求老师签字，那你就需要来找一个代课来操作一下。</p><p>代课群是一个好东西，如果能够找一个靠谱的代课就非常的舒服。代课群的规则一般是：给群主几块钱然后进群，群一般是是禁言的，你需要给群主发找代课的具体信息，然后群主在群里发，找到后群主会再让你支付3块钱的中介费。。代课的价格一般是两节课15，三节课20。</p><p>至于找代课，我的建议是在开学的时候每个课都先找一个代课，之后可以选择和代课老哥们聊一下，看下他们长期代课的意愿。如果你能找到一个平时比较闲又比较负责，能够代好几门课的，那恭喜你，这个老哥会让你非常舒服。当然你也需要多来点money让代课老哥舒服一下。比如说我这个学期找到一个很靠谱的老哥，会帮忙写作业、写期中卷子并且还会自己找同学借书抄，还会帮忙偶尔舔一下老师，这就非常的舒服，当然这些都要一点银子，除此之外还是之前所说的你需要时不时多给点Bonus。这里要感谢下这位代课老哥。</p><h2 id="时间点"><a href="#时间点" class="headerlink" title="时间点"></a>时间点</h2><p>这里所说的时间点指的是回学校的时间点，一般来说一个学期大概需要回学校3次。</p><h3 id="开学"><a href="#开学" class="headerlink" title="开学"></a>开学</h3><p>开学的时候是一定要回学校一次的，在开学的时候是上课人数最多的时候，而且老师通常会点个到来确定班级人数，这个时候如果不在学校就会非常的显眼。等个差不多一星期给同学们个你在学校的大概印象就够了，接下来可以找时候溜。</p><p>我这个学期的话是在开学大概第二周的时候回了学校大概一星期，上了一星期的课，当时考虑的是，第一周不回去有很多的理由可以跟同学解释，比如家里有点事、火车票没买到，等等。但是比较倒霉的是回去的一周都没有点到。我当时同学有几个知道我去了微博（因为在大三上末尾的时候没有留意到这些，跟一个老哥说了自己面了微博的实习生，于是就有好几个人都知道了），回去这一趟，顺便跟他们解释了说因为互联网寒冬，我的offer没有发下来，之前没来是因为家里有点事所以请了一段时间假。然后向他们贩卖了一波就业相关的焦虑，让他们焦虑自己的前途可能会让他们懒得管其他人的事。</p><h3 id="期中"><a href="#期中" class="headerlink" title="期中"></a>期中</h3><p>期中的时候，要回去一趟。到了这个时间点（大概在10周左右的样子）这时候已经过了两个多月，平时跟你关系不错的同学们可能会注意到你这段时间不在学校，你需要回去考试，顺带来跟他们解释下，这时候可能大概率会有人猜到你在外面实习，我的处理方法是，死不承认（滑稽</p><p>我在大概期中考试前被导员发现不在学校，当时是因为前面有几次不点到的课突然点到了，但是当时没有找代课，于是在导员查考勤表的时候发现我逃课太多，我们导员也有查寝的习惯，之前有两次她查寝我不在，于是要找我谈话。然而我当时并不在学校，但导员死活就是要我去找她，于是我就暴露了不在学校的事实，当时临近清明节，所以跟老师说清明节提前离校去北京参加一个比赛了。清明节之后回的学校。在清明节后我去找导员谈话，于是又跟她贩卖了一波焦虑，然后跟她聊了还挺多的。一个比较重要的点是我跟她说我平时基本都在家园机房，家园最近事情非常多，晚上也在机房，一般11点前才回寝室，实习的事情没有暴露，同时也为之后她每次查寝时我室友为我打掩护提供了方便。</p><h3 id="期末"><a href="#期末" class="headerlink" title="期末"></a>期末</h3><p>如果你坚持到了这个时候，恭喜，好好回学校准备考试吧～</p><h2 id="僚机"><a href="#僚机" class="headerlink" title="僚机"></a>僚机</h2><p>僚机非常重要，很多时间是需要僚机来打掩护的，最靠谱的还是你的室友。如果你的室友正好是班长，那你就拥有了F-35做僚机。我的室友就是我们班班长（再次滑稽）。当时我的室友替我打了很多掩护，在这里要感谢我的室友们。导员有查寝的习惯，她查寝的时候我的室友会把我的桌子搞得乱一点，旁边地上放些外卖盒椅子背上放件衣服等等，然后导员问起来，就说我去机房了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>还有一点就是，少在班群说话，让做什么就做，让大学习就学习，让截图就截。尽量减少存在感。</p><p>总结下，大概就是三点：代课，僚机，少说话。</p><p>当然以上的内容可能一点用都没有。</p><p>如果你的运气好，你可能苟一个学期都不会被发现，运气不好，可能某件突发事件你就暴露了。</p><p>最后，祝实习顺利。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;泻药，人在寝室，刚下床。（逃&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;众所周知，在信工，想要出去实习，需要面临多方面的压力。除了课程方面，最主要的压力来自于学院政策的阻碍，想要解决这些问题，非常的困难，甚至可以说需要运气支撑，但是也还是可以做一些努力来苟一波。&lt;/p&gt;
&lt;h2 id=&quot;代课
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代码整洁之道-阅读笔记</title>
    <link href="http://stan1812.github.io/2019/05/30/clean-code/"/>
    <id>http://stan1812.github.io/2019/05/30/clean-code/</id>
    <published>2019-05-30T14:45:36.000Z</published>
    <updated>2020-03-03T08:52:42.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码问题："><a href="#代码问题：" class="headerlink" title="代码问题："></a>代码问题：</h2><ul><li>函数存在副作用，调用时可能对函数的结果作了隐含的假设；</li><li>函数或类的职责繁多，不敢轻易修改，因为不知这种变化会影响到哪些模块；</li><li>热点代码被频繁变更，职责被包裹了一层又一层，没有清晰的边界；</li><li>在系统某个角落，隐藏着伺机而动的Bug，当诱发条件具备时，就会让整条调用链瘫痪；</li><li>不同的业务场景包含了不同的例外场景，每种例外场景的处理方式都各不相同；</li><li>同步处理与异步处理代码纠缠在一起，不可预知代码执行的顺序。</li></ul><h2 id="关于业务代码："><a href="#关于业务代码：" class="headerlink" title="关于业务代码："></a>关于业务代码：</h2><p>业务代码特点：逻辑复杂、前后依赖多、可复用性差、迭代周期短。</p><ul><li>合理冗余其实也是一种重构，根据业务逻辑和代码规模，做相似抽象还是代码冗余，这其实也是渐进式重构的一种体现。无论采用何种方式，只要能把业务逻辑表达清楚，让代码始终保持良好的可读性和可维护性，就OK。</li><li>相似抽象还是合理冗余 when？ how？why？非常容易遇到一种代码</li><li>我非常喜欢Redux 中的一些思想：state 就是普通的 object，reducer 就是普通的 function，action 也是普通的 object。简单，强大</li></ul><h2 id="渐进式重构"><a href="#渐进式重构" class="headerlink" title="渐进式重构"></a>渐进式重构</h2><h2 id="关于函数"><a href="#关于函数" class="headerlink" title="关于函数"></a>关于函数</h2><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>在编写web应用时，尤其是像使用Vue或者React的时候，应用需要维护大量的状态，这时函数之间也会不可避免的和状态之间扯上关系。在函数之间，状态的传递和维护使用哪种方式比较好呢？</p><p>比如<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">data()&#123;</div><div class="line">  <span class="keyword">return</span>&#123;</div><div class="line">    userGroup:<span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">methods:&#123;</div><div class="line">  bar()&#123;</div><div class="line">    operation(<span class="keyword">this</span>.userGroup)</div><div class="line">  &#125;,</div><div class="line">  far()&#123;</div><div class="line">    <span class="keyword">this</span>.userGroup = [xxx]</div><div class="line">    bar()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>或者是将数据使用参数进行传递<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">methods:&#123;</div><div class="line">  bar(data)&#123;</div><div class="line">    operation(data)</div><div class="line">  &#125;,</div><div class="line">  far()&#123;</div><div class="line">    bar(<span class="number">1</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这是我非常疑惑的地方，看起来使用前者是非常不明智的选择，因为其实相当于创建了多余的全局变量，这很明显违背了一些基本的原则。但是在实际的开发中，比如需要维护较复杂的应用，而某个状态需要在多个函数中使用，并且维护的数据类型属于数组等数据量比较大的类型时，在以数据驱动的Vue中，如果按照数据驱动思想去编写代码，使用<code>data</code>维护数据确实是比较简单并且省事的方法。</p><p>但简单可能会带来无序，在多个函数中对data的某个数据进行修改，意味着状态管理其实是比较混乱的。当需要加新的需求，然后你发现更改一行代码可能需要顾及到其他地方的数据变化。这其实在使应用的维护性变差。</p><p>但是在书中提到了这样的一句话：</p><blockquote><p>最理想的参数数量是零。<br>并且按照书中的说法，似乎参数的使用是迫不得已才要使用，<br>而后者的使用会面临以下几个问题：丑陋的标识参数</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代码问题：&quot;&gt;&lt;a href=&quot;#代码问题：&quot; class=&quot;headerlink&quot; title=&quot;代码问题：&quot;&gt;&lt;/a&gt;代码问题：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;函数存在副作用，调用时可能对函数的结果作了隐含的假设；&lt;/li&gt;
&lt;li&gt;函数或类的职责繁多，不敢轻易修
      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
  </entry>
  
  <entry>
    <title>宅与创造力</title>
    <link href="http://stan1812.github.io/2019/05/18/zhai/"/>
    <id>http://stan1812.github.io/2019/05/18/zhai/</id>
    <published>2019-05-18T13:24:04.000Z</published>
    <updated>2020-03-03T08:52:42.437Z</updated>
    
    <content type="html"><![CDATA[<p>宅会让人获得非凡的创造力或是丧失创造力。</p><p>我怕是属于后者。</p><p>完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;宅会让人获得非凡的创造力或是丧失创造力。&lt;/p&gt;
&lt;p&gt;我怕是属于后者。&lt;/p&gt;
&lt;p&gt;完。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MapReduce概念整理</title>
    <link href="http://stan1812.github.io/2019/05/11/hadoop-map-reduce/"/>
    <id>http://stan1812.github.io/2019/05/11/hadoop-map-reduce/</id>
    <published>2019-05-11T12:30:15.000Z</published>
    <updated>2020-03-03T08:52:42.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MapReduce数据模型"><a href="#MapReduce数据模型" class="headerlink" title="MapReduce数据模型"></a>MapReduce数据模型</h2><ol><li>向外扩展(Scale out)而非向上扩展(Scale up)<ol><li>多买便宜的，而非少买贵的</li></ol></li></ol><ol><li><p>假设故障很常见(Assume failures are common)</p><ol><li>健壮的应对系统或硬件故障</li></ol></li><li><p>将处理程序移向数据(Move processing to the data)</p><ol><li>传统高性能计算应用中，超级计算机一般有着处理节点(processing node)和存储节点(storage node)两种角色，它们通过高容量的设备完成互联。</li><li>大多数数据密集型的处理工作并不需要多么强大的处理能力，于是把计算与存储互相分开将使得网络成为系统性能瓶颈。</li><li>MapReduce在其架构中将计算和存储合并在了一起，并将数据处理工作直接放在数据存储的位置完成，只不过这需要分布式文件系统予以支撑。</li></ol></li><li><p>顺序处理数据并避免随机访问(Process data sequentially and avoid random access)</p><ol><li>MapReduce则主要设计用来在海量数据集上完成批处理操作，即所有的计算被组织成较长的流式处理操作，以延迟换取较大的吞吐能力。</li></ol></li><li><p>隐藏系统级别的细节</p><ol><li>MapReduce编程模型通过为其内部少量的几个组件提供了一个简单且精心定义的接口，从而将程序员与系统底层的处理细节隔离开来。MapReduce实现了“运算什么”与“如何在多个节点并行运算”的隔离，前者可以程序员控制，后者则完全由MapReduce编程框架或运行时环境控制。</li></ol></li><li><p>无缝扩展(Seamless scalability) </p><ol><li>其处理能力随着节点的增加而线性增长，即集群规模增长N倍其处理相同规模数据的时长也会缩短N倍。</li></ol></li></ol><h2 id="化整为零"><a href="#化整为零" class="headerlink" title="化整为零"></a>化整为零</h2><p>海量数据并行处理的核心思想即是“分而治之”，难点也随之产生</p><p>(1) 如何将大问题分割为小任务？进一步地，如何将大问题分解为可以并行处理的小任务？</p><p>(2) 如何将分解好的小任务派送给分布式系统中的某主机且是较为适合解决此问题的主机上的worker(进程)完成处理？</p><p>(3) 如何保证某worker获取所需的数据？</p><p>(4) 如何协调不同worker之间进行同步？</p><p>(5) 如何将某worker的部分结果共享给其它需要此结果的worker？</p><p>(6) 如何在出现软件或硬件故障时仍然能保证上述工作的顺利进行？</p><p>MapReduce为我们隐藏了这些问题</p><p>更为精确地说，MapReduce有三个相互关联却各不相同的概念。首先，MapReduce是一个函数式编程思想。其次，MapReduce也是一个运行框架，它能够协调运行基于MapReduce思想开发的程序。最后，MapReduce还可以被看作编程模型和执行框架的实现，例如Google的专有实现和另一个Hadoop中的MapReduce组件。</p><p>部署应用MapReduce意味着这样的过程：在现有的多个节点上部署完成MapReduce软件(即MapReduce的实现)并启动集群服务，便准备好了一个MapReduce程序运行环境(即运行框架)，此时只需要将用户开发的MapReduce程序(基于MapReduce函数式编程语言API开发)及其要处理的数据提交给MapReduce运行环境即可完成数据处理过程。</p><h2 id="JOB-运行流程"><a href="#JOB-运行流程" class="headerlink" title="JOB 运行流程"></a>JOB 运行流程</h2><p><img src="https://img-blog.csdn.net/20151215170248858" alt="https://img-blog.csdn.net/20151215170248858"></p><p>作业提交-&gt;作业初始化-&gt;任务分配-&gt;任务执行-&gt;更新任务执行进度和状态-&gt;作业完成</p><p>一个完整的mapreduce作业流程，包括4个独立的实体：</p><ul><li>客户端：client，编写mapreduce程序，配置作业，提交作业。</li><li>JobTracker：协调这个作业的运行，分配作业，初始化作业，与TaskTracker进行通信。</li><li>TaskTracker：负责运行作业，保持与JobTracker进行通信。</li><li>HDFS：分布式文件系统，保持作业的数据和结果。</li></ul><h2 id="Data-Flow"><a href="#Data-Flow" class="headerlink" title="Data Flow"></a>Data Flow</h2><p><img src="https://waltyou.github.io/images/posts/mapreduce-job-execution-flow.png" alt=""></p><h3 id="Input阶段"><a href="#Input阶段" class="headerlink" title="Input阶段"></a>Input阶段</h3><p>数据以一定的格式传递给Mapper，有TextInputFormat，DBInputFormat，SequenceFileFormat等可以使用</p><h3 id="Map阶段"><a href="#Map阶段" class="headerlink" title="Map阶段"></a>Map阶段</h3><p>对输入的(key，value)进行处理，即map(k1,v1)-&gt;list(k2,v2)</p><h3 id="Sort阶段"><a href="#Sort阶段" class="headerlink" title="Sort阶段"></a>Sort阶段</h3><p>对于Mapper的输出进行排序</p><h3 id="Combine阶段"><a href="#Combine阶段" class="headerlink" title="Combine阶段"></a>Combine阶段</h3><p>对于Sort之后又相同key的结果进行合并</p><h3 id="Partition阶段"><a href="#Partition阶段" class="headerlink" title="Partition阶段"></a>Partition阶段</h3><p>将Mapper的中间结果按照key的范围划分为R份（Reduce作业的个数)</p><h3 id="Reduce阶段"><a href="#Reduce阶段" class="headerlink" title="Reduce阶段"></a>Reduce阶段</h3><p>对于Mapper阶段的结果进行进一步处理</p><h3 id="Output阶段"><a href="#Output阶段" class="headerlink" title="Output阶段"></a>Output阶段</h3><p>输出计算结果</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MapReduce数据模型&quot;&gt;&lt;a href=&quot;#MapReduce数据模型&quot; class=&quot;headerlink&quot; title=&quot;MapReduce数据模型&quot;&gt;&lt;/a&gt;MapReduce数据模型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;向外扩展(Scale out)而非向上扩
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>译：7 Practical Tips for Cheating at Design</title>
    <link href="http://stan1812.github.io/2019/04/19/design/"/>
    <id>http://stan1812.github.io/2019/04/19/design/</id>
    <published>2019-04-19T12:44:52.000Z</published>
    <updated>2020-03-03T08:52:42.395Z</updated>
    
    <content type="html"><![CDATA[<p>在刷Medium上关于设计的文章的时候看到了这篇由<a href="https://medium.com/refactoring-ui" target="_blank" rel="external">Refactoring UI</a>团队写的文章，感觉非常赞，是非常有用的技巧，正好也在准备六级就来翻译一下。 原文链接：<a href="https://medium.com/refactoring-ui/7-practical-tips-for-cheating-at-design-40c736799886" target="_blank" rel="external">7 Practical Tips for Cheating at Design</a></p><p></p><blockquote><p>本文并非完全按照原文翻译，中间夹杂了一些个人的体会。</p></blockquote><p>无论喜欢与否，每个web开发人员都不可避免地会遇到需要做出设计决策的情况。(OS：对于开发者开发个人项目也是这样，因为其实一直去找设计师朋友去帮忙做很多决策是一件很麻烦的事情)</p><p>也许你的公司并没有一个全职设计师，但你需要设计出全新的UI；又或者你正在写你自己的side-project，而你希望它能够比 Bootstrap 的效果要强一点。</p><p>这个时候很多人会退缩:“这谁顶得住，我又不是一个艺术家” 但是事实证明，设计是有很多技巧的，我们完全可以运用这些技巧到工作中，并且并不需要有平面设计的背景。</p><p>今天的文章，我们总结了7个简单直观的改善网页视觉效果且能提升高级感的小技巧。很实际，也很实用，希望你们能喜欢。</p><h3 id="使用色彩和字重来创造层次结构，而不是单纯的大小对比"><a href="#使用色彩和字重来创造层次结构，而不是单纯的大小对比" class="headerlink" title="使用色彩和字重来创造层次结构，而不是单纯的大小对比"></a><a href="#使用色彩和字重来创造层次结构，而不是单纯的大小对比" title="使用色彩和字重来创造层次结构，而不是单纯的大小对比"></a>使用色彩和字重来创造层次结构，而不是单纯的大小对比</h3><p>（其实这也是我经常做的错误的事：想要创造层级就去放大缩小字体）</p><p><img src="https://cdn-images-1.medium.com/max/2400/1*KYZikUrx9F02cJU9kpn_gQ.png" alt=""></p><p>在对UI文本进行样式控制的时候，最常见的错误就是过度依赖字体大小差异来营造对比。</p><p>“这段文字重要吗？那就让它更大一点。”<br>“这段文字是比较次要吗？那么让它小一点。”</p><p>单纯使用字体大小对比，所营造的对比并不够，<strong>你需要尝试结合色彩和字重来营造更好的对比效果。</strong></p><p>“这段文字重要吗？<strong>我们让它色彩更加大胆一些吧</strong>。”<br>“这段文字是比较次要吗？<strong>我们让它的色彩更浅一些吧</strong>。”</p><p>你甚至可以采用两到三种颜色：</p><ul><li>主要内容采用深色（诸如标题，但是不要用纯黑）</li><li>次要内容采用灰色（比如文章发表日期）</li><li>辅助性内容采用浅灰色（比如页脚中的版权声明）</li></ul><p><img src="https://cdn-images-1.medium.com/max/1600/1*2YuCOOCjdMEJxg-Lb6G2FA.png" alt=""></p><p>类似的，在UI设计的时候，两种不同的<code>font-weight</code>就足以营造出优秀的层次感：</p><p>大多数的文本采用正常的<code>font-weight</code>（400到500，具体取决于字体）<br>对于需要强调的文字采用较重的字重（600到700，具体取决于字体）<br><img src="https://cdn-images-1.medium.com/max/1600/1*AHrVF0vTtj-yoyhmBNHNLA.png" alt=""></p><p>不要让正文部分字重小于<strong>400</strong>，尽管这可以让标题显得更大，但是低于400会使得可读性很差。如果你依然需要降低字重，不妨使用更浅的字体颜色，或者替换成其他识别度较强、字重相对较小的字体。</p><h3 id="不要在有色背景上使用灰色的文本"><a href="#不要在有色背景上使用灰色的文本" class="headerlink" title="不要在有色背景上使用灰色的文本"></a><a href="#不要在有色背景上使用灰色的文本" title="不要在有色背景上使用灰色的文本"></a>不要在有色背景上使用灰色的文本</h3><p><img src="https://cdn-images-1.medium.com/max/1600/1*ajjrhpp-l3GDG7ne7Am8fw.png" alt=""></p><p>在白色背景下，将黑色的文本改成灰色，是不错的淡化文本视觉效果的做法。但在彩色背景下这么做效果并不好。</p><p>这是因为，我们看到的效果其实是因为降低了对比度。</p><p><strong>在彩色背景下，想要降低对比度时应该让文本逐步接近背景色，</strong>而不是改为灰色。<br><img src="https://cdn-images-1.medium.com/max/2600/1*CNaej5BrPr9lWTMAfllfdw.png" alt=""></p><p>想降低和背景色之间的对比，通常有两种方法：</p><h4 id="1-降低白色文本的不透明度"><a href="#1-降低白色文本的不透明度" class="headerlink" title="1. 降低白色文本的不透明度"></a><a href="#1-降低白色文本的不透明度" title="1. 降低白色文本的不透明度"></a>1. 降低白色文本的不透明度</h4><p>使用白色的字体，并降低透明度，让背景色稍微透过来一点，以不与背景冲突的方式淡化文本。<br><img src="https://cdn-images-1.medium.com/max/1600/1*OMntEW2V5jPXrZR6CjrBFQ.png" alt=""></p><h4 id="2-根据背景色挑选文本的颜色"><a href="#2-根据背景色挑选文本的颜色" class="headerlink" title="2. 根据背景色挑选文本的颜色"></a><a href="#2-根据背景色挑选文本的颜色" title="2. 根据背景色挑选文本的颜色"></a>2. 根据背景色挑选文本的颜色</h4><p>这种情况下简单的降低透明度效果并不是很好，半透明的文本会影响可读性，这个时候最好是基于背景主色调来挑选相应的文本色。<br><img src="https://cdn-images-1.medium.com/max/1600/1*d5Ft9yND08hTdmXgFTLQJw.png" alt=""></p><h3 id="阴影设计"><a href="#阴影设计" class="headerlink" title="阴影设计"></a><a href="#阴影设计" title="阴影设计"></a>阴影设计</h3><p><img src="https://cdn-images-1.medium.com/max/2400/1*LisFGBtYOvR-3cwFTzTDUw.png" alt=""></p><p>相比于采用大范围的扩散模糊阴影，使用微妙的垂直偏移阴影效果会更明显。</p><p>这样看起来会更自然，因为模拟了最常见的光源特征，也就是光线从上往下照下来所营造的阴影效果，这是比较符合基本直觉的。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*qWSsYovqBDKF87f1IVMHsQ.png" alt=""></p><p>如果你对此有兴趣，可以去看下 Material Design Guideline </p><h3 id="尽量少使用-Borders"><a href="#尽量少使用-Borders" class="headerlink" title="尽量少使用 Borders"></a><a href="#尽量少使用-Borders" title="尽量少使用 Borders"></a>尽量少使用 Borders</h3><p><img src="https://cdn-images-1.medium.com/max/2400/1*fNm6hXxnBvIcHGp9DQRdRQ.png" alt=""></p><p>盒子模型是前端最常用到的工具。当需要在两个元素之间创建分隔的时候，应当尽量避免使两者直接接触。</p><p>Border是分隔两个元素的好办法，但它不是唯一的方法，过多的使用会让整个布局的设计感降低甚至造成混乱。</p><p>下次当你发现自己要处理这种情况时，可以尝试下面的办法：</p><h4 id="1-使用-box-shadow"><a href="#1-使用-box-shadow" class="headerlink" title="1. 使用 box shadow"></a><a href="#1-使用-box-shadow" title="1. 使用 box shadow"></a>1. 使用 box shadow</h4><p>box shadow 和border一样可以营造出边界感，而且更加微妙，并不会显得突兀，不会分散用户的注意力。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*Pm5PyS0vZ65GuGu8erPRfA.png" alt=""></p><h4 id="2-使用不同的背景色区分"><a href="#2-使用不同的背景色区分" class="headerlink" title="2. 使用不同的背景色区分"></a><a href="#2-使用不同的背景色区分" title="2. 使用不同的背景色区分"></a>2. 使用不同的背景色区分</h4><p>通常相邻的元素背景只需要有微妙的差别就足够能让用户进行区分。所以，你所需要做的就是在不同的div采用不同的背景色，并且尝试删除边框，你可能并不需要它。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*9j89WYXMqsnb_A1v8heXaw.png" alt=""></p><h4 id="3-增加额外的留白"><a href="#3-增加额外的留白" class="headerlink" title="3. 增加额外的留白"></a><a href="#3-增加额外的留白" title="3. 增加额外的留白"></a>3. 增加额外的留白</h4><p>有什么比简单地增加元素之间的分离更好的方法来创建元素之间的分隔呢? 将元素间隔得更远是在不引入任何新UI的情况下创建元素之间区别的好方法。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*7CEsoYdtFPjMBqpDB58HqQ.png" alt=""></p><h3 id="不要让小图标无端地放大"><a href="#不要让小图标无端地放大" class="headerlink" title="不要让小图标无端地放大"></a><a href="#不要让小图标无端地放大" title="不要让小图标无端地放大"></a>不要让小图标无端地放大</h3><p><img src="https://cdn-images-1.medium.com/max/2400/1*57g05Gl-FjDtcCUtaPPOLw.png" alt=""></p><p>当在设计一些落地页的时候，可能会需要突出产品的功能，这个时候就需要一些大图标来作为视觉锚点。你可能会去 Font Awesome 或者 Zondicons 这样的网站找几个免费的矢量图标，然后放大到符合你需求的尺寸。</p><p>它们都是矢量图标，照说是可以无损放大的。<strong>但是一个通常只有16×16 的图标放大三四倍，它固然无损，但是在视觉上就显得颇为不专业了</strong>：缺乏细节，给人感觉过于矮胖。</p><p><img src="https://cdn-images-1.medium.com/max/2400/1*dJyk3SNvrxuTEuZa7fiY0g.png" alt=""></p><p>可是，如果这些小图标是你唯一能够搞得到的素材的话，那不妨试着将它置于另外一个带有颜色的图形当中：</p><p><img src="https://cdn-images-1.medium.com/max/2400/1*Og6TmKmbZg7qauQymzhxBQ.png" alt=""></p><p>这样设计不仅能够让图标达到预期的视觉体积，而且看起来要比单纯的放大图标细节更加丰富。当然，如果你手头不是那么紧的话，最好还是买几个大尺寸的高素质图标，比如 Heroicons 或 Iconic。</p><h3 id="增加带有颜色的单边边框提升个性"><a href="#增加带有颜色的单边边框提升个性" class="headerlink" title="增加带有颜色的单边边框提升个性"></a><a href="#增加带有颜色的单边边框提升个性" title="增加带有颜色的单边边框提升个性"></a>增加带有颜色的单边边框提升个性</h3><p><img src="https://cdn-images-1.medium.com/max/2400/1*uwsVo34TWzKM91Gyqsh88Q.png" alt=""></p><p>如果你不是一个平面设计师，你如何在你的UI中添加更好视觉效果呢?</p><p>最简单的方法：在界面的边框中的一边添加上单色甚至渐变的边框，这能让平淡无奇的界面一下子变得鲜活起来。</p><p>比如在警告弹出框的侧面：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*jEivJuYRI3PbrGYVccKkHA.png" alt=""></p><p>或者在导航栏的底部，以示触发：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*7Pf5gu0r3uPi7W5vR9dcWQ.png" alt=""></p><p>或者在整个页面的顶部：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*YMrMBgjpbuTs_WqdbhymNg.png" alt=""></p><p>这并不需要什么平面设计的经验，但会明显强化页面的设计感。</p><p>你不知道选取什么颜色？简单，上Dribbble的色彩搜索中随便找几个看着漂亮的颜色，其实也就够用了。</p><h3 id="并非每个按钮都需要颜色"><a href="#并非每个按钮都需要颜色" class="headerlink" title="并非每个按钮都需要颜色"></a><a href="#并非每个按钮都需要颜色" title="并非每个按钮都需要颜色"></a>并非每个按钮都需要颜色</h3><p><img src="https://cdn-images-1.medium.com/max/2400/1*SIfuJd-3ZFYyA_W1Nme1Yw.png" alt=""></p><p>当用户可以在一个页面上执行操作时，很容易陷入纯粹基于语义设计操作的陷阱。</p><p>Bootstrap之类的框架提供了一个语义样式菜单，当你添加一个新按钮时，你可以从中选择:</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*2xkDfSjvq7Xyb_ceInrMpw.png" alt=""></p><p>“这是一个积极的操作？那这个按钮是绿色的。”<br>“要删除数据？那把按钮设置为红色的。”</p><p>的确，语义和按钮本身的设计息息相关，但是还有更重要的维度被忽略了，那就是<strong>层次结构。</strong></p><p>网页上每个操作其实都位于整个交互金字塔的某个位置。绝大多数的页面其实只有一个主要操作，搭配一些不太重要的次要操作，以及为数不多的几个三级操作。</p><p><strong>在设计这些交互的时候，通过层次结构来呈现交互的重要性是很重要的设计环节。</strong></p><ul><li><strong>主要操作应该明显</strong>。实色、高对比度的按钮是很有必要的。</li><li><strong>次要操作应该明显，但是不突出</strong>，应该采用ghost button或者和背景对比度较低的色彩是比较合理的。</li><li><strong>三级操作应该是可被发现，但是不明显的</strong>，这样的可以被设计为链接形式。</li></ul><p><img src="https://cdn-images-1.medium.com/max/1600/1*_tq33tZkr3DZuZgP08Jcrw.png" alt=""></p><p>“破坏性的交互所涉及的按钮不应该是红色的么？”</p><p>没必要！如果破坏性的交互所涉及到的按钮不是主要操作的话，让它按照次要操作甚至三级操作的按钮来设计就好了。</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*1CxYaUc6Bk-pTRXH5TQonw.png" alt=""></p><p>如果这样的操作是主要操作的话，可以让它是大号的、红色的带有加粗文本的按钮：</p><p><img src="https://cdn-images-1.medium.com/max/1600/1*cuYcwjOO26sKHImHaY6yFA.png" alt=""></p><h4 id="接下来是广告时间"><a href="#接下来是广告时间" class="headerlink" title="接下来是广告时间"></a><a href="#接下来是广告时间" title="接下来是广告时间"></a>接下来是广告时间</h4><p>Enjoy this post? We just released a book!<br>Refactoring UI takes everything we know about design and bundles it into one comprehensive package, including a book, screencasts, a component gallery, custom designed assets, and more.</p><p>Over 6000 people have picked it up so far, and the feedback has been amazing.</p><p>If you’re interested, head over to <a href="https://refactoringui.com/book/" target="_blank" rel="external">RefactoringUI.com/book</a> to learn more and download a sample.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在刷Medium上关于设计的文章的时候看到了这篇由&lt;a href=&quot;https://medium.com/refactoring-ui&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Refactoring UI&lt;/a&gt;团队写的文章，感觉非常赞，是非常有用的
      
    
    </summary>
    
    
      <category term="Design" scheme="http://stan1812.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>wildcard是个啥</title>
    <link href="http://stan1812.github.io/2019/03/12/wildcard/"/>
    <id>http://stan1812.github.io/2019/03/12/wildcard/</id>
    <published>2019-03-12T12:53:16.000Z</published>
    <updated>2020-03-03T08:52:42.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h1><h2 id="释意"><a href="#释意" class="headerlink" title="释意"></a>释意</h2><p>1、纸牌游戏中的“百搭牌”或“变牌”，持牌人决定此牌的牌值。</p><p>2、体育运动中的“外卡”或“外卡选手”。</p><p>3、计算机领域的“通配符”</p><h2 id="通配符证书"><a href="#通配符证书" class="headerlink" title="通配符证书"></a>通配符证书</h2><p>通配符 SSL 可以保护网站的 URL 及其所有子域（数量不限）。例如，一个单独的通配符证书就可以保护 <em>www.coolexample.com</em>、<em>blog.coolexample.com</em> 和 <em>store.coolexample.com</em>。</p><p>通配符证书可以保护通用域名和您在提交申请时指定的级别下的所有子域。只需在通用域名左侧的子域区域添加星号 (*) 即可。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a><strong>举例</strong></h3><p>如果您为 <em>*.coolexample.com</em> 申请证书，则可以保护：</p><ul><li>coolexample.com</li><li><strong>www</strong>.coolexample.com</li><li><strong>photos</strong>.coolexample.com</li><li><strong>blog</strong>.coolexample.com</li></ul><p>如果您为 <em>*.www.coolexample.com</em> 申请证书，则可以保护：</p><ul><li>www.coolexample.com</li><li><strong>mail</strong>.www.coolexample.com</li><li><strong>photos</strong>.www.coolexample.com</li><li><strong>blog</strong>.www.coolexample.com</li></ul><p>通配符证书可以像常规 SSL 证书一样为网站提供保护，并且申请是使用同一种验证方法进行处理的。</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id="字符"><a href="#字符" class="headerlink" title="? 字符"></a><strong>? 字符</strong></h3><p><code>?</code>字符代表单个字符。</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 存在文件 a.txt 和 b.txt</span></div><div class="line">$ <span class="keyword">ls</span> ?<span class="string">.txt</span></div><div class="line">a.txt b.txt</div></pre></td></tr></table></figure><p>上面命令中，<code>?</code>表示单个字符，所以会同时匹配<code>a.txt</code>和<code>b.txt</code>。</p><p>如果匹配多个字符，就需要多个<code>?</code>连用。</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 存在文件 a.txt、b.txt 和 ab.txt</span></div><div class="line">$ <span class="keyword">ls</span> ??<span class="string">.txt</span></div><div class="line">ab.txt</div></pre></td></tr></table></figure><p>上面命令中，<code>??</code>匹配了两个字符。<code>?</code>不能匹配空字符。也就是说，它占据的位置必须有字符存在。</p><h3 id="字符-1"><a href="#字符-1" class="headerlink" title="*字符"></a><strong>*字符</strong></h3><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 存在文件 a.txt、b.txt 和 ab.txt</span></div><div class="line"><span class="meta">$</span><span class="bash"> ls *.txt</span></div><div class="line">a.txt b.txt ab.txt</div><div class="line"><span class="meta">#</span><span class="bash"> 输出所有文件</span></div><div class="line"><span class="meta">$</span><span class="bash"> ls *</span></div></pre></td></tr></table></figure><p>上面代码中，<code>*</code>匹配任意长度的字符。</p><p><code>*</code>可以匹配空字符。</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 存在文件 a.txt、b.txt 和 ab.txt</span></div><div class="line">$ <span class="keyword">ls</span> a*<span class="string">.txt</span></div><div class="line">a.txt ab.txt</div></pre></td></tr></table></figure><h3 id="…-模式"><a href="#…-模式" class="headerlink" title="[…]模式"></a><strong>[…]模式</strong></h3><p>[…]则表示匹配括号中列出的字符中的任意一个</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 存在文件 a.txt 和 b.txt</span></div><div class="line">$ <span class="keyword">ls</span> [ab]<span class="string">.txt</span></div><div class="line">a.txt b.txt</div><div class="line"></div><div class="line">$ <span class="keyword">ls</span> *[ab]<span class="string">.txt</span></div><div class="line">ab.txt a.txt b.txt</div></pre></td></tr></table></figure><p><code>[start-end]</code>表示一个连续的范围。</p><figure class="highlight shell"><table><tr><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 存在文件 a.txt、b.txt 和 c.txt</span></div><div class="line"><span class="meta">$</span><span class="bash"> ls [a-c].txt</span></div><div class="line">a.txt b.txt c.txt</div><div class="line"></div><div class="line"><span class="meta">#</span><span class="bash"> 存在文件 report1.txt、report2.txt 和 report3.txt</span></div><div class="line"><span class="meta">$</span><span class="bash"> ls report[0-9].txt</span></div><div class="line">report1.txt report2.txt report3.txt</div></pre></td></tr></table></figure><p>[!..]表示不匹配括号中列出的字符中的任意一个</p><h3 id="…-模式-1"><a href="#…-模式-1" class="headerlink" title="{…}模式"></a><strong>{…}模式</strong></h3><p><code>{...}</code> 表示匹配大括号里面的所有模式，模式之间使用逗号分隔。</p><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">$ echo d&#123;<span class="selector-tag">a</span>,e,<span class="selector-tag">i</span>,u,o&#125;g</div><div class="line">dag deg dig dug dog</div></pre></td></tr></table></figure><p>它可以用于多字符的模式。</p><figure class="highlight puppet"><table><tr><td class="code"><pre><div class="line">$ <span class="keyword">echo</span> &#123;cat,dog&#125;</div><div class="line"><span class="keyword">cat</span> <span class="keyword">dog</span></div></pre></td></tr></table></figure><p><code>{...}</code>与<code>[...]</code>有一个很重要的区别。如果匹配的文件不存在，<code>[...]</code>会失去模式的功能，变成一个单纯的字符串，而<code>{...}</code>依然可以展开。</p><figure class="highlight vim"><table><tr><td class="code"><pre><div class="line"># 不存在 <span class="keyword">a</span>.txt 和 <span class="keyword">b</span>.txt</div><div class="line">$ <span class="keyword">ls</span> [<span class="keyword">ab</span>].txt</div><div class="line"><span class="keyword">l</span><span class="variable">s:</span> [<span class="keyword">ab</span>].tx<span class="variable">t:</span> No such <span class="keyword">file</span> <span class="built_in">or</span> directory</div><div class="line"></div><div class="line">$ <span class="keyword">ls</span> &#123;<span class="keyword">a</span>,<span class="keyword">b</span>&#125;.txt</div><div class="line"><span class="keyword">l</span><span class="variable">s:</span> <span class="keyword">a</span>.tx<span class="variable">t:</span> No such <span class="keyword">file</span> <span class="built_in">or</span> directory</div><div class="line"><span class="keyword">l</span><span class="variable">s:</span> <span class="keyword">b</span>.tx<span class="variable">t:</span> No such <span class="keyword">file</span> <span class="built_in">or</span> directory</div></pre></td></tr></table></figure><p>上面代码中，如果不存在<code>a.txt</code>和<code>b.txt</code>，那么<code>[ab].txt</code>就会变成一个普通的文件名，而<code>{a,b}.txt</code>可以照样展开。</p><p>大括号可以嵌套。</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><div class="line">$ echo &#123;<span class="keyword">j&#123;p,pe&#125;g,png&#125;</span></div><div class="line"><span class="keyword">jpg </span><span class="keyword">jpeg </span>png</div></pre></td></tr></table></figure><p>大括号也可以与其他模式联用。</p><figure class="highlight puppet"><table><tr><td class="code"><pre><div class="line">$ <span class="keyword">echo</span> &#123;cat,d*&#125;</div><div class="line"><span class="keyword">cat</span> <span class="keyword">dawg</span> <span class="keyword">dg</span> <span class="keyword">dig</span> <span class="keyword">dog</span> <span class="keyword">doug</span> <span class="keyword">dug</span></div></pre></td></tr></table></figure><p>上面代码中，会先进行大括号扩展，然后进行<code>*</code>扩展。</p><h3 id="start-end-模式"><a href="#start-end-模式" class="headerlink" title="{start..end} 模式"></a><strong>{start..end} 模式</strong></h3><p><code>{start..end}</code>会匹配连续范围的字符。</p><figure class="highlight lsl"><table><tr><td class="code"><pre><div class="line">$ echo d&#123;a..d&#125;g</div><div class="line">dag dbg dcg ddg</div><div class="line"></div><div class="line">$ echo &#123;<span class="number">11.</span><span class="number">.15</span>&#125;</div><div class="line"><span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span></div></pre></td></tr></table></figure><p>如果遇到无法解释的扩展，模式会原样输出。</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><div class="line">$ <span class="keyword">echo</span> &#123;a1.<span class="string">.3c</span>&#125;</div><div class="line">&#123;a1.<span class="string">.3c</span>&#125;</div></pre></td></tr></table></figure><p>这种模式与逗号联用，可以写出复杂的模式。</p><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">$ echo .&#123;mp&#123;<span class="number">3</span>..<span class="number">4</span>&#125;,m4&#123;<span class="selector-tag">a</span>,<span class="selector-tag">b</span>,<span class="selector-tag">p</span>,v&#125;&#125;</div><div class="line"><span class="selector-class">.mp3</span> <span class="selector-class">.mp4</span> <span class="selector-class">.m4a</span> <span class="selector-class">.m4b</span> <span class="selector-class">.m4p</span> .m4v</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;wildcard&quot;&gt;&lt;a href=&quot;#wildcard&quot; class=&quot;headerlink&quot; title=&quot;wildcard&quot;&gt;&lt;/a&gt;wildcard&lt;/h1&gt;&lt;h2 id=&quot;释意&quot;&gt;&lt;a href=&quot;#释意&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端、设计、用户体验</title>
    <link href="http://stan1812.github.io/2019/01/05/experience-engineering/"/>
    <id>http://stan1812.github.io/2019/01/05/experience-engineering/</id>
    <published>2019-01-05T15:38:27.000Z</published>
    <updated>2020-03-03T08:52:42.396Z</updated>
    
    <content type="html"><![CDATA[<p>如题，关于前端、设计和用户体验的一些思考。</p><p>先留坑了，期末考试完再来写。（2019/01/05）</p><blockquote><p>拖了一个多月，总算把这篇博客写完了。今天是元宵节，祝自己元宵节快乐(也祝看到这篇博客的你其他的所有人元宵节快乐)❤</p></blockquote><h3 id="前端，设计与用户体验"><a href="#前端，设计与用户体验" class="headerlink" title="前端，设计与用户体验"></a>前端，设计与用户体验</h3><blockquote><p> 体验科技是什么？体验科技包含大前端技术和用户体验设计，最终向用户提供的是产品与服务。体验科技是技术与设计的融合，是服务与用户的连接。——玉伯</p></blockquote><p>​    可以说曾经有很长的一段时间，我对前端工作流的理解就是，前端等产品出交互，然后等设计出UI，之后开始还原设计稿，实现交互逻辑。工作的时候也只是想着把页面精准还原就行了。当然很多时候事实也就是这样的，只是现在开始觉得，其实作为前端，我们可以把事情做的更好一点。</p><p>​    前段时间，看了SeaConf上玉伯的演讲：<a href="https://www.yuque.com/yubo/explore/tcaywl" target="_blank" rel="external">体验科技与好的社会</a>，看了以后感触很深。前端作为最接近用户的一环，我认为很多时候，前端的高度是可以影响产品的最终高度的。前端也许不是一个产品的灵魂所在，如果有一个好看的皮囊来承载这个灵魂，这个产品最终可能会被淘汰，它也会让用户记住在使用这个产品时，由产品所带来的欢愉和惊喜。在产品迭代如此迅速的互联网时代，这就够了。</p><h4 id="前端与设计"><a href="#前端与设计" class="headerlink" title="前端与设计"></a>前端与设计</h4><p>​    一直觉得设计师是非常酷的职业。觉得等到老了的时候 一个白发苍苍的设计师非常的酷，可能一直都能保持着对美的感受和要求。相比之下可能一个老程序员就显得没有那么酷了，虽然我对程序员并没有什么刻板印象(毕竟我也是个程序员)。</p><p>​    我也曾经尝试过设计一些页面，但是最终大多也都是半途而废失败告终。做的最完整的也不过是停留在期末大作业的前端设计水平。发现自己并没有什么对设计、排版、色彩的敏感性之后，我决定选择停留在浏览（或者说欣赏）一些国内外设计网站上那些优秀的设计师们的作品。</p><p>​    前端依赖于设计，设计决定了用户对一个产品的第一印象。很多时候，用户甚至会从设计来判断产品所有者（比如说某个公司）的专业性，在商业产品中，一个设计精美的网站显然能比设计糟糕的网站更容易获得用户的信任。想象一下，如果一个用户打开一个网站，结果网站设计版式色彩等非常混乱（比如说学校、政府机关的一些网站）。你可能会在心里暗暗的骂一句。如果不是有特殊的需求，用户肯定是不会愿意打开第二次的。如果你只是一个普通的商业/个人网站，后果其实可以想象。有句话叫美丽的皮囊千篇一律，有趣的灵魂万里挑一。是这样的，不过，一般的产品可能并没万里挑一的灵魂吧，美丽的皮囊也不是千篇一律的。要不还要选美干啥？</p><p>​    身边有一位非常棒的设计师兼前端同学，设计很棒写代码也贼6，简直就是前端的理想状态。希望自己以后能像他一样优秀。</p><p>​    多看设计网站，多读设计博客，多了解设计基本原则。希望以后我能自己设计出让自己满意的UI。</p><h4 id="前端与用户体验"><a href="#前端与用户体验" class="headerlink" title="前端与用户体验"></a>前端与用户体验</h4><p>​    用户体验是一个永恒的话题。产品经理们永远都在说这优化用户体验。细心的产品可能会关注到一个页面button点击的表现，输入框focus与blur状态的表现，有一些东西可能是只有前端会注意到的。这时候前端可能会面临两种选择，和产品沟通并积极寻找最佳方案，或者放任不管（”反正不影响功能“）。这可能是每个前端都会遇到的问题，这其实会体现一个前端的自我修养吧。前端是始终陪伴着用户的，换言之，前端是一个产品的第一道防线。因为总有产品、UI、QA同学注意不到的细节。而前端对一个产品是否有owner意识，或者说前端是否愿意去有这种意识，决定了这道防线的坚实程度。</p><p>​    每一个交互都应该是经过考量的。比如左滑退出会不会让用户感到不安（在hybrid应用里左滑是返回到上一路由还是退出页面？）？我退出某个页面后浏览到哪里会不会保留？我觉得产品是需要考虑每一个交互是否会给用户带来心理负担，更甚可能需要考虑每一个点击或者滑动是否会给用户带来惊喜，有非常多炫酷的交互方式，这时候又要考虑在低性能设备动画是否流畅，是否吸引了用户过多的注意力。这是我的一些思考。</p><p>​    人人都是产品经理，程序员们也不例外。多数人都是有一个关于产品的梦想的，只不过不同点在于产品的类型。你可能希望开发一个xx工具来解放xx方面的劳动，甚至去推动业界的发展，让社会更美好。每个人都会有些这样的想法或者说野心，就像玉伯说的，这没什么可不好意思的。</p><p>​    一个产品是否带来了价值，是否是普惠的，成本又有多少。这些前端当然可以选择不关注，如果没有足够的数据来做支撑，那么你的判断可能是不准确的。但这不妨碍你去对一个产品提高要求，其实也是对自己提高要求。去做出更稳定、兼容性更好的页面，去实现一些能给用户带来惊喜的效果，其实大家都能做到。</p><p>​    关于用户体验，前端要负起责任。</p><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>算是自己的一些拙见。对自己并不了解的领域做了一些评价。也算是自己的一些思考吧。</p><p>最后用玉伯的结尾来作为这篇文章的结尾：期待能与大家一起，让体验科技在中国大地上生根发芽，让我们的社会更美好。</p><p>– （2019/02/19）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如题，关于前端、设计和用户体验的一些思考。&lt;/p&gt;
&lt;p&gt;先留坑了，期末考试完再来写。（2019/01/05）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;拖了一个多月，总算把这篇博客写完了。今天是元宵节，祝自己元宵节快乐(也祝看到这篇博客的你其他的所有人元宵节快乐)❤&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
  </entry>
  
  <entry>
    <title>前端、设计、用户体验</title>
    <link href="http://stan1812.github.io/2019/01/05/experience/"/>
    <id>http://stan1812.github.io/2019/01/05/experience/</id>
    <published>2019-01-05T15:38:27.000Z</published>
    <updated>2020-03-03T08:52:42.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>体验科技包含大前端技术和用户体验设计，最终向用户提供的是产品与服务。体验科技是技术与设计的融合，是服务与用户的连接。——玉伯</p></blockquote><p>​    可以说曾经有很长的一段时间，我对前端工作流的理解就是，前端等产品出交互，然后等设计出UI，之后开始还原设计稿，实现交互逻辑。工作的时候也只是想着把页面精准还原就行了。当然很多时候事实也就是这样的，只是现在开始觉得，其实作为前端，我们可以把事情做的更好一点。</p><p>​    前段时间，看了SeaConf上玉伯的演讲：<a href="https://www.yuque.com/yubo/explore/tcaywl" target="_blank" rel="external">体验科技与好的社会</a>，看了以后感触很深。前端作为最接近用户的一环，我认为很多时候，前端的高度是可以影响产品的最终高度的。前端也许不是一个产品的灵魂所在，如果有一个好看的皮囊来承载这个灵魂，这个产品最终可能会被淘汰，它也会让用户记住在使用这个产品时，由产品所带来的欢愉和惊喜。在产品迭代如此迅速的互联网时代，这就够了。</p><h3 id="前端与设计"><a href="#前端与设计" class="headerlink" title="前端与设计"></a>前端与设计</h3><p>​    一直觉得设计师是非常酷的职业。觉得等到老了的时候 一个白发苍苍的设计师非常的酷，可能一直都能保持着对美的感受和要求。相比之下可能一个老程序员就显得没有那么酷了，虽然我对程序员并没有什么刻板印象(毕竟我也是个程序员)。</p><p>​    我也曾经尝试过设计一些页面，但是最终大多也都是半途而废失败告终。做的最完整的也不过是停留在期末大作业的前端设计水平。发现自己并没有什么对设计、排版、色彩的敏感性之后，我决定选择停留在浏览（或者说欣赏）一些国内外设计网站上那些优秀的设计师们的作品。</p><p>​    前端依赖于设计，设计决定了用户对一个产品的第一印象。很多时候，用户甚至会从设计来判断产品所有者（比如说某个公司）的专业性，在商业产品中，一个设计精美的网站显然能比设计糟糕的网站更容易获得用户的信任。想象一下，如果一个用户打开一个网站，结果网站设计版式色彩等非常混乱（比如说学校、政府机关的一些网站）。你可能会在心里暗暗的骂一句。如果不是有特殊的需求，用户肯定是不会愿意打开第二次的。如果你只是一个普通的商业/个人网站，后果其实可以想象。有句话叫美丽的皮囊千篇一律，有趣的灵魂万里挑一。是这样的，不过，一般的产品可能并没万里挑一的灵魂吧，美丽的皮囊也不是千篇一律的。要不还要选美干啥？</p><p>​    身边有一位非常棒的设计师兼前端同学，设计很棒写代码也贼6，简直就是前端的理想状态。希望自己以后能像他一样优秀。</p><p>​    多看设计网站，多读设计博客，多了解设计基本原则。希望以后我能自己设计出让自己满意的UI。</p><h3 id="前端与用户体验"><a href="#前端与用户体验" class="headerlink" title="前端与用户体验"></a>前端与用户体验</h3><p>​    用户体验是一个永恒的话题。产品经理们永远都在说这优化用户体验。细心的产品可能会关注到一个页面button点击的表现，输入框focus与blur状态的表现，有一些东西可能是只有前端会注意到的。这时候前端可能会面临两种选择，和产品沟通并积极寻找最佳方案，或者放任不管（”反正不影响功能“）。这可能是每个前端都会遇到的问题，这其实会体现一个前端的自我修养吧。前端是始终陪伴着用户的，换言之，前端是一个产品的第一道防线。因为总有产品、UI、QA同学注意不到的细节。而前端对一个产品是否有owner意识，或者说前端是否愿意去有这种意识，决定了这道防线的坚实程度。</p><p>​    每一个交互都应该是经过考量的。比如左滑退出会不会让用户感到不安（在hybrid应用里是控返回到上一路由还是退出页面？）？我退出某个页面后浏览到那里会不会保留？我觉得产品是需要考虑每一个交互是否会给用户带来心理负担，更甚可能需要考虑每一个点击或者滑动是否会给用户带来惊喜，有非常多炫酷的交互方式，这时候又要考虑在低性能设备动画是否流畅，是否吸引了用户过多的注意力。这是我的一些思考。</p><p>​    人人都是产品经理，程序员们也不例外。多数人都是有一个关于产品的梦想的，只不过不同点在于产品的类型。你可能希望开发一个xx工具来解放xx方面的劳动，甚至去推动业界的发展，让社会更美好。每个人都会有些这样的想法或者说野心，就像玉伯说的，这没什么可不好意思的。</p><p>​    一个产品是否带来了价值，是否是普惠的，成本又有多少。这些前端当然可以选择不关注，如果没有足够的数据来做支撑，那么你的判断可能是不准确的。但这不妨碍你去对一个产品提高要求，其实也是对自己提高要求。去做出更稳定、兼容性更好的页面，去实现一些能给用户带来惊喜的效果，其实大家都能做到。</p><p>​    关于用户体验，前端要负起责任。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>算是自己的一些拙见。对自己并不了解的领域做了一些评价。也算是自己的一些思考吧。</p><p>最后用玉伯的结尾来作为这篇文章的结尾：期待能与大家一起，让体验科技在中国大地上生根发芽，让我们的社会更美好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;体验科技包含大前端技术和用户体验设计，最终向用户提供的是产品与服务。体验科技是技术与设计的融合，是服务与用户的连接。——玉伯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​    可以说曾经有很长的一段时间，我对前端工作流的理解就是，前端等产品出交互
      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
  </entry>
  
  <entry>
    <title>Hooks at a Glance</title>
    <link href="http://stan1812.github.io/2018/10/28/Hooks/"/>
    <id>http://stan1812.github.io/2018/10/28/Hooks/</id>
    <published>2018-10-28T03:54:43.000Z</published>
    <updated>2018-10-28T05:50:11.639Z</updated>
    
    <content type="html"><![CDATA[<p>在看了React Hooks的文档之后，本英语渣渣竟然突然有了想要翻译一下这篇文档的冲动，于是就首次尝试翻译一篇英文文档,原文<a href="https://reactjs.org/docs/hooks-overview.html" target="_blank" rel="external">Hooks at a Glance</a></p><p>Hooks是一个React中的新提案，他可以让你在不使用Class的情况下使用state和其他的React特性。Hooks 目前已经发布在 v16.7.0 alpha 版本，且正在开放的<a href="https://github.com/reactjs/rfcs/pull/68" target="_blank" rel="external">RFC</a>讨论。</p><p>Hooks是向后兼容的，这篇文档将向有经验的React开发者提供一个概览。</p><h2 id="📌-State-Hook"><a href="#📌-State-Hook" class="headerlink" title="📌 State Hook"></a>📌 State Hook</h2><p>这是一个计数器的例子，点击按钮，数字加一。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Declare a new state variable, which we'll call "count"</span></div><div class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></div><div class="line"><span class="regexp">        Click me</span></div><div class="line"><span class="regexp">      &lt;/</span>button&gt;</div><div class="line">    &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p><p>在这里，<code>useState</code>是一个Hook(我们稍后会讨论它是什么意思)，我们在一个函数式组件中调用它来添加一些内部的状态。React<br>将在重新渲染间保留此状态，<code>useState</code>返回一个pair:包含了当前的状态值和一个可以用来更新该值的函数。你可以在一个事件监听器或者其他地方调用这个函数。它和Class中的<code>setState</code>是类似的，不过他没把新旧状态合并在一起。（稍后会有例子来比较在使用State Hooks时useState和this.state的差异）</p><p>useState只有一个参数作为他的初始状态，在上面的例子中，这个参数是0，因为计数器从0开始。请注意，和this.state不同的是，这里的state不一定非要是一个对象——你要是想那也行。初始状态只在首次渲染时使用。</p><h3 id="声明多个状态变量"><a href="#声明多个状态变量" class="headerlink" title="声明多个状态变量"></a>声明多个状态变量</h3><p>你可以在一个组件中多次使用State Hook<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleWithManyStates</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Declare multiple state variables!</span></div><div class="line">  <span class="keyword">const</span> [age, setAge] = useState(<span class="number">42</span>);</div><div class="line">  <span class="keyword">const</span> [fruit, setFruit] = useState(<span class="string">'banana'</span>);</div><div class="line">  <span class="keyword">const</span> [todos, setTodos] = useState([&#123; <span class="attr">text</span>: <span class="string">'Learn Hooks'</span> &#125;]);</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>数组解构语法允许我们为通过调用useState声明的状态变量赋予不同的名称,这些名字并不是useState这个API的一部分，相反，React假定如果多次调用useState，就在每次渲染期间以相同的顺序执行。我们稍后会讨论这什么时候有用。</p><h3 id="但到底什么是Hook呢？"><a href="#但到底什么是Hook呢？" class="headerlink" title="但到底什么是Hook呢？"></a>但到底什么是Hook呢？</h3><p>Hooks 是一个React 函数组件内一类特殊的函数（通常以 “use” 开头，比如 “useState”），使开发者能够在 function component 里 ‘hook in’ state 和 life-cycles，以及使用 custom hook 复用业务逻辑。Hooks在Class组件中不能使用-这使得你可以在不写Class的情况下使用React（我们不建议您在一夜之间重写现有组件，但如果您愿意，可以开始在新组件中使用Hook。）<br>React提供了一些像useState这样的内置Hook。你还可以创建custom Hook以在不同组件之间重用有状态行为。我们先来看看内置的Hooks。</p><h2 id="⚡️-Effect-Hook"><a href="#⚡️-Effect-Hook" class="headerlink" title="⚡️ Effect Hook"></a>⚡️ Effect Hook</h2><p>你之前可能在React组件执行数据获取，订阅或手动更改DOM。我们称这种操作为“side effects”因为它们会影响其他的组件，并且不会在渲染期间就完成。</p><p>Effect Hook：<code>useEffect</code>为函数组件增添了执行side effects的能力。它与React Class中的componentDidMount，componentDidUpdate和componentWillUnmount具有相同的用途，但统一为单个API。 （我们将在使用Effect Hook时显示将useEffect与这些方法进行比较的示例。）</p><p>举个栗子，这个组件在React更新DOM之后设置文档标题 </p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</div><div class="line">  <span class="comment">// Similar to componentDidMount and componentDidUpdate:</span></div><div class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// Update the document title using the browser API</span></div><div class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></div><div class="line"><span class="regexp">        Click me</span></div><div class="line"><span class="regexp">      &lt;/</span>button&gt;</div><div class="line">    &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><p>当你调用useEffect时，相当于告诉了React在刷新对DOM的更改后再运行你的“effect”函数。Effects是声明在Component内的，所以有权访问组件的props和state。默认情况下，React在每次render都会调用effects，包括第一次render。（我们将更多地讨论使用<a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="external">Effect Hook</a>和class中的lifecycles进行比较。）</p><p>Effects还可以通过返回函数指定如何“清理”它们。例如，这个组件使用Effect来订阅朋友的在线状态，并通过取消订阅来清理：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>)</span>&#123;</div><div class="line">  <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</div><div class="line">    setIsOnline(status.isOnline)</div><div class="line">  &#125;</div><div class="line">  useEffects(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</div><div class="line">    &#125;;</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">if</span>(isOnline === <span class="literal">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'loading'</span></div><div class="line">  &#125;</div><div class="line">   <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> :<span class="string">'Offline'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这个例子中，React会在组件unmount时，以及在由于后续渲染而重新运行effects之前取消订阅ChatAPI（你也可以告诉React<a href="https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects" target="_blank" rel="external">跳过重新订阅</a>如果我们传给ChatAPI的props.friend.id没有变的话）</p><p>就像·useState·一样，你可以在一个Component中多次使用effect<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatusWithCounter</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</div><div class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</div><div class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</div><div class="line">    setIsOnline(status.isOnline);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ...</span></div></pre></td></tr></table></figure></p><p>Hooks允许您通过哪些部分相关（例如添加和删除订阅）来组织组件中的side effects，而不是基于生命周期方法强制拆分。<br>您可以在这个页面上了解有关useEffect的更多信息：<a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="external">Using the Effect Hook</a>。</p><h2 id="✌️-Rules-of-Hooks"><a href="#✌️-Rules-of-Hooks" class="headerlink" title="✌️ Rules of Hooks"></a>✌️ Rules of Hooks</h2><p>Hooks是JavaScript函数，但它们强加了两个额外的规则：</p><ul><li>只能在顶层调用Hooks。不要在循环，条件或嵌套函数中调用Hook。</li><li>仅从React函数组件中调用Hooks。不要从常规JavaScript函数中调用Hook。 （还有另一个有效的地方叫Hooks - 你自己的定制Hooks。我们马上就会了解它们。）</li></ul><p>我们提供了一个<a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="external">linter插件</a>来自动执行这些规则。这些规则最初可能看起来有限或令人困惑，但它们对于使Hooks运行良好至关重要。</p><h2 id="💡-Custom-Hooks"><a href="#💡-Custom-Hooks" class="headerlink" title="💡 Custom Hooks"></a>💡 Custom Hooks</h2><p>有时，我们希望在组件之间重用一些有状态逻辑。以往，这个问题有两种流行的解决方案：HOC和render props。Custom Hook可以做到这些，并且让你不需往组件树添加更多的组件。<br> 在前面，我们介绍了一个调用useState和useEffect Hooks的FriendStatus组件来订阅朋友的在线状态。假设我们还希望在另一个组件中重用此订阅逻辑：<br> 首先，我们将这个逻辑提取到一个名为useFriendStatus的自定义Hook中：<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"> <span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</div><div class="line">    setIsOnline(status.isOnline);</div><div class="line">  &#125;</div><div class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> isOnline;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 它将friendID作为参数，并返回我们的朋友是否在线。<br> 现在我们可以在组件中使用它：<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;li style=&#123;&#123; <span class="attr">color</span>: isOnline ? <span class="string">'green'</span> : <span class="string">'black'</span> &#125;&#125;&gt;</div><div class="line">      &#123;props.friend.name&#125;</div><div class="line">    &lt;<span class="regexp">/li&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p><p> 这些组件的状态是完全独立的。Hooks是重用有状态逻辑的一种方式，而不是状态本身。事实上，每次调用Hook都有一个完全隔离的state - 所以你甚至可以在一个组件中使用相同的自定义Hook两次。<br> Custom Hooks更像是一种约定而非功能,如果一个函数的名字以‘use’开头，把那个且他调用了其他的Hooks 我们称他为custom Hook 。useSomething命名约定也是linter插件在使用了hooks的代码中查找bug的原理。<br> 您可以编写自定义Hook，涵盖各种用例，如表单处理，动画，声明性订阅，计时器，可能还有更多我们没有考虑过的。我们很高兴看到React社区提出的定制Hooks。</p><h2 id="🔌-Other-Hooks"><a href="#🔌-Other-Hooks" class="headerlink" title="🔌 Other Hooks"></a>🔌 Other Hooks</h2><p>您可能会发现一些不太常用的内置Hook很有用。例如，useContext允许您订阅React上下文而不引入嵌套：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> locale = useContext(LocaleContext);</div><div class="line">  <span class="keyword">const</span> theme = useContext(ThemeContext);</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>useReducer允许您使用reducer管理复杂组件的本地状态：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Todos</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [todos, dispatch] = useReducer(todosReducer);</div><div class="line">  <span class="comment">// ...</span></div></pre></td></tr></table></figure></p><p>这只是React 官网中关于Hooks的一篇大概的介绍，更加详细的使用文档，可以在官方文档中获得：<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="external">HOOKS(Proposal)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在看了React Hooks的文档之后，本英语渣渣竟然突然有了想要翻译一下这篇文档的冲动，于是就首次尝试翻译一篇英文文档,原文&lt;a href=&quot;https://reactjs.org/docs/hooks-overview.html&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
    
      <category term="-JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>燃烧</title>
    <link href="http://stan1812.github.io/2018/10/25/movie-buring/"/>
    <id>http://stan1812.github.io/2018/10/25/movie-buring/</id>
    <published>2018-10-25T14:07:19.000Z</published>
    <updated>2020-03-03T08:52:42.413Z</updated>
    
    <content type="html"><![CDATA[<p>电影，燃烧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;电影，燃烧。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
  </entry>
  
  <entry>
    <title>元编程</title>
    <link href="http://stan1812.github.io/2018/10/24/meta-programming/"/>
    <id>http://stan1812.github.io/2018/10/24/meta-programming/</id>
    <published>2018-10-24T14:35:28.000Z</published>
    <updated>2020-03-03T08:52:42.413Z</updated>
    
    <content type="html"><![CDATA[<p>在1024这一天，先开个坑叭。</p><h3 id="什么是原编程（Mata-Programming）"><a href="#什么是原编程（Mata-Programming）" class="headerlink" title="什么是原编程（Mata Programming）"></a>什么是原编程（Mata Programming）</h3><p>很早之前就接触了元编程的一些东西，但是并没有什么很好的理解，只是觉得这个名字好牛逼，很玄幻🐸。主要还是在实际的coding中并没有直接的感触，最近又看到了相关的概念所以来简单的写点东西。</p><h3 id="不准确的翻译"><a href="#不准确的翻译" class="headerlink" title="不准确的翻译"></a>不准确的翻译</h3><p>在《你不知道的JS-ES6与未来》有这样的解释：元编程是针对程序本身的行为进行操作的编程。换句话说，它是为你程序的编程而进行的编程。 是的，很拗口。也有更详细些的这样的解释：元编程（笼统地说）是所有关于一门语言的底层机制，而不是数据建模或者业务逻辑那些高级抽象。如果程序可以被描述为 “制作程序”，元编程就能被描述为 “让程序来制作程序”。你可能已经在日常编程中不知不觉地使用到了元编程。</p><p>在接触了相关的概念之后，觉得似乎和想象中的不太一样，所以想到是否存在翻译的误解，首先从元这个字来理解好像有些问题，在中文的环境下元这个字在理解中有这样的理解：基本：单元，元件，元气（精气，根本），元素，元音。 而在概念中好像并不是这种意思，看到了有人解释这个meta的意思然后就有些理解了：</p><blockquote><p>Meta- 这个前缀在希腊语中的本意是「在…后，越过…的」，类似于拉丁语的 post-，比如 metaphysics 就是「在物理学之后」，这个词最开始指一些亚里士多德的著作，因为它们通常排序在《物理学》之后。但西方哲学界在几千年中渐渐赋予该词缀一种全新的意义：关于某事自身的某事。比如 meta-knowledge 就是「关于知识本身的知识」，meta-data 就是「关于数据的数据」，meta-language 就是「关于语言的语言」，而 meta-programming 也是由此而来，是「关于编程的编程」。<br>弄清了词源和字面意思，可知大陆将 meta- 这个前缀译为「元」并不恰当。台湾译为「后设」，稍微好一点点，但仍旧无法望文生义。也许「自相关」是个不错的选择，「自相关数据」、「自相关语言」、「自相关编程」——但是好像又太罗嗦了。</p></blockquote><p>这个翻译似乎有些问题。</p><p>这里举一个例子：</p><blockquote><p>例如，如果你为了调查对象a和另一个对象b之间的关系 —— 它们是被[[Prototype]]链接的吗？ —— 而使用a.isPrototypeOf(b)，这通常称为自省，就是一种形式的元编程。宏（JS中还没有） —— 代码在编译时修改自己 —— 是元编程的另一个明显的例子。使用for..in循环枚举一个对象的键，或者检查一个对象是否是一个“类构造器”的 实例，是另一些常见的元编程任务。</p></blockquote><h3 id="所关注的内容"><a href="#所关注的内容" class="headerlink" title="所关注的内容"></a>所关注的内容</h3><p>元编程关注以下的一点或几点：代码检视自己，代码修改自己，或者代码修改默认的语言行为而使其他代码受影响。简单的来概括，元编程中关注的方面: 代码生成(Code Generation) 反射(Reflection)</p><p>元编程的目标是利用语言自身的内在能力使你其他部分的代码更具描述性，表现力，和/或灵活性。由于元编程的 元 的性质，要给它一个更精确的定义有些困难。理解元编程的最佳方法是通过代码来观察它。<br>ES6在JS已经拥有的东西上，增加了几种新的元编程形式/特性。</p><p>Symbols 实现了的反射（Reflection within implementation）—— 你将 Symbols 应用到你已有的类和对象上去改变它们的行为。<br>Reflect 通过自省（introspection）实现反射（Reflection through introspection） —— 通常用来探索非常底层的代码信息。<br>Proxy 通过调解（intercession）实现反射（Reflection through intercession） —— 包裹对象并通过自陷（trap）来拦截对象行为。</p><h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h3><p>来看一个函数名的问题：这似乎是一个非常简单的不值一提的问题，但是JS就是这样，他会给你非常多的惊喜，答案会有些令人诧异地模糊。考虑如下代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">daz</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">bar: <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">bam: daz,</div><div class="line">zim() &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>在这前一个代码段中，“obj.foo()的名字是什么？”有些微妙。是”foo”，””，还是undefined？那么obj.bar()呢 —— 是”bar”还是”baz”？obj.bam()称为”bam”还是”daz”？obj.zim()呢？</p><p>另外，作为回调被传递的函数呢？就像：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line"><span class="comment">// `cb()` 的名字是什么？</span></div><div class="line">&#125;</div><div class="line">foo( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">// 我是匿名的！</span></div><div class="line">&#125; );</div></pre></td></tr></table></figure></p><p>在程序中函数可以被好几种方法所表达，而函数的“名字”应当是什么并不总是那么清晰和明确。更重要的是，我们需要区别函数的“名字”是指它的name属性 —— 是的，函数有一个叫做name的属性 —— 还是指它词法绑定的名称，比如在function bar() { .. }中的bar。<br>词法绑定名称是你将在递归之类的东西中所使用的：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (i &lt; <span class="number">10</span>) <span class="keyword">return</span> foo( i * <span class="number">2</span> );</div><div class="line"><span class="keyword">return</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>name属性是你为了元编程而使用的，所以它才是我们在这里的讨论中所关注的。<br>产生这种用困惑是因为，在默认情况下一个函数的词法名称（如果有的话）也会被设置为它的name属性。实际上，ES5（和以前的）语言规范中并没有官方要求这种行为。name属性的设置是一种非标准，但依然相当可靠的行为。在ES6中，它已经被标准化。</p><h4 id="推断"><a href="#推断" class="headerlink" title="推断"></a>推断</h4><p>但如果函数没有词法名称，name属性会怎么样呢？现在在ES6中，有一个推断规则可以判定一个合理的name属性值来赋予一个函数，即使它没有词法名称可用。<br>考虑如下代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> abc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">abc.name;<span class="comment">// "abc"</span></div></pre></td></tr></table></figure></p><p>如果我们给了这个函数一个词法名称，比如abc = function def() { .. },那么name属性将理所当然地是”def”。但是由于缺少词法名称，直观上名称”abc”看起来很合适。<br>这里是在ES6中将会（或不会）进行名称推断的其他形式：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;);<span class="comment">// name:</span></div><div class="line">(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123; .. &#125;);<span class="comment">// name:</span></div><div class="line"><span class="built_in">window</span>.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;;<span class="comment">// name:</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Awesome</span> </span>&#123;</div><div class="line"><span class="keyword">constructor</span>() &#123; .. &#125;<span class="comment">// name: Awesome</span></div><div class="line">funny() &#123; .. &#125;<span class="comment">// name: funny</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = <span class="class"><span class="keyword">class</span> <span class="title">Awesome</span> </span>&#123; .. &#125;;<span class="comment">// name: Awesome</span></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">foo() &#123; .. &#125;,<span class="comment">// name: foo</span></div><div class="line">*bar() &#123; .. &#125;,<span class="comment">// name: bar</span></div><div class="line">baz: <span class="function"><span class="params">()</span> =&gt;</span> &#123; .. &#125;,<span class="comment">// name: baz</span></div><div class="line">bam: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;,<span class="comment">// name: bam</span></div><div class="line">get qux() &#123; .. &#125;,<span class="comment">// name: get qux</span></div><div class="line">set fuz() &#123; .. &#125;,<span class="comment">// name: set fuz</span></div><div class="line">[<span class="string">"b"</span> + <span class="string">"iz"</span>]:</div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;,<span class="comment">// name: biz</span></div><div class="line">[<span class="built_in">Symbol</span>( <span class="string">"buz"</span> )]:</div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;<span class="comment">// name: [buz]</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> x = o.foo.bind( o );<span class="comment">// name: bound foo</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;).bind( o );<span class="comment">// name: bound</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; .. &#125;<span class="comment">// name: default</span></div><div class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Function</span>();<span class="comment">// name: anonymous</span></div><div class="line"><span class="keyword">var</span> GeneratorFunction =</div><div class="line"><span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;&#125;.__proto__.constructor;</div><div class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> GeneratorFunction();<span class="comment">// name: anonymous</span></div></pre></td></tr></table></figure></p><p>name属性默认是不可写的，但它是可配置的，这意味着如果有需要，你可以使用Object.defineProperty(..)来手动改变它。</p><h4 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h4><p>在“new.target”中，我们引入了一个ES6的新概念：元属性。正如这个名称所暗示的，元属性意在以一种属性访问的形式提供特殊的元信息，而这在以前是不可能的。<br>在new.target的情况下，关键字new作为一个属性访问的上下文环境。显然new本身不是一个对象，这使得这种能力很特殊。然而，当new.target被用于一个构造器调用（一个使用new调用的函数/方法）内部时，new变成了一个虚拟上下文环境，如此new.target就可以指代这个new调用的目标构造器。<br>这是一个元编程操作的典型例子，因为它的意图是从一个构造器调用内部判定原来的new的目标是什么，这一般是为了自省（检查类型/结构）或者静态属性访问。<br>举例来说，你可能想根据一个构造器是被直接调用，还是通过一个子类进行调用，来使它有不同的行为：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line"><span class="keyword">constructor</span>() &#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">new</span>.target === Parent) &#123;</div><div class="line"><span class="built_in">console</span>.log( <span class="string">"Parent instantiated"</span> );</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">console</span>.log( <span class="string">"A child instantiated"</span> );</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Parent();</div><div class="line"><span class="comment">// Parent instantiated</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Child();</div><div class="line"><span class="comment">// A child instantiated</span></div></pre></td></tr></table></figure></p><p>这里有一个微妙的地方，在Parent类定义内部的constructor()实际上被给予了这个类的词法名称（Parent），即便语法暗示着这个类是一个与构造器分离的不同实体。</p><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>待续</p><h3 id="Proxy-amp-Reflect"><a href="#Proxy-amp-Reflect" class="headerlink" title="Proxy &amp; Reflect"></a>Proxy &amp; Reflect</h3><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>从对匿名函数的函数名推断，到告诉你一个构造器是如何被调用的元属性，你可以前所未有地在程序运行期间来调查它的结构。通用Symbols允许你覆盖固有的行为，比如将一个对象转换为一个基本类型值的强制转换。代理可以拦截并自定义各种在对象上的底层操作，而且Reflect提供了模拟它们的工具。</p><p>参考文章：<br>[译]ES6 中的元编程 系列<br>You-Dont-Know-JS<br>MDN-元编程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在1024这一天，先开个坑叭。&lt;/p&gt;
&lt;h3 id=&quot;什么是原编程（Mata-Programming）&quot;&gt;&lt;a href=&quot;#什么是原编程（Mata-Programming）&quot; class=&quot;headerlink&quot; title=&quot;什么是原编程（Mata Programmi
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>CoCo</title>
    <link href="http://stan1812.github.io/2018/10/10/CoCo/"/>
    <id>http://stan1812.github.io/2018/10/10/CoCo/</id>
    <published>2018-10-10T12:11:43.000Z</published>
    <updated>2018-10-24T14:36:53.614Z</updated>
    
    <content type="html"><![CDATA[<p>一篇感觉非常有意思的文章转载一下。转载自<a href="https://juejin.im/post/5a249066f265da430406714a" target="_blank" rel="external">@doodlewind</a></p><h2 id="内存寻梦环游记：一个变量的三重死亡"><a href="#内存寻梦环游记：一个变量的三重死亡" class="headerlink" title="内存寻梦环游记：一个变量的三重死亡"></a>内存寻梦环游记：一个变量的三重死亡</h2><h3 id="内存的世界"><a href="#内存的世界" class="headerlink" title="内存的世界"></a>内存的世界</h3><p>小 u 身高 64 位，是内存世界 number 家族里的一名浮点数变量。因为小 u 身体的二进制第一位是 0，所以按照 IEEE 754 标准，大家都把她当做女孩子来看待。她第 2 位到第 11 位的阶码并不够大，使得她看起来小巧玲珑；而她剩下的 52 个小数位十分精致，这样工作的时候和她打交道的变量舍入误差都很小，所以大家都很喜欢她。</p><p>小 u 每天的工作，是在内存世界里和其他的变量打交道，计算出有用的结果去造福人类世界。平时，在函数调用结束以后，小 u 就可以下班回到她在源代码里的家了。她的工作压力不大，不像那些身处 for 循环里名叫 i 呀 j 呀的变量那样需要不停地加班连轴转。而她的家也是自她出生以来就由人类世界里的程序员编写好的。别看那些程序员穿着邋遢，但对源代码却像对待自己的孩子一样宠爱。小 u 在源代码里的家就是用一种名叫 JavaScript 的材料建起来的，不光有五颜六色的编辑器主题来装饰，还有严谨的分号和括号来保证家里的结构的稳定和对称，让她很有安全感。</p><p>虽然有着可爱的外表、轻松的工作和舒心的家，但小 u 却还是有着自己的烦恼：她的家族出身决定了她不能有伴侣。</p><p>在 JavaScript 这种材料所在的国度里，number 家族隶属于古老的基本类型家族。除了 number 之外，那些经典的数据结构，像字符串 string 和空值 null，都属于基本类型家族。由于简单的基本类型很容易在代码里被解释器推断出来，所以他们的内存都是在一种死板的『栈』空间上预先分配好而不可变的。哪怕是和其他 number 耳鬓厮磨地加加减减，也不能真正地在一起。</p><p>而与基本类型家族相对的，则是时髦的引用类型家族。那些人类程序员青睐的所谓『面向对象编程』，说的就是这个家族。这个家族的成员复杂而多变，因此他们会被分配到广袤的『堆』空间上，相互之间经常是你中有我，我中有你的状态。比起注定孤独一生的基本类型家族，有对象的引用类型家族无疑要滋润得多。</p><p>小 u 有个不敢说出口的梦想，那就是努力成为引用类型里的一员。听说在远方的 Java 国度，有一条叫做『自动装箱』的法律能够让自己的家族看起来像引用类型家族一样，那样她也许就可以不再孤独了。</p><p>梦想归梦想，她对自己的生活其实还是挺满意的。在内存世界习惯之后，工作和生活的平衡是许多人类世界的程序员一辈子都达不到的。这样的生活一直继续着，直到有一天……</p><h3 id="闭包的诅咒"><a href="#闭包的诅咒" class="headerlink" title="闭包的诅咒"></a>闭包的诅咒</h3><p>那天像往常一样，小 u 从源代码的家里出发，通过词法分析门后，搭上了语法分析班车的轨道。班车上 JIT 的标识代表着 Just-In-Time，就好像人类世界中『JR 新干线』和『和谐号』那样，是高效、快捷的象征。</p><p>班车迅速地把小 u 载到了语法树轨道上的叶子节点站台。走下班车，站台上有一张 64 位尺寸的长椅。她坐上椅子闭上眼，等待着解释器对她的扫描和调用。</p><p>『但愿这次不要遇上粗俗的 null 值……』小 u 默念着，眼前一阵电光闪动，随着内存世界底层无数晶体管状态的改变，解释器如期读取了小 u 的值。在这条原子性的指令里，小 u 需要让解释器完全地控制自己，她从来不知道从电光闪动到再一次睁开眼睛之间，内存世界里发生了什么。</p><p>『嗯……』她如期醒来了，照理说她在醒来时还是会身处同样的站台位置，等待回程的语法树班车接她回家。</p><p>眼前还是同样的景象，不对，好像又有哪里不一样——站台的结构和布置似乎和之前别无二致，只是少了一样东西：轨道上空空荡荡，没有等待她的班车，更没有别人。难道……误点了？她打心里不相信这样低级的错误会出现频率精准的内存世界里。不过班车没来就是没来，她只好在站台上继续等待。</p><p>时间一赫兹一赫兹地经过，小 u 内心的不安和焦虑也在慢慢增加：到底发生了什么？班车是忘记我了吗？还是说提前开走了？女孩子一个人在外呆这么久是很不安全的，但是作为严谨的变量，独自行动更是内存世界里的大忌。『还是……再等等吧……』小 u 有些绝望地想。</p><p>班车还是没有到。</p><p>『不行了，我必须回源码里去啊！』等待终于让小 u 的情绪激动起来了，她开始在站台上寻找其它的出口，想要找到回家的路。轨道不能跳下去，但站台的两头有个红色的 Exit 标识，那里看起来是个可以通行的出口。不过现代编程语言国度里的变量一般从来都不这么走，因为手动的内存操作很危险。</p><p>小 u 打量四周，小心翼翼地推开了回程那头 Exit 下锈迹斑斑的门。谢天谢地，这里是有路的，并且看起来不是那么危险。她走过一段狭长的走道，走道里每隔固定的长度就会亮着一个小小的指示灯，看起来是内存地址空间的下标标识。终于，她看到了出口：一扇形状相同的 Exit 门。小 u 迫不及待地推开门，想看看自己有没有更接近家一点。</p><p>眼前的景象让她诧异：一模一样的轨道、一模一样的长椅、一模一样的站台、一模一样的 Exit，就好像自己根本没有移动过一样！</p><p>难道我走错路了吗？这不可能呀！小 u 对方向这样非 0 即 1 的状态有着绝对的自信，她知道她不会走错的。也许这段地址空间里的内容都是这样吧？没事的，再走走就不一样了吧。于是，天真的她开始了漫长的步行，然而让她一点点丧失信心的是，每一个 Exit 都通向同样的站台，毫无区别，甚至连锈迹都是一样的。『有人吗！』她开始呼救，尽管看起来有些徒劳。又这样支撑了一会，她终于感觉要放弃了，疲惫地坐在一个站台的长椅上听天由命。</p><p>……</p><p>『你迷路了吗？』</p><p>耳边一个声音响起，她骤然惊醒，蜷缩起来打量着声音的来源。这也是个 number 家族的浮点数，从第一位 1 来看是个男孩子，有着高她一个头的阶码和粗糙的小数位。</p><p>『你是谁……这又是哪里？』</p><p>『我是小 s，这里是闭包的堆空间。』</p><p>『闭包……堆？』</p><p>『是啊，我们家族的变量平时都是分配在栈上，每次调用的生命周期很快就能结束了。但是现在不知道在哪个函数里还有着对我们的引用，所以我们还没法被清除掉……』</p><p>『等等！生命周期是什么东西啊？难道我的生命还会结束吗？』</p><p>看到小 u 迷茫的样子，小 s 显得很吃惊：『难道你不知道吗？我们变量的生命一共有三重死亡呀。第一重，发生在我们离开作用域的时候，比如一个函数返回以后。这时候在上下文里就找不到我们了，我们这一重生命周期结束，但是不会被马上销毁掉。第二重，发生在内存中不再有引用我们的地方，解释器进行垃圾收集的时候。这时候我们彻底离开内存世界，回到源代码里。第三重，是人类世界里的程序员把我们的定义代码删除的时候，那时候才是最终的死亡。』</p><p>『那……难道我每次回到源码家里的时候，都……』</p><p>『是的，会发生前两重的死亡。但是只要源码没有被删除，我们就仍然存在于世界上。并且，前两重死亡发生得非常快，我们根本感觉不到。』</p><p>『可是，这样重新回到源码里的我还是我吗？』</p><p>『别问我这么深奥的问题啊……不过你要这么说的话，一个人还没有办法重复踏进两次河流呢！』</p><p>『噢……好像是这样……可是你刚才说的什么堆……』小 u 看起来还是很困惑。</p><p>『哦哦，你说这个啊！我们虽然是基本类型，但也不一定分配在栈上的。有可能引用类型会里动态地用到我们，这时候我们也有可能被分配在堆上呀。』小 s 还是在一本正经地说教。</p><p>闭包…引用类型…堆…小 u 恍然大悟，原来自己所在的空间，已经不是之前那个能够及时把她释放到回程班车上的栈空间了。由于某个函数或者引用类型此刻还有若干指向自己的地方，因此她被分配在了动态的堆空间上——这不就是她一直希望的吗！不过，由于解释器对堆空间的自动内存回收还没有运行，因此她现在只能和小 s 在这片空间里游荡，就好像被诅咒了一样。</p><p>『所以，我们能一起回去吗？』</p><h3 id="循环的泄漏"><a href="#循环的泄漏" class="headerlink" title="循环的泄漏"></a>循环的泄漏</h3><p>『本来我们肯定可以一起回去的，可感觉好奇怪，照理说解释器早该自动把我们这一带的内存都回收了，怎么到现在还是什么都没发生……』小 s 虽然看起来博闻强识，不过对于眼前的情况还是有些困惑。</p><p>『会不会这一带还有别人在使用……』小 u 的判断力好像恢复了。</p><p>『如果按正常的内存分配，到现在应该早就自动回收了呀。除非内存泄漏……啊！』小 s 好像被自己吓到了。</p><p>『那又是什么啊？』</p><p>『说来话长了……这么说吧，内存世界里一些制度比较老的国家，是让人类世界的程序员手动把我们释放掉的。这个规矩经常漏掉一些变量，给我们带来了很大的痛苦。我们 JavaScript 这边倒好一点，可以让解释器帮我们自动回收内存……』</p><p>『欸？那不是很好吗？』</p><p>『哎呀，自动回收的代码也是那帮不靠谱的程序员写的，该有的问题还是会有的呀。比如那个蹩脚的 IE 浏览器，出现循环引用的时候就会出问题……啊对了！怪不得我们出不去了！估计我们是被困在 IE 里了！』</p><p>『循环…引用…？』</p><p>『这个简单说是这样的：假如我们不是浮点数，是引用类型的对象的话，那么只要 u 这个对象有个属性指向我，而我的一个属性指向 u，这个你中有我我中有你的情况就是循环引用了啊。』</p><p>小 u 的脸忽然红了。不过迟钝的小 s 还是滔滔不绝：『现代的浏览器做内存回收的算法普遍是标记清除算法，这个算法没有循环引用问题。但是早期 IE 用了一个叫引用计数的算法，这个算法在刚才那种情况的时候引用计数就不会清零，这样内存就不会被解释器收集了……』</p><p>『啊……所以我们回不去了吗？』</p><h3 id="重生的重构"><a href="#重生的重构" class="headerlink" title="重生的重构"></a>重生的重构</h3><p>小 u 的疑问把小 s 从知识的海洋里拉了出来。现在，他们终于明白了现状：两个孤独的基本类型变量没有办法被自动回收，只要用户不停机，他们就会被永远困在这里，就像盗梦空间里那样。并且数学上已经证明，停机问题是不可解的。两人间长长的沉默降临了。</p><p>终于，小 s 打破了沉默：『其实……我想到了一个方法，可以试试。』</p><p>『嗯嗯，是什么啊？』</p><p>『我在的代码段应该还会执行，在那个时候，我想办法触发一个异常，让程序挂掉。』</p><p>『可是我们都好好地在这里了呀，已经是正确的代码怎么会报错呢？』</p><p>小 s 苦笑了一下：『看来你对 JavaScript 的奇葩一无所知啊。据说当初国父 Brendan Eich 制定基本国策的时候只用了一个周末，所以这门语言到处是暗坑，就算看起来结构工整规范的代码，那些人类程序员也经常写得乱七八糟。』</p><p>『所以，怎么……』</p><p>『比如说，虽然我是浮点数，但是其实因为我是在 if 里声明的，所以只要我愿意，我就能用一个叫做变量提升的设计缺陷，把我自己临时变成 undefined。』</p><p>『那样的话，类型就错了呀。』</p><p>小 s 又自信了起来：『对，只要我抓住那次机会，把这时候的我和其他变量做一次运算，就能把返回的类型从浮点数变成危险的 NaN 了。这样后面用到结果的地方肯定都不对，就算程序不崩溃，人类世界的用户或者程序员也能发现这个问题了。』</p><p>『他们发现了以后又能怎么样呢？』</p><p>『会重构掉我这段代码，然后你也可以回去了。』</p><p>『这样的话，一旦你的代码消失了，岂不是……』</p><p>『没事，很高兴认识你……』小 s 已经慢慢走到了站台一侧的边缘了，那里有一个左花括号挡住了他。他看准花括号前的地砖，使劲地踩了下去。一瞬间，变量提升就把他带出了作用域。没有过多少赫兹的时间，站台的地面下就开始摇晃，传来了燃烧着的报错对象从地下一层层抛出调用栈的声音。随着砰的一声巨响，报错对象撕裂了地面——这也是小 u 最后记得的场景了。</p><p>在记忆中的下一个镜头，她已经在回程的语法树班车上了。回到源代码里，然后等待着后面的调用，一切又似乎重新变得那么自然，好像什么都没有发生过。当然了，她所在的源代码模块里没有一个叫做 s 的变量，也许是在那个异常抛出之后就被人类加班加点地 hotfix 重构掉了吧。</p><p>几个版本之后，小 u 在一次代码优化中终于如愿以偿地成为了引用类型的属性。初来乍到的这个新源码家庭的时候，她看到这个 class 的属性里，来了一个熟悉的新成员。</p><p>『啊，u』</p><p>『啊，s』</p><p>异口同声地，他们说出了对方的名字。</p><p>END</p><p>后记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一篇感觉非常有意思的文章转载一下。转载自&lt;a href=&quot;https://juejin.im/post/5a249066f265da430406714a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@doodlewind&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="-JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Proxy &amp; Rreflect</title>
    <link href="http://stan1812.github.io/2018/09/15/proxy-reflect/"/>
    <id>http://stan1812.github.io/2018/09/15/proxy-reflect/</id>
    <published>2018-09-15T15:23:46.000Z</published>
    <updated>2020-03-03T08:52:42.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Proxy：更好的对象处理"><a href="#Proxy：更好的对象处理" class="headerlink" title="Proxy：更好的对象处理"></a>Proxy：更好的对象处理</h2><h3 id="Proxy概述"><a href="#Proxy概述" class="headerlink" title="Proxy概述"></a>Proxy概述</h3><p>Proxy 用来修改某些操作的默认行为，等同于在语言层面进行修改，属于一种元编程的：对编程语言进行编程。</p><p>顾名思义，Proxy的原意即是代理，Proxy 可以理解为在目标对象前架设一个拦截层，外界对该对象的访问都经过这层拦截，因此提供了一种机制来对外界的访问进行过滤和改写。<br>先来看一个示例：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;,&#123;</div><div class="line">  get:<span class="function"><span class="keyword">function</span>(<span class="params">target,key,receiver</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>`</span>)</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target,key,receiver)</div><div class="line">  &#125;,</div><div class="line">  set:<span class="function"><span class="keyword">function</span>(<span class="params">target,key,receiver</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>`</span>)</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target,key,value,receiver)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">// 以上代码对一个空对象进行了一层拦截，重新定义了属性的get，set方法，</span></div></pre></td></tr></table></figure></p><p>Proxy实际上重载了点运算符，用自己的定义覆盖了语言的原始定义。</p><h3 id="基本语法与API"><a href="#基本语法与API" class="headerlink" title="基本语法与API"></a>基本语法与API</h3><p>原生Javascript 对象所提供的Proxy的原生构造函数<code>let p = new Proxy(target, handler);</code>其中有几个概念，traps表示提供属性访问的方法，handler为包含traps的占位符对象（即属性是当执行一个操作时定义代理的行为的函数），target 用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。<br>API<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">handler.getPrototypeOf()</div><div class="line"><span class="comment">// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。</span></div><div class="line">handler.setPrototypeOf()</div><div class="line"><span class="comment">// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</span></div><div class="line">handler.isExtensible()</div><div class="line"><span class="comment">// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</span></div><div class="line">handler.preventExtensions()</div><div class="line"><span class="comment">// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</span></div><div class="line">handler.getOwnPropertyDescriptor()</div><div class="line"><span class="comment">// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, "foo") 时。</span></div><div class="line">handler.defineProperty()</div><div class="line"><span class="comment">// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, "foo", &#123;&#125;) 时。</span></div><div class="line">handler.has()</div><div class="line"><span class="comment">// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 "foo" in proxy 时。</span></div><div class="line">handler.get()</div><div class="line"><span class="comment">// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span></div><div class="line">handler.set()</div><div class="line"><span class="comment">// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span></div><div class="line">handler.deleteProperty()</div><div class="line"><span class="comment">// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。</span></div><div class="line">handler.ownKeys()</div><div class="line"><span class="comment">// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。</span></div><div class="line">handler.apply()</div><div class="line"><span class="comment">// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。</span></div><div class="line">handler.construct()</div><div class="line"><span class="comment">// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</span></div></pre></td></tr></table></figure></p><h3 id="Proxy能带来的"><a href="#Proxy能带来的" class="headerlink" title="Proxy能带来的"></a>Proxy能带来的</h3><p>因为在使用了Proxy后，对象的行为基本上都是可控的，所以我们能拿来做一些之前实现起来比较复杂的事情。</p><ol><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理<br>下面来看一下使用Proxy能给我们带来什么改变<h4 id="原生JS的枚举："><a href="#原生JS的枚举：" class="headerlink" title="原生JS的枚举："></a>原生JS的枚举：</h4>直接使用JS对象来代替枚举类型通常会不安全，我们所希望的枚举类型通常需要包含至少以下的特点：</li></ol><ul><li>如果不存在的话，报错。</li><li>不允许动态设置，否则报错。</li><li>不允许删除，否则报错。<br>当然TS的出现为我们解决了这个问题，我们这里单纯使用Proxy来编写一下简单的类型检测(当然使用原本的Object.definePerpoty也可实现)，<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ENUM</span>(<span class="params">object</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(object, &#123;</div><div class="line">    get(target, prop) &#123;</div><div class="line">      <span class="keyword">if</span> (target[prop]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`Unknown enum '<span class="subst">$&#123;prop&#125;</span>'`</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    set() &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Enum is readonly'</span>)</div><div class="line">    &#125;,</div><div class="line">    deleteProperty() &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Enum is readonly'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="使用Peoxy包装Fetch"><a href="#使用Peoxy包装Fetch" class="headerlink" title="使用Peoxy包装Fetch"></a>使用Peoxy包装Fetch</h3><p>Fetch是一个非常常用的原生API了，我们可以使用Proxy来简单的包装一下，使其变得更加的易用<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> handlers = &#123;</div><div class="line">  get (target, property) &#123;</div><div class="line">    <span class="keyword">if</span> (!target.init) &#123;</div><div class="line">      [<span class="string">'GET'</span>, <span class="string">'POST'</span>].forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</div><div class="line">        target[method] = <span class="function">(<span class="params">url, params = &#123;&#125;</span>) =&gt;</span> &#123;</div><div class="line">          <span class="keyword">return</span> fetch(url, &#123;</div><div class="line">            headers: &#123;</div><div class="line">              <span class="string">'content-type'</span>: <span class="string">'application/json'</span></div><div class="line">            &#125;,</div><div class="line">            mode: <span class="string">'cors'</span>,</div><div class="line">            credentials: <span class="string">'same-origin'</span>,</div><div class="line">            method,</div><div class="line">            ...params</div><div class="line">          &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> target[property]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> FetchX = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handlers)</div><div class="line"><span class="keyword">await</span> FetchX.GET(<span class="string">'XXX'</span>)</div><div class="line"><span class="keyword">await</span> FetchX.POST(<span class="string">'XXX'</span>, &#123;</div><div class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;...&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> assert = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;,&#123;</div><div class="line">  set(target,message,value)&#123;</div><div class="line">    <span class="keyword">if</span>(!value) <span class="built_in">console</span>.error(message)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">assert[<span class="string">'I am  wuyanzu'</span>] = <span class="literal">false</span>  <span class="comment">// Error: I am not wuyanzu</span></div></pre></td></tr></table></figure><h3 id="函数的链式调用"><a href="#函数的链式调用" class="headerlink" title="函数的链式调用"></a>函数的链式调用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> pipe = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> funcStack = [];</div><div class="line">    <span class="keyword">let</span> oproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125; , &#123;</div><div class="line">      get(target,fnName) &#123;</div><div class="line">        <span class="keyword">if</span> (fnName === <span class="string">'get'</span>) &#123;</div><div class="line">          <span class="keyword">return</span> funcStack.reduce(<span class="function">(<span class="params">val, fn</span>) =&gt;</span> fn(val) ,value);</div><div class="line">        &#125;</div><div class="line">        funcStack.push(<span class="built_in">window</span>[fnName]);</div><div class="line">        <span class="keyword">return</span> oproxy;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> oproxy;</div><div class="line">  &#125;</div><div class="line">&#125;());</div><div class="line"></div><div class="line"><span class="keyword">let</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</div><div class="line"><span class="keyword">let</span> pow    = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</div><div class="line"><span class="keyword">let</span> reverseInt = <span class="function"><span class="params">n</span> =&gt;</span> n.toString().split(<span class="string">""</span>).reverse().join(<span class="string">""</span>) | <span class="number">0</span>;</div><div class="line"></div><div class="line">pipe(<span class="number">3</span>).double.pow.reverseInt.get; <span class="comment">// 63</span></div></pre></td></tr></table></figure><h3 id="一个简单的数据响应"><a href="#一个简单的数据响应" class="headerlink" title="一个简单的数据响应"></a>一个简单的数据响应</h3><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"input"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>);</div><div class="line"><span class="keyword">const</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> newObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">  get(target, key, receiver) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</div><div class="line">  &#125;,</div><div class="line">  set(target, key, value, receiver) &#123;</div><div class="line">    <span class="built_in">console</span>.log(target, key, value, receiver);</div><div class="line">    <span class="keyword">if</span> (key === <span class="string">'text'</span>) &#123;</div><div class="line">      input.value = value;</div><div class="line">      p.innerHTML = value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line"></div><div class="line">input.addEventListener(<span class="string">'keyup'</span>, (e)=&gt; &#123;</div><div class="line">  newObj.text = e.target.value;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>相比Object.definePeproty只能代理一个属性，Proxy可以直接代理对象，这也带来了极大的方便，比如Vue由于使用的是Object.definePeproty来实现的数据劫持，所以对数组的监听，又额外进行了一些处理。之前尤雨溪发了一条微博：<br><code>这两天验证了一些 Vue 3.0 的设计，证明一些思路是可行的... Proxy 是个好东西 [doge] ​​​​</code><br>相信会有更多的惊喜的吧。</p><h2 id="Reflect：Proxy的另一面"><a href="#Reflect：Proxy的另一面" class="headerlink" title="Reflect：Proxy的另一面"></a>Reflect：Proxy的另一面</h2><p>首先我们要了解一下，为什么会新添加这么一个全局对象？如果你看过Reflect的一些函数，你就会发现，这个对象上的方法基本上都可以从Object上面找到，找不到的那些，也是可以通过对对象命令式的操作去实现的；那么为什么还要新添加一个呢？</p><ol><li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</li><li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li><li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li><li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</li></ol><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>Reflect对象一共有 13 个静态方法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">Reflect</span>.apply(target, thisArg, args)</div><div class="line"><span class="built_in">Reflect</span>.construct(target, args)</div><div class="line"><span class="built_in">Reflect</span>.get(target, name, receiver)</div><div class="line"><span class="built_in">Reflect</span>.set(target, name, value, receiver)</div><div class="line"><span class="built_in">Reflect</span>.defineProperty(target, name, desc)</div><div class="line"><span class="built_in">Reflect</span>.deleteProperty(target, name)</div><div class="line"><span class="built_in">Reflect</span>.has(target, name)</div><div class="line"><span class="built_in">Reflect</span>.ownKeys(target)</div><div class="line"><span class="built_in">Reflect</span>.isExtensible(target)</div><div class="line"><span class="built_in">Reflect</span>.preventExtensions(target)</div><div class="line"><span class="built_in">Reflect</span>.getOwnPropertyDescriptor(target, name)</div><div class="line"><span class="built_in">Reflect</span>.getPrototypeOf(target)</div><div class="line"><span class="built_in">Reflect</span>.setPrototypeOf(target, prototype)</div></pre></td></tr></table></figure></p><p>上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。<br>这里关于Reflect有一篇很好的文章：<a href="https://juejin.im/post/5a0e66386fb9a04523417418" target="_blank" rel="external">ES6 中的元编程：第二部分 —— 反射（Reflect）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Proxy：更好的对象处理&quot;&gt;&lt;a href=&quot;#Proxy：更好的对象处理&quot; class=&quot;headerlink&quot; title=&quot;Proxy：更好的对象处理&quot;&gt;&lt;/a&gt;Proxy：更好的对象处理&lt;/h2&gt;&lt;h3 id=&quot;Proxy概述&quot;&gt;&lt;a href=&quot;#Pr
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
</feed>
