<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>An Amazing World</title>
  
  <subtitle>前端小学生的神奇世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://stan1812.github.io/"/>
  <updated>2018-07-18T15:25:43.140Z</updated>
  <id>http://stan1812.github.io/</id>
  
  <author>
    <name>Shady</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我不知道的JavaScript&lt;四&gt;：原型与原型链</title>
    <link href="http://stan1812.github.io/2018/07/16/dont-know-JS4/"/>
    <id>http://stan1812.github.io/2018/07/16/dont-know-JS4/</id>
    <published>2018-07-16T14:50:44.000Z</published>
    <updated>2018-07-18T15:25:43.140Z</updated>
    
    <content type="html"><![CDATA[<h2 id="当我们在谈论原型时，我们在谈论什么？"><a href="#当我们在谈论原型时，我们在谈论什么？" class="headerlink" title="当我们在谈论原型时，我们在谈论什么？"></a>当我们在谈论原型时，我们在谈论什么？</h2><h3 id="从对象说起"><a href="#从对象说起" class="headerlink" title="从对象说起"></a>从对象说起</h3><hr><p>有一句话是这样说的JS中万物皆对象，这句话虽然不完全正确但是有些道理，毕竟JS中还是有很多特殊的复杂子类型比如函数，虽然函数也是可调用的对象，不过毕竟<code>typeOf null</code>结果都是object [滑稽]（因为底层对象都表示为二进制，在JS中二进制前三位都为0的话会被判定为object类型，null的二进制表示为全零自然会是object）</p><p>但是还是要好好梳理下对象相关的一些东西</p><h4 id="扯些关系不大的"><a href="#扯些关系不大的" class="headerlink" title="扯些关系不大的"></a>扯些关系不大的</h4><p>数组和对象的关系源远流长，以至于要区分数组和对象都要专门使用<code>Object.prototype.toString.call([])</code>或者<code>Array.isArray()</code>来判断。对象可以像数组一样使用<code>[]</code>来访问值，数组也可以使用<code>.</code>来添加属性，只是不管使用点操作符还是[]操作符来为数组添加命名属性，数组的length属性都不会发生变化<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> a =[]</div><div class="line">a.test = <span class="string">"hello"</span></div><div class="line"><span class="built_in">console</span>.log(a)</div><div class="line"><span class="comment">//[test: "hello"] test: "hello" length: 0</span></div></pre></td></tr></table></figure></p><h4 id="对象属性描述符"><a href="#对象属性描述符" class="headerlink" title="对象属性描述符"></a>对象属性描述符</h4><p>在ES5之前并没有提供可以直接检测属性特性的方法,但是从ES5开始,属性具备了标识符：可以通过<code>Object.getOwnPropertyDescriptor({})</code>获取：<br>比如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> test = &#123;&#125;</div><div class="line"><span class="built_in">Object</span>.defineProperty(test,<span class="string">"a"</span>,&#123;</div><div class="line">  value: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span>  </div><div class="line">&#125;)</div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(test,<span class="string">"a"</span>)</div><div class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure></p><p>顾名思义，writeble,enumrable,configurable。0</p><h4 id="getter和setter"><a href="#getter和setter" class="headerlink" title="getter和setter"></a>getter和setter</h4><p>在ES5中可以部分改写默认操作，虽然只能应用到单个属性上，当给一个属性定义getter和setter或者两者都有的时候，这个属性会被定义成“访问描述符（与数据描述符相对）”对于访问描述符来说，JS会忽略他们的value和writeable属性，而只关心set和get、configurable、enumerable特性<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  get a()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"b"</span>,&#123;</div><div class="line">  get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a*<span class="number">2</span>&#125;</div><div class="line">  enumerable:<span class="literal">true</span></div><div class="line">&#125;)</div><div class="line">obj.a <span class="comment">//1</span></div><div class="line">obj.b <span class="comment">//2</span></div></pre></td></tr></table></figure></p><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>当一个属性值为undefined的时候，要如何来判断是否存在？方法很多也很简单，<code>xx in obj</code>,<code>Object.getOwnProperty(&quot;xx&quot;)</code>区别在于in操作符会到原型链上检查，而后者不会。之后我们会详细区分。<br>Object.getOwnPropertyNames({})或者Object.keys()返回对象的所有属性名组成的数组，这可以用来便利对象，或者使用for in</p><p>数组中包含着内置的<code>@@iterator</code>因此我们for of可以直接应用到数组上，其实这样工作的：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="keyword">var</span> it = myArray[<span class="built_in">Symbol</span>.iterator]() <span class="comment">//使用Symbol.iterator获取对象内部的@@iterator属性。</span></div><div class="line">it.next() <span class="comment">//&#123;value: 1, done: false&#125;</span></div><div class="line">it.next() <span class="comment">//&#123;value: 2, done: false&#125;</span></div><div class="line">it.next() <span class="comment">//&#123;value: 3, done: false&#125;</span></div><div class="line">it.next() <span class="comment">//&#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure></p><p>而普通的对象没有内置的@@iterator，但我们可以手写：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> obj =&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</div><div class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="built_in">Symbol</span>.iterator,&#123;</div><div class="line">  enumerable:<span class="literal">false</span>,</div><div class="line">  writeable:<span class="literal">false</span>,</div><div class="line">  configurable:<span class="literal">true</span>,</div><div class="line">  value:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">this</span></div><div class="line">    <span class="keyword">var</span> idx = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> ks = <span class="built_in">Object</span>.keys(o)</div><div class="line">    <span class="keyword">return</span>&#123;</div><div class="line">      next:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">          value:o[ks[idx++]],</div><div class="line">          done:(idx&gt;ks.length)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">//手动遍历</span></div><div class="line"><span class="keyword">var</span> it = obj[<span class="built_in">Symbol</span>.iterator]();</div><div class="line">it.next()</div><div class="line"><span class="comment">//for of 遍历：</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> obj)&#123;</div><div class="line">  <span class="built_in">console</span>.log(el)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="由对象到原型"><a href="#由对象到原型" class="headerlink" title="由对象到原型"></a>由对象到原型</h3><hr><p>Javascript中的对象都会有一个特殊的<code>[[Prototype]]</code>内置属性，就是对于其他属性的引用，几乎所有的对象在创建[[Prototype]]属性的时候都会赋一个非空的值，但很快我们就会看到对象的[[Prototype]]属性可以为空，虽然少见。</p><p>[[Prototype]]属性有什么用呢?我们之前提到过，当试图引用对象的属性的时候会触发[[get]]操作，第一步是检查对象本身是否有这个属性，如果没有就继续往原型链上寻找，整个过程会持续找到匹配的属性名，或者查找完整条原型链，如果是后者，最终会返回undefined。</p><p>那么哪里是原型链的尽头呢？所有普通的原型链最终都会指向内置的Object.prototype /由于所有的内置对象都源于这个Object.prototype，所以这个对象会包含很多通用的功能，比如最常用的.toString,.valueOf</p><h4 id="属性设置与屏蔽"><a href="#属性设置与屏蔽" class="headerlink" title="属性设置与屏蔽"></a>属性设置与屏蔽</h4><p>给一个对象设置一个属性并非只是添加一个新属性或者修改一个属性而已，接下来我们来解释下这个过程：</p><p><code>obj.foo = &quot;bar&quot;</code></p><p>如果obj包含名为foo的普通数据访问属性，这条语句可以修改已有的属性值</p><p>如果foo并不包含在obj中那么就向原型链上寻找，如果找不到，foo将添加到obj</p><p>然而如果foo存在于原型链上层，那么赋值语句的行为会有些怪异:</p><ul><li>如果在原型链上存在foo且<code>writeable:true</code> 那么将会在obj添加foo，并且是屏蔽属性。  </li><li>如果在原型链上存在foo且<code>writeable:false</code> 那么不能在obj添加foo，且原型链上的foo不会被改写，语句会被忽略，严格模式下会报错。</li><li>如果在原型链上存在foo且是一个setter 那么将会调用这个setter<br>我们可能认为，只要向原型链上已存在的属性赋值就一定会触发屏蔽，但是在这以上三种情况中只有一种会发生屏蔽，2，3想要触发屏蔽的话可以使用Object.defineProperty()<br>如果原型链上也存在，obj也存在，那么会发生屏蔽，底层的foo将屏蔽链上的foo</li></ul><p>有时候会发生隐式屏蔽:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</div><div class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(obj1)</div><div class="line">obj1.a <span class="comment">// 1</span></div><div class="line">obj2.a <span class="comment">// 1</span></div><div class="line">obj1.hasOwnProperty(<span class="string">"a"</span>) <span class="comment">//true</span></div><div class="line">obj2.hasOwnProperty(<span class="string">"a"</span>) <span class="comment">//false</span></div><div class="line">obj2.a++ <span class="comment">//发生隐式屏蔽</span></div><div class="line"></div><div class="line">obj2.a <span class="comment">//2</span></div><div class="line">obj1.a <span class="comment">//1</span></div><div class="line"></div><div class="line">obj2.hasOwnProperty(<span class="string">"a"</span>) <span class="comment">//true</span></div></pre></td></tr></table></figure></p><p>这段代码其实还蛮有意思的。</p><h3 id="”类“"><a href="#”类“" class="headerlink" title="”类“"></a>”类“</h3><p>众所周知JS和传统的面向对象的语言不同，他并没有类来作为对象的抽象，JS只有对象，他是少有的可以不通过类直接创建对象的语言。</p><p>虽然没有类，但是开发者们其实一直都在模仿类的行为，其实就是利用了函数的一种特性：所有的函数都会有一个名为prototype的公有且不可枚举的属性，他会指向一个对象。<br><figure class="highlight php"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">Function</span> <span class="title">Foo</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">Foo.prototype <span class="comment">//&#123;&#125;</span></div></pre></td></tr></table></figure></p><p>这个对象称为Foo的原型，因为我们通过Foo.prototype来访问他，但是以学习JS的经验来看（滑稽），顾名思义会出大问题滴（再次滑稽）。先抛开名字不谈，这个东西到底是什么？<br>之前我们讲过new对象时大概会发生的四个步骤，这里就要提到第二步：执行原型连接，关联到Foo.prototype上。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo()</div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === Foo.prototype <span class="comment">// true</span></div></pre></td></tr></table></figure></p><p>在面向对象的语言中，类可以被实例化多次，实例化一个类就意味着把类的行为复制到一个对象中，但是在JS中并没有类似的复制机制，你不能创建一个类的多个实例，只能创建多个对象，他们的[[Prototype]]关联到同一个对象上，因此在默认情况下，并不会发生复制，因此这些对象不会完全失去联系，他们是互相关联的。<br>但是事实上，我们可以认为new Foo()所创建的这个链接其实是一种副作用，他并非直接创建关联。更直接的方法时：<code>Object.create()</code></p><p>JS中我们并不会把一个对象（类）复制到另一个对象（实例）上，只是将他们关联起来，这个机制通常被称为原型继承，这个名称主要是为了应对面向类的语言中继承的意义，但是其实并没有表示出动态语言中对应的含义。也就是说，这里说到继承，其实算不上继承。这可能会让习惯于传统语言的开发者非常不习惯。</p><p>继承意味着复制操作，但JS默认并不会复制对象属性，只是会创建一个关联，这样一个对象可以通过<code>委托</code>来访问另一个对象的属性和函数，委托这个词更能准确描述JS中对象的关联机制。</p><p>回到之前的代码中，为神马会认为Foo是一个类呢？因为new。但是事实，JS中，对于构造函数最好的解释我认为应该是：所有带new的函数调用。除了这个迷惑人的东西之外，还有一个Prototype.constructor<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Foo.prototype.constructor===Foo <span class="comment">//true</span></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo()</div><div class="line">a.constructor === Foo <span class="comment">//true</span></div></pre></td></tr></table></figure></p><p>Foo.prototype默认会有一个不可枚举的constructor属性，这个属性引用的是与对象关联的函数（Foo），而a竟然也有一个constructor属性，指向”创建这个对象的函数“，可能你已经想到，实际上，这个.constructor是Foo.prototype的。</p><hr><p>未完待续。。<br>23：25</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;当我们在谈论原型时，我们在谈论什么？&quot;&gt;&lt;a href=&quot;#当我们在谈论原型时，我们在谈论什么？&quot; class=&quot;headerlink&quot; title=&quot;当我们在谈论原型时，我们在谈论什么？&quot;&gt;&lt;/a&gt;当我们在谈论原型时，我们在谈论什么？&lt;/h2&gt;&lt;h3 id=&quot;从
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我不知道的JavaScript&lt;三&gt;：this</title>
    <link href="http://stan1812.github.io/2018/07/15/dont-know-JS3/"/>
    <id>http://stan1812.github.io/2018/07/15/dont-know-JS3/</id>
    <published>2018-07-15T13:33:13.000Z</published>
    <updated>2018-07-16T08:43:14.974Z</updated>
    
    <content type="html"><![CDATA[<p>this可以说是在JS中相当复杂甚至有时可以说是“邪乎”的一个机制，他带来了很多便利，但有时侯会让人感到有些崩溃👽</p><p>今天就来梳理下this的部分。</p><h3 id="为什么要使用this"><a href="#为什么要使用this" class="headerlink" title="为什么要使用this?"></a>为什么要使用this?</h3><p>首先来看一段代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> greeting = <span class="string">"hello"</span>+ identify.call(<span class="keyword">this</span>);</div><div class="line">  <span class="built_in">console</span>.log(greeting)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> me = &#123;<span class="attr">name</span>:<span class="string">"Faker"</span>&#125;</div><div class="line"><span class="keyword">var</span> you = &#123;<span class="attr">name</span>:<span class="string">"Uzi"</span>&#125;</div><div class="line">identify(you) <span class="comment">// Uzi</span></div><div class="line">identify(me) <span class="comment">//Faker</span></div><div class="line"></div><div class="line">speak.call(me); <span class="comment">// hello Faker</span></div><div class="line">speak.call(you);<span class="comment">// hello Uzi</span></div></pre></td></tr></table></figure></p><p>这段代码在不同的上下文对象中重复使用了函数identify和speak，下面我们来看一下不使用this时候该怎么写：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params">context</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> context.name.toUpperCase()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">spaek</span>(<span class="params">context</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> greeting = <span class="string">"hello"</span>+ identify(context);</div><div class="line">  <span class="built_in">console</span>.log(greeting)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>显然，在不使用this的时候，需要显示的来传递上下文对象，this的引入使得对象引用传递的更加优雅。</p><h3 id="对this的误解"><a href="#对this的误解" class="headerlink" title="对this的误解"></a>对this的误解</h3><h4 id="this指向函数自身？"><a href="#this指向函数自身？" class="headerlink" title="this指向函数自身？"></a>this指向函数自身？</h4><p>若只是根据字面意思来说的话似乎this的意思就是这样，虽然可以使用函数来存储一些内容，但是this的机制并没有这么简洁。</p><p>首先还是来看例子<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.count++</div><div class="line">&#125;</div><div class="line">test.count = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">  test()</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(test.count) <span class="comment">// 0</span></div></pre></td></tr></table></figure></p><p>test.count并没有像我们所期望的那样输出5，而是输出了0，很显然这说明在函数执行的时候，this并没有指向Test函数，那么this到底指向哪里了呢？其实这里是指向的全局，在浏览器中即是window。当我们打印this.window的时候，你会发现他打印的又是NaN，这也不难解释，因为你并未初始化一个window下的count，undefined++自然就成了NaN。至于为什么在这里指向Window。我们稍后再谈</p><h4 id="this指向函数的作用域？"><a href="#this指向函数的作用域？" class="headerlink" title="this指向函数的作用域？"></a>this指向函数的作用域？</h4><p>其实我很长一段时间都是这么理解的。。👀因为我确实应用这个准则解释了一些问题。虽然之后发现解释得不是很合理。其实这样理解并不正确。这里其实混淆了一些概念。</p><p>这里可以指出：this在任何时候都不指向函数的词法作用域，在JS内部，作用确实和对象类似，可见的标识符都是它的属性，但是作用域对象并不能通过JS代码访问，它存在于引擎内部。</p><p>我们依然使用例子来说明问题：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a =<span class="number">2</span>;</div><div class="line">  <span class="keyword">this</span>.bar();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line">foo() <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p><p>这里在书中说到调用this.bar()不能成功，但是在浏览器环境中是可以成功的。bar挂载到了window上。当然这不是重点，重点在于这个代码想要使用this.a和this.bar连接foo的内部作用域。然后按照作用域查找，但这是不能实现的。</p><hr><p>以上，this既不指向函数自身，也不止像函数的词法作用域。实际上this是在函数调用时才发生的绑定，他指向哪里取决于函数在哪里调用。</p><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">foo()</div></pre></td></tr></table></figure><p>首先我们应该知道声明在全局作用域中的变量就是全局对象的一个同名属性，他们实际上就是同一个东西，并不是复制得到的。</p><p>我们来分析下代码，通过分析，foo的调用位置是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定。</p><p>如果使用严格模式的话，全局对象无法使用默认绑定，this将绑定到undefined</p><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>依然还是看代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a:<span class="number">2</span>,</div><div class="line">  foo:foo</div><div class="line">&#125;</div><div class="line">obj.foo() <span class="comment">//2</span></div></pre></td></tr></table></figure></p><p>首先注意到foo的声明方式，及其之后是如何被当作引用属性添加到obj中，但是无论是直接在obj中定义还是先定义再添加为引用属性，这个函数严格来说都不属于obj对象</p><p>然后，调用位置会使用obj上下文来引用函数，因此可以说，函数被调用的时候obj对象包含它。</p><p>当函数引用拥有上下文对象时，隐式绑定会把函数调用的this绑定到这个上下文对象，因为调用foo时this被绑定到obj所以this.a和obj.a相同。</p><p>对象属性引用链中只有最后一层会影响调用位置。<br>举个🎂</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  a:<span class="number">1</span>,</div><div class="line">  foo:foo</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj2=&#123;</div><div class="line">  a:<span class="number">2</span>,</div><div class="line">  obj1:obj1  </div><div class="line">&#125;</div><div class="line">obj2.obj1.foo()<span class="comment">// 1</span></div></pre></td></tr></table></figure><h5 id="隐式绑定丢失"><a href="#隐式绑定丢失" class="headerlink" title="隐式绑定丢失"></a>隐式绑定丢失</h5><p>隐式绑定丢失就是被隐式绑定的函数会丢失绑定对象，然后会应用默认绑定·将this绑定到全局对象或者undifined（取决于是否是严格模式）。来看一个这里的错误用法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a:<span class="number">1</span>,</div><div class="line">  foo:foo</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = obj.foo</div><div class="line"><span class="keyword">var</span> a = <span class="string">"2"</span></div><div class="line">bar() <span class="comment">// 2</span></div></pre></td></tr></table></figure></p><p>这段代码尝试使用obj.foo将this的绑定传递到bar的调用中，但实际上bar依然是一个对函数foo的引用，应用了默认绑定。</p><p>另一种更加常见的绑定丢失发生在传入回调函数的时候：这里看一个例子<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dofoo</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">  fn()</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj =&#123;</div><div class="line">  a:<span class="number">2</span>,</div><div class="line">  foo:foo</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a =<span class="number">1</span>;</div><div class="line">dofoo(obj.foo) <span class="comment">//1</span></div></pre></td></tr></table></figure></p><p>参数传递其实是一种隐式赋值，因此我们传入函数的时候也会被隐式复制，所以结果和上个例子相同。需要注意的是，如果把函数传入语言内置的函数结果也是相同</p><h4 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h4><p>在之前分析隐式绑定的时候，我们总是会构造一个对象，通过对象中的一个属性来间接引用函数，从而把this隐式的绑定到这个对象上。<br>如果不是用这种方法该如何做呢?</p><p>这里要提到两个非常有用的函数<code>call</code>和<code>apply</code></p><p>这两方法第一个参数是一个对象，他们会把这个对象绑定到this接着在调用函数时指向这个this，因此可以直接指定this的绑定对象因此也称作显示绑定。</p><p>依然是一个简单的小例子来直观表示一下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj =&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</div><div class="line">foo.call(obj) <span class="comment">//1</span></div></pre></td></tr></table></figure></p><p>call将this绑定到了obj上。<br>硬绑定的典型应用场景一种就是创建一个包裹函数传入所有的参数并且返回接受到的所有值：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something </span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + something </div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a: <span class="number">2</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> foo.apply(obj,<span class="built_in">arguments</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>)</div><div class="line"><span class="built_in">console</span>.log(b) <span class="comment">//5</span></div><div class="line"></div><div class="line"><span class="comment">// 我们可以稍加改动 创建一个可以重复使用的辅助函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">fn,obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> fn.apply(obj,<span class="built_in">arguments</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>硬绑定是一种非常常用的模式，所以ES5中也提供了<code>Function.prototype.bind()</code></p><h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><p>熟悉JS的同志们可能知道JS中的构造函数其实和传统面向对象语言的有非常大的不同，如果你认为他的构造函数和传统的语言一样那你可能对JS有什么误解。</p><p>JS中的new使用方法是和传统的那些面向对象语言类似的，但是他们的机制完全不同。事实上，JS中的构造函数可以说只是一个使用new操作符时被调用的函数，它并不属于某个类，也不会实例化某个类，实际上，他都算不上一个特殊的函数类型，他只是碰巧被new调用了一下而已。并不存在所谓的”构造函数“，只存在”构造调用“</p><p>在执行new的调用时，会执行以下的操作：</p><ul><li>构建一个全新的对象、</li><li>这个新对象会被执行原型连接</li><li>这个新对象绑定到函数调用的this</li><li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象</li></ul><p>我们这里暂时不关心第二步（之后也会详细梳理）</p><p>看个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>)</div><div class="line"><span class="built_in">console</span>.log(bar.a) <span class="comment">//2</span></div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"><span class="string">---</span></div><div class="line"><span class="string">### 绑定方式优先级</span></div><div class="line"><span class="string">默认绑定优先级自然是最低的，显示绑定也比隐式绑定的优先级要高，现在我们来分析下隐式绑定和new绑定的优先级级别</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span>javascript</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">some</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = some</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">foo</span>:foo&#125;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;&#125;</div><div class="line">obj1.foo(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(obj1.a) <span class="comment">//2</span></div><div class="line">obj1.foo.call(obj2,<span class="number">3</span>)</div><div class="line"><span class="built_in">console</span>.log(obj2.a) <span class="comment">//3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.foo(<span class="number">4</span>)</div><div class="line"><span class="built_in">console</span>.log(obj1.a) <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(bar.a) <span class="comment">//4</span></div></pre></td></tr></table></figure></p><p>可以看到new绑定的优先级高于隐式绑定</p><p>接下来我们来讨论一下new绑定和显示绑定的优先级问题，之前提到过，bind会创建一个新的函数这个函数会忽略他当前的this绑定(无论当前绑定对象是什么)并把提供的对象绑定到this上。但是事实上并不是完全这样。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = data</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;&#125;</div><div class="line"><span class="keyword">var</span> bar = foo.bind(obj1)</div><div class="line">bar(<span class="number">2</span>) <span class="comment">//obj1.a = 2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">1</span>)</div><div class="line"><span class="built_in">console</span>.log(obj1.a) <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(baz.a)  <span class="comment">//1</span></div></pre></td></tr></table></figure></p><p>可以看到<code>bar</code>被硬绑定到<code>obj1</code>上，但是<code>new bar(1)</code>并没有把obj1.a也修改为1而是使用了new绑定，得到了一个一个名字为baz的新对象。</p><p>似乎之前所写到的bind并没有提供改变this指向的功能，事实上bind函数所提供的实现当然要复杂的多，简单的说代码会判断硬绑定函数是否会被new调用，如果是的话就会用新创建的this替换绑定的this</p><h3 id="gt-中的this"><a href="#gt-中的this" class="headerlink" title="()=&gt;{}中的this"></a>()=&gt;{}中的this</h3><p>箭头函数的this不使用4种绑定规则，而是根据外层（函数或者全局）作用域来决定this,定义时候绑定<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a</span>)=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 =&#123; <span class="attr">a</span>:<span class="number">1</span>&#125;</div><div class="line"><span class="keyword">var</span> obj2 =&#123; <span class="attr">a</span>:<span class="number">2</span>&#125;</div><div class="line"><span class="keyword">var</span> bar = foo.call(obj1)</div><div class="line">bar.call(obj2) <span class="comment">//1</span></div></pre></td></tr></table></figure></p><p>foo内部的箭头函数会捕获调用时foo的this，由于foo的this绑定到obj1 ，bar的this也会绑定到obj1，箭头函数的绑定无法被修改（new也不行）</p><p>ES6中定义的时候绑定this的具体含义，应该继承的是父执行上下文里面的this，不是父执行上下文</p><p>简单来说类似于<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(self.a)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 =&#123; <span class="attr">a</span>:<span class="number">1</span>&#125;</div><div class="line"><span class="keyword">var</span> obj2 =&#123; <span class="attr">a</span>:<span class="number">2</span>&#125;</div><div class="line"><span class="keyword">var</span> bar = foo.call(obj1)</div><div class="line">bar.call(obj2) <span class="comment">//1</span></div></pre></td></tr></table></figure></p><hr><p>暂时写到这里<br>2018.7.16/16:43</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;this可以说是在JS中相当复杂甚至有时可以说是“邪乎”的一个机制，他带来了很多便利，但有时侯会让人感到有些崩溃👽&lt;/p&gt;
&lt;p&gt;今天就来梳理下this的部分。&lt;/p&gt;
&lt;h3 id=&quot;为什么要使用this&quot;&gt;&lt;a href=&quot;#为什么要使用this&quot; class=&quot;he
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我不知道的JavaScript&lt;二&gt;：闭包</title>
    <link href="http://stan1812.github.io/2018/07/13/dont-konw-JS2/"/>
    <id>http://stan1812.github.io/2018/07/13/dont-konw-JS2/</id>
    <published>2018-07-13T08:06:14.000Z</published>
    <updated>2018-07-15T12:42:24.947Z</updated>
    
    <content type="html"><![CDATA[<p>上篇梳理了作用域的相关基础知识，要理解闭包，作用域是相当重要的一环。闭包一直以来总是一个会出现些怪异问题的东西，之所以怪异是因为自己还是没有理解透彻，这次就来梳理一下闭包的相关问题。</p><p>闭包在JS中的地位可以说是相当重要的了，总是会在各种论坛博客上面看到各种前辈们所写的关于闭包的解析，自己也是似懂非懂，总以为自己懂了，然后偶然间突然想起来要问问自己却又说不出个所以然。所以现在就来系统的阐述一下。</p><h3 id="何为闭包"><a href="#何为闭包" class="headerlink" title="何为闭包"></a>何为闭包</h3><p>我们从前辈的总结中得到这样一个定义：当函数可以记住并且访问所在的词法作用域时，就产生了闭包，即使函数是在当前作用域之外执行。</p><p>先来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a) <span class="comment">//2</span></div><div class="line">  &#125;</div><div class="line">  bar()</div><div class="line">&#125; </div><div class="line">foo()</div></pre></td></tr></table></figure></p><p>这是一个闭包吗？</p><p>这段代码和之前嵌套作用域所使用的代码很类似，bar访问上级作用域并找到a，但是这和上面的定义似乎不是很完全贴合，有人说这属于一种闭包，有人说这并不算严格的闭包，这里我觉得，我们所关心的是闭包所带来的作用，而非是作为标准委员会来制作标准，所以这里不再争论。</p><p>再看下一个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> bar</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> baz = foo();</div><div class="line">baz() <span class="comment">//2</span></div></pre></td></tr></table></figure></p><p>这其实就是一个非常典型的闭包了。<br>来分析一下这段简单的代码的执行过程：<br>很显然，函数bar能够访问foo的内部作用域，然后foo将bar本身传递了出去，即bar函数作为返回值，中间的调用执行我们不再关注，需要注意的是，函数foo执行完毕后，其作用域是否有销毁？观察运行结果，我们发现是没有的，函数baz(其实也就是bar)在执行的时候并非在其定义时所在的词法作用域，但是他依然保留了foo内部作用域的引用，而这个引用，就叫做闭包。</p><p>这个函数在定义时词法作用域以外的地方被调用，闭包使得函数可以继续访问定义的词法作用域。且无论通过何手段将内部函数传递到其所在词法作用域以外，他都会保留对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包/</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>事实上，在实际写代码的时候我们可以发现闭包在代码中并不是一个陌生的东西，来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>)</span>&#123;</div><div class="line">  settimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;message&#125;,<span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line">wait(<span class="string">"hello"</span>)</div></pre></td></tr></table></figure></p><p>将一个内部函数timer传递给settimeout，timer具有涵盖wait(…)作用域的闭包，因此还保留有对变量message的引用<br>在wait执行1000ms后，他的内部作用于并不会消失，timer依然保留着wait作用域的闭包。<br>更深入的来说，从settimeout的异步运行机制我们可以知道，他会被送入macortask等待执行，settimeout会持有一个对参数的引用，也就是timer，函数会调用这个函数，也就是timer函数，词法作用域保持完整。</p><p>事实上，只要使用了回调函数，那么就在使用闭包。</p><h4 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h4><p>一般认为立即执行函数是典型的闭包例子，但是若以之前试图解释的定义来看，这似乎并非是一个无异议的闭包实例<br>举个🎂；<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">2</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(a)&#125;)()</div></pre></td></tr></table></figure></p><p>我们其实可以这样理解，首先，函数并非是在所定义的词法作用域之外执行，其次我们可以理解为函数在执行时向上级作用域（这里也是全局作用域）找到了a，只是通过了普通的词法作用域查找而非闭包中找到的。</p><p>但是正像之前所说的那样有不同的概念，他确实可以说是创建了闭包。因为他保存了自身的状态。</p><h4 id="闭包与循环"><a href="#闭包与循环" class="headerlink" title="闭包与循环"></a>闭包与循环</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">    settimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(i)&#125;,<span class="number">1000</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>依然是之前就提到过的一个问题，虽然之前已经解释过这里还是再放一下：<br>现在若要使用闭包解决：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">   (<span class="function">(<span class="params">i</span>)=&gt;</span> settimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(i),<span class="number">1000</span>))(i)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="闭包与模块设计"><a href="#闭包与模块设计" class="headerlink" title="闭包与模块设计"></a>闭包与模块设计</h4><p>在ES6的import export诞生之前，可以说模块的设计可能会直接接触最最典型的闭包应用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Moudle</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> something = <span class="string">"something"</span>;</div><div class="line">  <span class="keyword">var</span> somethingElse = <span class="string">"sometingElse"</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">saySomething</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(something)</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">saySomethingElse</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(somethingElse)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    saySomething:saySomething,</div><div class="line">    somethingElse:somethingElse</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是一个在之前可能会写的代码，他很直观地体现了闭包的作用。</p><p>当然这只是一个方便理解的demo，实际的使用中，这样是肯定不能用的。</p><p>但我们可以以此归纳出：</p><ol><li>为创建内部作用域而调用了一个包装函数</li><li>包装函数返回值必须至少包括一个对内部函数的引用，这样就会创建包含整个包装函数内部作用域的闭包。<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3></li></ol><p>我们现在来简要的总结一下：<br>可以说：当函数能够记住并访问所在的词法作用域时，即使函数在他的词法作用域之外执行，这事就产生了闭包。</p><hr><p>下篇来梳理下this</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇梳理了作用域的相关基础知识，要理解闭包，作用域是相当重要的一环。闭包一直以来总是一个会出现些怪异问题的东西，之所以怪异是因为自己还是没有理解透彻，这次就来梳理一下闭包的相关问题。&lt;/p&gt;
&lt;p&gt;闭包在JS中的地位可以说是相当重要的了，总是会在各种论坛博客上面看到各种前辈
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>我不知道的JavaScript&lt;一&gt;：作用域</title>
    <link href="http://stan1812.github.io/2018/07/12/dont-konw-js1/"/>
    <id>http://stan1812.github.io/2018/07/12/dont-konw-js1/</id>
    <published>2018-07-12T14:13:04.000Z</published>
    <updated>2018-07-15T12:42:36.181Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来对于JS总是有一些一知半解的东西，因为这个假期没有留校，也还没有去找实习，就当给自己一些“私人时间”来对之前不求甚解的东西来梳理一遍吧。</p><h3 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h3><p>所有语言都有作用域，这是一种语言的基本功能之一，就是能够存储变量的值，并且能够在之后对之进行访问和修改，也正是因为这种存储和访问变量的能力将<strong>状态</strong>带给了程序。要将变量引入程序就带来了相应的其他问题，怎么存，如何找到他们。相应的就需要一套规则来存储变量，并且之后可以方便的找到这些变量，这套规则就是作用域了。</p><h4 id="1-1-编译"><a href="#1-1-编译" class="headerlink" title="1.1 编译"></a>1.1 编译</h4><p>虽然JS是一门脚本语言，但是他也是一门“编译语言”，与传统C，JAVA等不同的是，他并非是提前编译的，而是在运行时进行编译（V8），JS的编译过程大概经过这几个过程：</p><ul><li>分词/词法分析（Tokenizing/Lexing）这个过程将字符串分解成对有意义的代码块，这些代码块被称为词法单元（Token）比如<code>var a = 1;</code> 这段代码会被分解为“var、a、=、1、；”</li><li>解析/语法分析（Parsing） 这个过程将词法单元流转换为一个由元素嵌套所构成的代表程序语法机构的抽象语法书（AST，Abstract Syntax Tree）</li><li>代码生成 AST树转化成可执行代码的过程。</li></ul><p>以上可以说是非常笼统概括的一个简单的编译过程，事实上，JS的编译解释过程要复杂得多，中间还要包括比如说在词法分析和代码生成阶段的特定处理步骤来对运行的性能、冗余元素进行优化等。很容易想到，因为JS的编译发生在你要运行代码前，所以引擎使用了各种方法来使编译速度能够提升上来。</p><h4 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h4><p> 既然作用域是根据名称查找变量的一套规则，那么在实际的使用中，就需要同时顾及几个作用域。</p><p> 当一个函数或块嵌套在另一个快或者函数中的时候，就发生了作用域的嵌套。因此，在当前的作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量（全局作用域为止）这其实也就是遍历嵌套作用域的规则。</p><p> 一个很简单的例子：<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a+b);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">foo(<span class="number">2</span>) <span class="comment">// 4</span></div></pre></td></tr></table></figure></p><p> 对b的RHS引用无法在函数foo内部完成，于是到上一层作用域中寻找</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>作用域有两种基本的工作模型：词法作用域和动态作用域。词法作用域较为普通，大多数语言都采用这种模式，而动态作用域则也仍有一些语言在使用。</p><h4 id="2-1-词法阶段"><a href="#2-1-词法阶段" class="headerlink" title="2.1 词法阶段"></a>2.1 词法阶段</h4><p>之前提到，大多数的语言编译器的第一个工作阶段叫做词法化，这也是词法作用域的名称来历的基础。</p><p>简单地说，词法作用域就是定义在词法阶段的作用域，也就是说，是由你在写代码的时候将代码放在哪里决定的，因此大部分情况下当词法分析器处理代码的时候会保持作用域不变。</p><p>来看一个例子；<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;            <span class="comment">// 1</span></div><div class="line">  <span class="keyword">var</span> b = a * <span class="number">2</span>;            <span class="comment">// 2</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a,b,c</span>)</span>&#123;      <span class="comment">// 3</span></div><div class="line">    <span class="built_in">console</span>.log(a,b,c);</div><div class="line">  &#125;</div><div class="line">  bar(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">&#125;</div><div class="line">foo(<span class="number">2</span>);</div></pre></td></tr></table></figure></p><p>我们把他理解为三层机构</p><ol><li>包含着全局作用域，只有一个标识符foo</li><li>包含着foo所创建的作用域，其中有 a  bar b</li><li>包含bar 创建的作用域， 只有c一个标识符</li></ol><p>现在暂时认为作用域尤其对应的代码块写在哪里决定，是逐级包含的</p><h4 id="2-2-查找"><a href="#2-2-查找" class="headerlink" title="2.2 查找"></a>2.2 查找</h4><p>作用域间的结构和位置关系给引擎提供了足够的位置信息，引擎使用这些信息来查找标识符的位置<br>作用域查找会在找到第一个匹配的标识符时停止，在多层的嵌套作用域中可以定义同名的标识符，这里叫作“遮蔽效应”</p><h4 id="2-3-欺骗词法"><a href="#2-3-欺骗词法" class="headerlink" title="2.3 欺骗词法"></a>2.3 欺骗词法</h4><p>既然词法作用域完全由函数的声明位置来决定，那么如何来在运行时改变词法作用域呢？<br>到了在众多风格指南中都会明令禁止使用的部分了:eval和with</p><ul><li><p>eval</p><p>eval接受一个字符串为参数，将其中的内容视为书写时就存在这个位置的代码。<br>也就是说，在进行词法分析的时候，eval内部的代码假装自己本来就在那里，而引擎也并不拆穿他，如常地进行词法作用域查找<br>看一个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str,a</span>)</span>&#123;</div><div class="line">  <span class="built_in">eval</span>(str);</div><div class="line">  <span class="built_in">console</span>.log(a,b);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">foo(<span class="string">"var b = 3;"</span>,<span class="number">1</span>) <span class="comment">//1,3</span></div></pre></td></tr></table></figure><p>这段代码所做的其实也就是在foo的作用域中创建了新的变量b，并遮蔽了外部的同名变量（严格模式下eval将拥有自己的词法作用域）</p></li><li><p>with<br>with通常被当作重复引用同一个对象的多个属性的快捷方式比如:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">  age: <span class="number">10</span>,</div><div class="line">  weight: <span class="number">40</span>,</div><div class="line">  height: <span class="number">1.5</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">with</span>(xiaoming)&#123;</div><div class="line">  age: <span class="number">12</span>,</div><div class="line">  weight: <span class="number">45</span>,</div><div class="line">  height: <span class="number">1.6</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是在with的使用过程中可能会：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">with</span>(obj)&#123;</div><div class="line">    a = <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">a</span>:<span class="number">3</span>&#125;</div><div class="line"><span class="keyword">var</span> o2 = &#123;<span class="attr">b</span>:<span class="number">3</span>&#125;</div><div class="line">foo(o1)  <span class="comment">// o1.a = 2</span></div><div class="line">foo(o2)  <span class="comment">// o2.a = undefined window.a = 2</span></div></pre></td></tr></table></figure><p>尽管with块可以将一个对象处理成词法作用域，但是这个块内声明的var并不会限制在这个块的作用域，而是被添加到with所处的函数作用域中。</p></li></ul><h3 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h3><h4 id="3-1函数作用域"><a href="#3-1函数作用域" class="headerlink" title="3.1函数作用域"></a>3.1函数作用域</h4><p>Javascript具有基于函数的作用域吗，这意味着每声明一个函数都会为其创建作用域<br>首先看个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line">bar(); <span class="comment">// bar is not defined</span></div><div class="line"><span class="built_in">console</span>.log(a,b,c) <span class="comment">// all failed</span></div></pre></td></tr></table></figure></p><p>函数作用域的含义是指：属于这个函数的全部变量都可以在整个函数的范围内使用和复用（嵌套作用域也可）</p><h4 id="3-2-隐藏内部实现"><a href="#3-2-隐藏内部实现" class="headerlink" title="3.2 隐藏内部实现"></a>3.2 隐藏内部实现</h4><p>在写代码的时候，我们一般会遵照最小特权或最小暴漏原则，即：在软件设计中，应最小限度的暴漏必要内容，而将其他内特容都隐藏起来。</p><p>这个原则可以引申到如何选择作用域来包含变量和函数。</p><p>简单地说，通常我们写代码是先声明一个函数再向里面加上代码，但是我们也经常做一些相反的事情，我们发现一段代码可以更加独立，于是我们抽出这段代码来封装成新的函数。其实就是将这些代码隐藏了，而结果就是，在这些代码的周围创建了新的作用域，可以说，把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。</p><h4 id="3-3-立即执行函数"><a href="#3-3-立即执行函数" class="headerlink" title="3.3 立即执行函数"></a>3.3 立即执行函数</h4><p>我们知道在代码外添加包装函数可以将内部的变量和函数“隐藏”起来，外部作用域无法访问包装函数内部的内容，但是很显然，这还需要一个函数名（将污染其所在作用域）并且还需显式调用函数才有效。上帝说要有立即执行函数于是就有了：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">2</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">  <span class="built_in">console</span>.log(a)</div><div class="line">  &#125;)();</div><div class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 2</span></div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;b()&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;)</div></pre></td></tr></table></figure><h4 id="3-4块作用域"><a href="#3-4块作用域" class="headerlink" title="3.4块作用域"></a>3.4块作用域</h4><p>先来一个非常简单的例子来引出块作用域：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i)&#125;,<span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">test()</div></pre></td></tr></table></figure></p><p>很可惜JavaScript直接来看的话并没有块级作用域，但是其实也是有的：</p><ol><li>with</li><li><p>try/catch<br>在ES3中，try/catch会创建一个块作用域，其中声明的变量只有catch内部有效</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">  <span class="literal">undefined</span>();</div><div class="line">&#125;<span class="keyword">catch</span>(err)&#123;<span class="built_in">console</span>.log(err)&#125;</div><div class="line"><span class="built_in">console</span>.log(err)<span class="comment">//  err not defined</span></div></pre></td></tr></table></figure></li><li><p>ES6的出现改变了这一乱象，let const关键字可以将变量绑定到任意作用域上，也就是说，let为其声明得的变量隐式的附加在了一个已经存在的块级作用域上。</p><h4 id="3-5变量提升"><a href="#3-5变量提升" class="headerlink" title="3.5变量提升"></a>3.5变量提升</h4><p>Javascript的代码并不完全按照从上到下执行</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 1</span></div><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log(a) <span class="comment">//2</span></div><div class="line"></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(a) <span class="comment">//undefined</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div></pre></td></tr></table></figure></li></ol><p>变量和函数的声明都会在代码执行之前被处理</p><p>比如<code>var a = 2</code>解释器会将其认为是两段代码<code>var a</code> <code>a = 2</code>,首先是声明，其后是赋值，定义声明是在编译阶段进行的，赋值会留在原地等待执行阶段。</p><p>也就是说：2中的代码的执行顺序是这样的：<code>var a ;console.loe(a); a = 2</code></p><p>这个过程好像变量和函数声明被移动到了最上面，这就叫_<em>提升</em></p><ul><li><p>函数会被提升但函数表达式不会被提升：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">foo() <span class="comment">// success</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">foo() <span class="comment">// TypeError</span></div><div class="line"><span class="keyword">var</span> foo =<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></li><li><p>函数优先</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">foo() <span class="comment">// 1</span></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  cosnole.log(<span class="number">2</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>先写到这里，下一篇将对闭包来进行梳理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直以来对于JS总是有一些一知半解的东西，因为这个假期没有留校，也还没有去找实习，就当给自己一些“私人时间”来对之前不求甚解的东西来梳理一遍吧。&lt;/p&gt;
&lt;h3 id=&quot;一、作用域&quot;&gt;&lt;a href=&quot;#一、作用域&quot; class=&quot;headerlink&quot; title=&quot;一、
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>从头实现一个mini Redux</title>
    <link href="http://stan1812.github.io/2018/06/14/mini-redux/"/>
    <id>http://stan1812.github.io/2018/06/14/mini-redux/</id>
    <published>2018-06-14T14:58:28.000Z</published>
    <updated>2018-06-14T15:00:26.833Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
      <category term="React" scheme="http://stan1812.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>JS的内存管理</title>
    <link href="http://stan1812.github.io/2018/06/06/JS-memary-mannager/"/>
    <id>http://stan1812.github.io/2018/06/06/JS-memary-mannager/</id>
    <published>2018-06-06T04:10:57.000Z</published>
    <updated>2018-06-06T05:02:47.014Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS中的内存模型"><a href="#JS中的内存模型" class="headerlink" title="JS中的内存模型"></a>JS中的内存模型</h3><h4 id="JS基本类型与栈"><a href="#JS基本类型与栈" class="headerlink" title="JS基本类型与栈"></a>JS基本类型与栈</h4><p>JS基本类型已经很清楚了：null、undefined、String、Number、Boolean</p><p>JS中的这些基础类型，有固定的大小，一般会保存在栈中（闭包除外），由系统自动分配内存空间，基础数据类型都是按值访问。</p><h4 id="JS引用类型与堆"><a href="#JS引用类型与堆" class="headerlink" title="JS引用类型与堆"></a>JS引用类型与堆</h4><p>其他语言不同，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JS不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以粗浅地理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联。</p><h3 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h3><p> JS环境中分配的内存一般有如下生命周期：</p><ul><li>内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存</li><li>内存使用：即读写内存，也就是使用变量、函数等</li><li>内存回收：使用完毕，由垃圾回收自动回收不再使用的内存</li></ul><p>在所有语言中第一和第二部分都很清晰。最后一步在底层语言中很清晰，但是在像JavaScript 等上层语言中，这一步是隐藏的、透明的。</p><p>分配和内存使用部分不再说了</p><h4 id="内存的回收"><a href="#内存的回收" class="headerlink" title="内存的回收"></a>内存的回收</h4><p>大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。</p><p>高级语言解释器嵌入了“垃圾回收器”，来跟踪内存的分配和使用，当分配的内存不再使用时，自动释放它。但是这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>JS中目前有两种垃圾回收的比较通用的算法</p><h4 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h4><p>这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123; </div><div class="line">  a: &#123;</div><div class="line">    b:<span class="number">2</span></div><div class="line">  &#125;</div><div class="line">&#125;; </div><div class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></div><div class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// o2变量是第二个对“这个对象”的引用</span></div><div class="line"></div><div class="line">o = <span class="number">1</span>;      <span class="comment">// 现在，“这个对象”的原始引用o被o2替换了</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> oa = o2.a; <span class="comment">// 引用“这个对象”的a属性</span></div><div class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></div><div class="line"></div><div class="line">o2 = <span class="string">"yo"</span>; <span class="comment">// 最初的对象现在已经是零引用了</span></div><div class="line">           <span class="comment">// 他可以被垃圾回收了</span></div><div class="line">           <span class="comment">// 然而它的属性a的对象还在被oa引用，所以还不能回收</span></div><div class="line"></div><div class="line">oa = <span class="literal">null</span>; <span class="comment">// a属性的那个对象现在也是零引用了</span></div><div class="line">           <span class="comment">// 它可以被垃圾回收了</span></div></pre></td></tr></table></figure></p><p>限制：循环引用</p><p>该算法有个限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</div><div class="line">  o.a = o2; <span class="comment">// o 引用 o2</span></div><div class="line">  o2.a = o; <span class="comment">// o2 引用 o</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">"boom!"</span>;</div><div class="line">&#125;</div><div class="line">f();</div></pre></td></tr></table></figure></p><h5 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h5><p>IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄漏：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> div;</div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  div = <span class="built_in">document</span>.getElementById(<span class="string">"myDivElement"</span>);</div><div class="line">  div.circularReference = div;</div><div class="line">  div.lotsOfData = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).join(<span class="string">"*"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>在上面的例子里，myDivElement 这个 DOM 元素里的 circularReference 属性引用了 myDivElement，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 lotsOfData 属性)，而这个数据占用的内存将永远不会被释放。</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>现代的浏览器已经不再使用引用计数算法了。现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。</p><p>标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。</p><p>从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。但反之未必成立。</p><p>根据这个概念，上面的例子可以正确被垃圾回收处理了。当div与其时间处理函数不能再从全局对象出发触及的时候，垃圾回收器就会标记并回收这两个对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JS中的内存模型&quot;&gt;&lt;a href=&quot;#JS中的内存模型&quot; class=&quot;headerlink&quot; title=&quot;JS中的内存模型&quot;&gt;&lt;/a&gt;JS中的内存模型&lt;/h3&gt;&lt;h4 id=&quot;JS基本类型与栈&quot;&gt;&lt;a href=&quot;#JS基本类型与栈&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Serious JavaScript</title>
    <link href="http://stan1812.github.io/2018/04/23/seriouslyJavascript/"/>
    <id>http://stan1812.github.io/2018/04/23/seriouslyJavascript/</id>
    <published>2018-04-23T05:43:08.000Z</published>
    <updated>2018-04-23T06:23:35.420Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，JavaScript是一门非常严谨的语言。</p><p>比如：<br><!-- ```javascript0 == "0" // true0 == []  // true//so =>"0" == [] // ?// false``` --></p><p><img src="/imgs/seriousJS/carbon.png" alt=""></p><!-- ```javascriptparseInt(0.000001)  // # => 0parseInt(0.0000001) // # => 1``` --><p><img src="/imgs/seriousJS/carbon1.png" alt=""></p><!-- ```javascriptconsole.log([1] + [1]) //11console.log([1] + [1] - [1]) //10``` --><p><img src="/imgs/seriousJS/carbon2.png" alt=""></p><!-- ```javascriptlet bool = new Boolean(false)if(bool)  console.log("JS is amazing")  // JS is amazing``` --><p><img src="/imgs/seriousJS/carbon3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;众所周知，JavaScript是一门非常严谨的语言。&lt;/p&gt;
&lt;p&gt;比如：&lt;br&gt;&lt;!-- 
```javascript
0 == &quot;0&quot; // true
0 == []  // true
//so =&gt;
&quot;0&quot; == [] // ?
// false
``` --&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 枚举类型的一些理解</title>
    <link href="http://stan1812.github.io/2018/04/14/javaEnum/"/>
    <id>http://stan1812.github.io/2018/04/14/javaEnum/</id>
    <published>2018-04-13T16:15:20.000Z</published>
    <updated>2018-04-14T09:28:26.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说点废话"><a href="#说点废话" class="headerlink" title="说点废话"></a>说点废话</h3><p>  在开始学习JAVA之后，写习惯了Javascript的我，首先意识到的是好繁琐，比如在接触JAVA中的枚举类型之后，这在JS中想要实现重写一些方法，以及其他一些类似的效果其实从语法上来讲要简单的不少，虽然Javascript最初是JS之父用了10多天写出了的，甚至有一一部分直接抄的JAVA比如Date类，（虽然抄来的Date一直被吐槽不好用，好像打算要重写？）</p><p>  甚至连起名字都是为了蹭一波JAVA的名气。并且面向对象的实现方式也截然不同，一个是纯正的基于对象的继承，另一个是基于原型链的继承。甚至有人调侃真的OOP和假的OOP。。</p><p>  不过虽然实现方式不一样，但是一些设计思想感觉还是类似的，之前总有人说JAVA和Javascript的区别就是斑马和斑马线的区别，现在来想一想其实这两种语言还是类似的地方的，尤其是在ES6中的Class出现之后，Class ，extends 等等语法糖的出现，给人感觉更像了///可能JS作为一个一开始并不被看好的语言随着应用范围越来越广，使用JS、构建的项目也越来越大，想要变得更牛逼似乎有一种更适合于工程化的东西出现了吧。</p><h3 id="JAVA的枚举类型"><a href="#JAVA的枚举类型" class="headerlink" title="JAVA的枚举类型"></a>JAVA的枚举类型</h3><p>先来举个最常用的栗子🎂 ：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Colors &#123;</div><div class="line">  RED,BLUE,BLACK,YELLOW,GREEN;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 简单调用：Colors.RED</span></div></pre></td></tr></table></figure></p><p>这是最基本的使用方法。但是其实并没有展现出JAVA的枚举类型的用途，有点人才埋没。</p><p>再举一个目前用的比较多的一种使用方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Tips &#123;</div><div class="line">  WIN(<span class="string">"you win"</span>),LOSE(<span class="string">"you lose"</span>);</div><div class="line">  <span class="keyword">private</span> String tip;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Tips</span><span class="params">(String tip)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.tip = tip;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.tip;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">System.out.println(Tips.WIN)</div><div class="line"><span class="comment">// you win</span></div></pre></td></tr></table></figure><p>在这段代码中，我们简单的保存了一些基本的提示信息,重写tostring方法,这在JS里面其实可以说是很常见了，不同的是修改的原型链上的方法，不禁感到非常亲切。</p><p>在看到这种用法之后，很疑惑，WIN和LOSE，看起来很像是一个函数，但是很不理解在初始化的时候到底是怎么操作的，以至于认为在调用的时候是调用的一个名为WIN的方法，于是就反编译了编译生成的class文件：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">➜  src javap Tips.class</div><div class="line">Compiled from <span class="string">"Tips.java"</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Tips</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Tips</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tips WIN;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tips LOSE;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Tips[] values();</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tips <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</div><div class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</div><div class="line">  <span class="keyword">static</span> &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在看到了反编译的文件之后才算明白，所创建的枚举类型实例（且为final类型）继承自Java的Enum类，<br>而在内部的编译中，其实是遍历生成以所写内容命名的Tips类的实例，且生成的实例就能为final类型，不可继承，因为是static类型由Tips类所属，所以可以直接调用，比如：<code>Tips.WIN</code>.<br>因为重写了构造方法Tips(),并声明了私有变量tip，所以在生成实例的时候，初始化各个实例的tip为所传入的内容。然后重写toString方法，在调用的时候，返回tip。效果就是实现了，当然重写类的toString方法可能一般并不提倡，以为在JS里面也同样是要避免污染原型链的，这里应该是类似的。</p><p>由于WIN（以WIN为例）实质上是Tips类的一个static的对象，为全局共有,当然可以给其创建封装新的接口，比如，<br>比如：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTip</span> <span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.tip;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>需要注意的一点是，这个getTip方法是属于实例的还是属于class的？也就是说他是类方法还是实例方法？<br>再来反编译一下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">➜  src javap Tips.class</div><div class="line">Compiled from <span class="string">"Tips.java"</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Tips</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Tips</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tips WIN;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tips LOSE;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Tips[] values();</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tips <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</div><div class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</div><div class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getTip</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</div><div class="line">  <span class="keyword">static</span> &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为在JS里构造函数中所写的方法，是属于实例的，即每初始化一个实例对象就会重新声明一个属于该对象的重名方法。浪费了内存。想要使其共享，就要将函数写到prototype上，所以在这里想了一下，不过在查了一些东西之后发现，这里的方法，即使并未写在构造函数里面，只要是非静态方法其就是实例方法。。似乎在JS和JAVA中，构造函数的概念及作用并不完全相同。与JS中使用工厂模式初始化的对象相比，JAVA中的类与JS的构造函数来对比更为合适一些。</p><h3 id="Enum抽象类常见方法"><a href="#Enum抽象类常见方法" class="headerlink" title="Enum抽象类常见方法"></a>Enum抽象类常见方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">返回类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">compareTo(E o)</td><td style="text-align:left">int</td><td style="text-align:left">比较此枚举与指定对象的顺序</td></tr><tr><td style="text-align:left">equals(Object other)</td><td style="text-align:left">boolean</td><td style="text-align:left">当指定对象等于此枚举常量时，返回 true。</td></tr><tr><td style="text-align:left">name()</td><td style="text-align:left">String</td><td style="text-align:left">返回此枚举常量的名称，在其枚举声明中对其进行声明</td></tr><tr><td style="text-align:left">ordinal()</td><td style="text-align:left">int</td><td style="text-align:left">返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零）</td></tr><tr><td style="text-align:left">toString()</td><td style="text-align:left">String</td><td style="text-align:left">返回枚举常量的名称，它包含在声明中</td></tr><tr><td style="text-align:left">getDeclaringClass()</td><td style="text-align:left">Class&lt;?&gt;</td><td style="text-align:left">返回与此枚举常量的枚举类型相对应的 Class 对象</td></tr></tbody></table><p>大概就是这样叭🚀</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;说点废话&quot;&gt;&lt;a href=&quot;#说点废话&quot; class=&quot;headerlink&quot; title=&quot;说点废话&quot;&gt;&lt;/a&gt;说点废话&lt;/h3&gt;&lt;p&gt;  在开始学习JAVA之后，写习惯了Javascript的我，首先意识到的是好繁琐，比如在接触JAVA中的枚举类型之后，这在
      
    
    </summary>
    
    
      <category term="JAVA" scheme="http://stan1812.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊前端各种宽高左右</title>
    <link href="http://stan1812.github.io/2018/04/13/heightInHtml/"/>
    <id>http://stan1812.github.io/2018/04/13/heightInHtml/</id>
    <published>2018-04-13T15:35:18.000Z</published>
    <updated>2018-04-23T06:23:28.343Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>之前对DOM接口中各种height，height，scrollHeight，clientHeight，clientWidth等等概念有大概的了解，但是在想理清其概念的时候却发现了挺多的问题，概念有些模糊，在翻了写文档做了些测试之后来写一篇总结。</p><h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">offset</th><th style="text-align:left">scroll</th><th style="text-align:left">client</th></tr></thead><tbody><tr><td style="text-align:left">Height</td></tr><tr><td style="text-align:left">Left</td></tr><tr><td style="text-align:left">Top</td></tr><tr><td style="text-align:left">Width</td></tr></tbody></table><h4 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h4><ul><li><p>offsetleft:margin  + padding</p></li><li><p>offsettop:margin + padding;</p></li><li><p>offsetwidth:本身的宽度+内边距左右+边框左右;</p></li><li><p>offsetHeight:same</p><h4 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h4></li><li><p>Element.scrollHeight :只读,指一个元素内容高度，包括由于溢出导致的视图中不可见内容。没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同。包括元素的padding，但不包括元素的border和margin。scrollHeight也包括 ::before 和 ::after这样的伪元素。</p></li><li><p>Element.scrollTop: 可写 ,获取或设置一个元素的内容垂直滚动的像素数。一个元素的 scrollTop 值是这个元素的顶部到它的最顶部可见内容（的顶部）的距离的度量。当一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为0。如果一个元素不能被滚动（例如，它没有溢出，或者这个元素有一个”non-scrollable”属性）， scrollTop将被设置为0。设置scrollTop的值小于0，scrollTop 被设为0.如果设置了超出这个容器可滚动的值, scrollTop 会被设为最大值.</p></li><li><p>Element.scrollLeft 与xxtop类似</p></li><li><p>Element.scrollwidth：内容区域尺寸加上内边距加上溢出尺寸，当内容正好和内容区域匹配没有溢出时，这些属性与clientWidth和clientHeight相等</p></li></ul><h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><ul><li><p>element.clientHeight:只读，对于没有定义CSS或者内联布局盒子的元素为0，同时它是元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距。clientHeight 可以通过 CSS height + CSS padding- 水平滚动条高度 (如果存在)来计算.</p></li><li><p>clientleft:元素的内边距的外边缘和边框的外边缘的距离，实际就是边框的左边框宽度</p></li><li><p>clienttop:同理边框的上边框的宽度</p></li><li><p>clientwidth:用于描述元素内尺寸宽度，是指 元素内容+内边距 大小，不包括边框、外边距、滚动条部分</p></li></ul><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><p>无限加载：element.scrollHeight - element.scrollTop === element.clientHeight</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;之前对DOM接口中各种height，height，scrollHeight，clientHeight，clientWidth等等概念有大概的
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
      <category term="HTML" scheme="http://stan1812.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>小程序&lt;宜墨&gt;开发小记</title>
    <link href="http://stan1812.github.io/2018/02/14/LearnKoa/"/>
    <id>http://stan1812.github.io/2018/02/14/LearnKoa/</id>
    <published>2018-02-14T08:44:33.000Z</published>
    <updated>2018-04-23T06:25:01.482Z</updated>
    
    <content type="html"><![CDATA[<p>在今天这个特别的日子，我，一个单身狗，感觉自己浑身散发着清香。</p><p>但是在今天，回到家就重度拖延症的我也算是终于完成了自己的第一个微信小程序的完整开发。一个想要写给妈妈的小程序。</p><p>先来说下技术栈吧：<br><figure class="highlight xl"><table><tr><td class="code"><pre><div class="line">前端：</div><div class="line">    微信小程序</div><div class="line">后端(restful api)：</div><div class="line">    <span class="built_in">NodeJS</span></div><div class="line">    koa2</div><div class="line">    monk</div><div class="line">    mongodb</div><div class="line">    corntab</div><div class="line">    PM2</div></pre></td></tr></table></figure></p><p>至于设计和产品嘛。。当然也是我啊（滑稽🙈）</p><p>小程序在之前已经大概的说过一点，这次说下后台的一些东西。</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据来源于一个app “观之”（原每日一读），在拿到他的接口之后，本来是可以直接拿来用就不用写后台，但是打算在微信上架，担心会有侵权的一些问题，期间也咨询了几个学法律的同学，但是得到的最终答案是，这个东西很模糊。于是为了避免麻烦，我决定把先写个爬虫把数据爬一下，因为内容都是各种各种杂文，所以也就不用担心侵权的问题了。</p><p>这个爬虫应该可以说是最简单的爬虫了，上去就是干，node一把梭，经过调试就开始爬，很快就爬到了从今年到2012年左右的数据，差不多够了。然后还就是使用corntab加一个定时任务，每天零点定时抓取更新的内容，存进mongodb。</p><h3 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h3><p>寒假看了一些koa的东西，然后就决定使用koa。刚开始看koa的时候着实被koa的开放吓了一跳，项目目录完全自己按需搭建。</p><p>虽然有一些开发者所搭建的generator但是为了把握一下整个的结构所以就自己搭建了项目结构:</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[root@VM_56_194_centos Wechat-BE]<span class="comment"># tree -L 1</span></div><div class="line">.</div><div class="line">|-- app.js</div><div class="line">|-- controller.js</div><div class="line">|-- controllers</div><div class="line">|-- ecosystem.config.js</div><div class="line">|-- node_modules</div><div class="line">|-- package.json</div><div class="line">`-- readme.md</div></pre></td></tr></table></figure><p>具体的技术细节的话代码地址在此<a href="https://github.com/Stan1812/Wechat-BE" target="_blank" rel="external">https://github.com/Stan1812/Wechat-BE</a></p><p>部署到服务器，然后使用PM2做进程守护。开始提供服务</p><p>现在koa只是基本的使用，开学之后学习深入些再写koa的相关东西</p><h3 id="monk"><a href="#monk" class="headerlink" title="monk"></a>monk</h3><p>monk感觉是在小项目中很好用的一个node连接mongodb的工具，相比mongose轻便精巧很多，正如他的简介“A tiny layer that provides simple yet substantial usability improvements for MongoDB usage within Node.JS.”<br>留个地址吧，官网：<a href="https://automattic.github.io/monk/" target="_blank" rel="external">https://automattic.github.io/monk/</a></p><hr><p>溜了溜了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在今天这个特别的日子，我，一个单身狗，感觉自己浑身散发着清香。&lt;/p&gt;
&lt;p&gt;但是在今天，回到家就重度拖延症的我也算是终于完成了自己的第一个微信小程序的完整开发。一个想要写给妈妈的小程序。&lt;/p&gt;
&lt;p&gt;先来说下技术栈吧：&lt;br&gt;&lt;figure class=&quot;highlig
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
      <category term="NodeJS" scheme="http://stan1812.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序之不完全胡乱指东西南北</title>
    <link href="http://stan1812.github.io/2018/01/24/wechatapp/"/>
    <id>http://stan1812.github.io/2018/01/24/wechatapp/</id>
    <published>2018-01-24T13:37:33.000Z</published>
    <updated>2018-04-23T06:24:32.486Z</updated>
    
    <content type="html"><![CDATA[<p>今天考完了试，很开心，晚上没什么事，来写篇博客。</p><h3 id="先吹吹水"><a href="#先吹吹水" class="headerlink" title="先吹吹水"></a>先吹吹水</h3><p>在期末考试之前的某段时间，差不多就是跳一跳火的那段时间吧，由于无聊，去微信公众平台注册了一个账号，然后就对着文档开始了小程序的玩耍之路。之前虽然小程序挺火的，但是也一直没有什么兴趣去看。。主要还是感觉限制太多了叭，个人总感觉小程序，毕竟还是微信一家的东西。像我这种菜鸡也就玩一玩叭。</p><p>之前看到过一个有点火的小程序，是一个显示手机信息的小工具，就是比如手机的内存啊，型号什么的信息，然后就有了好几万的用户，然后在我看了小程序的文档之后发现了一个这样的API<code>wx.getSystemInfo(OBJECT)</code>。基本上就是这个API了叭。。选对了目标用户真的是能飞。</p><h3 id="开放的API"><a href="#开放的API" class="headerlink" title="开放的API"></a>开放的API</h3><p>小程序所开放的能力感觉还是很强的，非常方便的就能调用手机的各种接口，文件，设备，包括GPS，网络状态，罗盘等，甚至对于剪切板这个东西，浏览器出于安全考虑一直不肯完全放开权限，要写各种hack的东西，微信也提供了很好的封装<code>wx.getClipboardData(OBJECT)</code> <code>wx.setClipboardData(OBJECT)</code>，这是微信有点大胆？（也可能是我多想了）不错。</p><p>除此之外，小程序的媒体能力也很丰富，录音，视频，相机，甚至实时音视频接口都有提供。对于我们这种辣鸡开发者确实是些可玩性很强的东西。</p><p>网络方面，除了常规的request，还提供了websocket的接口，确实是很周到。然后也开放了设置导航条，tabBar，置顶信息的API，给了更大的客户定制能力。</p><p>至于API，其他的不多说了。文档说的不能再清楚了。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><h4 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h4><ul><li>.json  JSON 配置文件(package.json)</li><li>.wxml  WXML 模板文件(.html/.vue)</li><li>.wxss  WXSS 样式文件</li><li>.js    JS 脚本逻辑文件<h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4>这是我写的一小demo</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[root@VM_56_194_centos wechat_demo]<span class="comment"># tree -L 2</span></div><div class="line">.</div><div class="line">|-- app.js </div><div class="line">|-- app.json //当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等</div><div class="line">|-- app.wxss</div><div class="line">|-- main.js</div><div class="line">|-- main.json</div><div class="line">|-- main.wxml</div><div class="line">|-- pages</div><div class="line">|   |-- artlist</div><div class="line">|   |   |-- list.js</div><div class="line">|   |   |-- list.json</div><div class="line">|   |   |-- list.wxml</div><div class="line">|   |   `-- list.wxss</div><div class="line">|   |-- index</div><div class="line">|   |   |-- index.js</div><div class="line">|   |   |-- index.wxml</div><div class="line">|   |   `-- index.wxss</div><div class="line">|   `-- logs</div><div class="line">|       |-- logs.js</div><div class="line">|       |-- logs.json</div><div class="line">|       |-- logs.wxml</div><div class="line">|       `-- logs.wxss</div><div class="line">|-- project.config.json</div><div class="line">|-- README.md</div><div class="line">|-- utils</div><div class="line">|   `-- util.js</div><div class="line">`-- wxParse</div><div class="line">    |-- emojis</div><div class="line">    |-- html2json.js</div><div class="line">    |-- htmlparser.js</div><div class="line">    |-- showdown.js</div><div class="line">    |-- wxDiscode.js</div><div class="line">    |-- wxParse.js</div><div class="line">    |-- wxParse.wxml</div><div class="line">    `-- wxParse.wxss</div></pre></td></tr></table></figure><p>这是一个每日一文的小东西，每天随机推荐一片文章。</p><p>其实结构还是很清晰的。。wxparse是一个解析HTML的工具，因为获取的文章数据是带html标签的，需要解析，但是小程序没有像V-html这样舒服东西，所以要找其他的工具，但是使用起来需要直接把文件手动复制到目录下，没有开放的包管理器，可能这就是相对比较封闭的一些劣势吧。</p><h3 id="大概思想"><a href="#大概思想" class="headerlink" title="大概思想"></a>大概思想</h3><p>依然是如今最火的MVVM思想，数据驱动，挺多地方和Vue还是很像的，要想上手做些demo还是挺快的。基本是都是常见的数据绑定，然后各种 <strong>钩子函数</strong>。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 页面的初始数据</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  data: &#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面加载</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onLoad: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面初次渲染完成</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onReady: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面显示</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onShow: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面隐藏</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onHide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面卸载</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onUnload: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 页面相关事件处理函数--监听用户下拉动作</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onPullDownRefresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 页面上拉触底事件的处理函数</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onReachBottom: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 用户点击右上角分享</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onShareAppMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>还是比较容易理解的。</p><p>组件之间的通信，数据管理，应该是相对来说比较重要的东西了。但是文档中没有提太多，然后这里有一篇比较好的文章：<img src="https://segmentfault.com/a/1190000008895441" alt="https://segmentfault.com/a/1190000008895441"><br>比较容易想到的是，最粗暴的，使用localStorage，简单粗暴。然后比较好的方法应该是使用<code>globalData</code>来处理吧。<br>深一点的其他东西还讨论不来，就先这样吧~</p><p>溜了溜了睡觉睡觉，明天回家！！！🍭</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天考完了试，很开心，晚上没什么事，来写篇博客。&lt;/p&gt;
&lt;h3 id=&quot;先吹吹水&quot;&gt;&lt;a href=&quot;#先吹吹水&quot; class=&quot;headerlink&quot; title=&quot;先吹吹水&quot;&gt;&lt;/a&gt;先吹吹水&lt;/h3&gt;&lt;p&gt;在期末考试之前的某段时间，差不多就是跳一跳火的那段时间吧，由
      
    
    </summary>
    
    
      <category term="技术" scheme="http://stan1812.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>初探parcel📦</title>
    <link href="http://stan1812.github.io/2018/01/13/parcel/"/>
    <id>http://stan1812.github.io/2018/01/13/parcel/</id>
    <published>2018-01-13T09:32:37.000Z</published>
    <updated>2018-04-23T06:24:48.917Z</updated>
    
    <content type="html"><![CDATA[<p>在期末复习的一个难受的下午，也就是现在，我突然想起了之前看到的号称零配置且最快的前端打包神器：Parcel，于是我放下数字逻辑。准备看看这货到底什么样。</p><p>github地址：<a href="https://github.com/parcel-bundler/parcel" target="_blank" rel="external">https://github.com/parcel-bundler/parcel</a></p><p>首先想要吐槽一下。。Parcel图标确实是不怎么好看哈哈。一个纸箱子。。不过可以说是直接了当的展示出了他的功能。打包嘛。</p><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>先来官网瞅一瞅（说的确实挺厉害的）</p><blockquote><p>🚀 极速打包时间<br>Parcel 使用 worker 进程去启用多核编译。同时有文件系统缓存，即使在重启构建后也能快速再编译。</p><p>📦 将你所有的资源打包<br>Parcel 具备开箱即用的对 JS, CSS, HTML, 文件 及更多的支持，而且不需要插件。</p><p>🐠 自动转换<br>如若有需要，Babel, PostCSS, 和PostHTML甚至 node_modules 包会被用于自动转换代码.</p><p>✂️ 零配置代码分拆<br>使用动态 import() 语法, Parcel 将你的输出文件束(bundles)分拆，因此你只需要在初次加载时加载你所需要的代码。</p><p>🔥 热模块替换<br>Parcel 无需配置，在开发环境的时候会自动在浏览器内随着你的代码更改而去更新模块。</p><p>🚨 友好的错误日志<br>当遇到错误时，Parcel 会输出 语法高亮的代码片段，帮助你定位问题</p></blockquote><p>官网还提供了这样一个比较</p><table><thead><tr><th style="text-align:left">打包工具</th><th style="text-align:left">时间</th></tr></thead><tbody><tr><td style="text-align:left">browserify</td><td style="text-align:left">22.98s</td></tr><tr><td style="text-align:left">webpack</td><td style="text-align:left">20.71s</td></tr><tr><td style="text-align:left">parcel</td><td style="text-align:left">9.98s</td></tr><tr><td style="text-align:left">parcel - with cache</td><td style="text-align:left">2.64s</td></tr></tbody></table><blockquote><p>基于一个合理大小的应用，包含1726个模块， 6.5M 未压缩大小. 在一台有4个物理 CPU 的 2016 MacBook Pro 上构建。</p></blockquote><p>相比的话，确实是相当的快，而且二次打包简直要起飞。。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">先安装（当然你也可以使用yarn）</div><div class="line">mkdir parceltest &amp;&amp; <span class="built_in">cd</span> parceltest &amp;&amp; npm install parcel-bundler --save</div></pre></td></tr></table></figure><p>文档中说的是Parcel 可以使用任何类型的文件作为入口，但是最好还是使用 HTML 或 JavaScript 文件。如果在 HTML 中使用相对路径引入主要的 JavaScript 文件，Parcel 也将会对它进行处理将其替换为相对于输出文件的 URL 地址。</p><p>然后，创建一个 index.html 和 index.js 文件。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">touch index.html &amp;&amp; touch index.js</div></pre></td></tr></table></figure></p><p>index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p>index.js<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"hello parcel"</span>);</div></pre></td></tr></table></figure></p><p>Parcel 内置了一个当你改变文件时能够自动重新构建应用的开发服务器，而且为了实现快速开发，该开发服务器支持热模块替换。在package.json指出即可：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="string">"scripts"</span>:&#123;</div><div class="line">  <span class="string">"start"</span>:<span class="string">"parcel index.html"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后，npm start<br>现在在浏览器中打开 <a href="http://localhost:1234/。也可以使用" target="_blank" rel="external">http://localhost:1234/。也可以使用</a> -p <port number=""> 选项覆盖默认的端口。<br>确实很快。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">built <span class="keyword">in</span> 16ms</div></pre></td></tr></table></figure></port></p><p>此外支持零配置代码拆分，也是挺舒服的。</p><p>至于sass，babel什么的，文档说的看起来于是相当的易于安装，基本无配置。支持TS，貌似还支持vue的组件和react的组件。</p><p>不过目前就看了这么多，边看文档，边简单的测试，边写这个小体验。只是接触了最基础的东西，总体给人的感觉是很轻，很快。很友好。不过据说webpack 4.0也要加入默认配置（可怜我webapck 3.0都不怎么会用。。）不知道parcel能不能真的火起来。不过一些小项目尝尝鲜还是没有问题的叭。</p><p>复习实在无聊，来看下这个东西还是很解闷的。。就先这么多吧，，复习要紧复习要紧。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在期末复习的一个难受的下午，也就是现在，我突然想起了之前看到的号称零配置且最快的前端打包神器：Parcel，于是我放下数字逻辑。准备看看这货到底什么样。&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/parcel-bundler/p
      
    
    </summary>
    
    
      <category term="技术" scheme="http://stan1812.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="工具" scheme="http://stan1812.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Crontab略解🎉</title>
    <link href="http://stan1812.github.io/2018/01/12/Crontab/"/>
    <id>http://stan1812.github.io/2018/01/12/Crontab/</id>
    <published>2018-01-11T16:22:06.000Z</published>
    <updated>2018-01-13T10:35:48.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Crond-amp-amp-Crontab"><a href="#Crond-amp-amp-Crontab" class="headerlink" title="Crond&amp;&amp;Crontab"></a>Crond&amp;&amp;Crontab</h3><p>先说下他俩是干啥么的。</p><blockquote><p>crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p><p>然后，Linux下的任务调度分两类，系统任务调度和用户任务调度。</p><p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。</p><p>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致</p><h3 id="Crontab-格式："><a href="#Crontab-格式：" class="headerlink" title="Crontab 格式："></a>Crontab 格式：</h3><table><thead><tr><th style="text-align:left">分</th><th style="text-align:left">时</th><th style="text-align:left">日</th><th style="text-align:left">月</th><th style="text-align:left">周</th><th style="text-align:left">命令</th></tr></thead><tbody><tr><td style="text-align:left">minute</td><td style="text-align:left">hour</td><td style="text-align:left">day</td><td style="text-align:left">month</td><td style="text-align:left">week</td><td style="text-align:left">command</td></tr><tr><td style="text-align:left">0~59</td><td style="text-align:left">0~23</td><td style="text-align:left">0~31</td><td style="text-align:left">0~12</td><td style="text-align:left">0~7</td><td style="text-align:left">系统命令/脚本文件 </td></tr></tbody></table><p>且均为整数<br>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p></blockquote><p>在以上各个字段中，还可以使用以下特殊字符：</p><p>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</p><p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</p><p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</p><p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="crond"><a href="#crond" class="headerlink" title="crond"></a>crond</h4><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">安装crontab：</div><div class="line"></div><div class="line">yum install crontabs</div><div class="line"></div><div class="line"></div><div class="line">/sbin/service crond start //启动服务</div><div class="line"></div><div class="line">/sbin/service crond stop //关闭服务</div><div class="line"></div><div class="line">/sbin/service crond restart //重启服务</div><div class="line"></div><div class="line">/sbin/service crond reload //重新载入配置</div><div class="line"></div><div class="line">查看crontab服务状态：</div><div class="line"></div><div class="line">service crond status</div><div class="line"></div><div class="line">手动启动crontab服务：</div><div class="line"></div><div class="line">service crond start</div><div class="line"></div><div class="line">查看crontab服务是否已设置为开机启动，执行命令：</div><div class="line"></div><div class="line">ntsysv</div><div class="line"></div><div class="line">加入开机自动启动：</div><div class="line"></div><div class="line">chkconfig –level 35 crond on</div></pre></td></tr></table></figure><h4 id="Crontab"><a href="#Crontab" class="headerlink" title="Crontab"></a>Crontab</h4><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">crontab [-u user] file</div><div class="line"></div><div class="line">crontab [-u user] [ -e | -l | -r ]</div></pre></td></tr></table></figure><p>2．命令功能：</p><p>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</p><p>3．命令参数：</p><ul><li>-u user : 用来设定某个用户的crontab服务，例如，“-u xxx”表示设定xxx用户的crontab服务，此参数一般有root用户来运行.</li><li>file : file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li><li>-e : 编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</li><li>-l : 显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</li><li>-r : 从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</li><li>-i : 在删除用户的crontab文件时给确认提示。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">比如每天定时启动一个Node的爬虫（结果展示了部分数据）</div><div class="line">[root@VM_56_194_centos ~]<span class="comment">#  crontab -l</span></div><div class="line">2 0 * * * /root/.nvm/versions/node/v8.8.0/bin/node /home/art-spider/Daily-article-spider/today.js</div></pre></td></tr></table></figure><p>最后推荐一个非常好用的帮助你写crontab命令的网站：<a href="https://crontab.guru/#1_0_*_*_*" target="_blank" rel="external">https://crontab.guru/#1<em>0</em><em>_</em>_*</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Crond-amp-amp-Crontab&quot;&gt;&lt;a href=&quot;#Crond-amp-amp-Crontab&quot; class=&quot;headerlink&quot; title=&quot;Crond&amp;amp;&amp;amp;Crontab&quot;&gt;&lt;/a&gt;Crond&amp;amp;&amp;amp;Crontab
      
    
    </summary>
    
      <category term="技术" scheme="http://stan1812.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://stan1812.github.io/tags/Linux/"/>
    
      <category term="技术" scheme="http://stan1812.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>几种排序</title>
    <link href="http://stan1812.github.io/2018/01/02/%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F/"/>
    <id>http://stan1812.github.io/2018/01/02/各种排序/</id>
    <published>2018-01-02T15:22:04.000Z</published>
    <updated>2018-01-04T10:04:56.921Z</updated>
    
    <content type="html"><![CDATA[<p>学习数据结构，最后接触了很多关于排序的东西。一些比较常见且使用较多的排序来总结一下。另外那些牛X的排序感觉理解还是有些难度的。。下面来写一下各种排序的JS实现。</p><p>先上一张图：<br><img src="/imgs/sort.png" alt=""></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序应该可以说是我接触的第一个排序算法，也是一种思想很容易理解的算法。</p><h4 id="思想："><a href="#思想：" class="headerlink" title="思想："></a>思想：</h4><p>相邻的数据进行两两比较，小数放在前面，大数放在后面，一趟下来，最小的数被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成</p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">//相邻元素两两对比</span></div><div class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">//元素交换</span></div><div class="line">                arr[j+<span class="number">1</span>] = arr[j];</div><div class="line">                arr[j] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h4 id="思想：-1"><a href="#思想：-1" class="headerlink" title="思想："></a>思想：</h4><p>先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> minIndex, temp;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</div><div class="line">        minIndex = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">//寻找最小的数</span></div><div class="line">                minIndex = j;                 <span class="comment">//将最小数的索引保存</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp = arr[i];</div><div class="line">        arr[i] = arr[minIndex];</div><div class="line">        arr[minIndex] = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>将数据分为两部分，有序部分与无序部分，一开始有序部分包含第1个元素，依次将无序的元素插入到有序部分，直到所有元素有序。插入排序又分为直接插入排序、二分插入排序、链表插入等，这里只讨论直接插入排序。它是稳定的排序算法，时间复杂度为O(n^2)</p><h4 id="实现：-1"><a href="#实现：-1" class="headerlink" title="实现："></a>实现：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length;</div><div class="line">    <span class="keyword">var</span> preIndex, current;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        preIndex = i - <span class="number">1</span>;</div><div class="line">        current = arr[i];</div><div class="line">        <span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</div><div class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex];</div><div class="line">            preIndex--;</div><div class="line">        &#125;</div><div class="line">        arr[preIndex+<span class="number">1</span>] = current;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>####　思想：<br>希尔排序是插入排序的一种更高效率的实现。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。</p><h4 id="实现：-2"><a href="#实现：-2" class="headerlink" title="实现："></a>实现：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> len = arr.length,</div><div class="line">        temp,</div><div class="line">        gap = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(gap &lt; len/<span class="number">3</span>) &#123;          <span class="comment">//动态定义间隔序列</span></div><div class="line">        gap =gap*<span class="number">3</span>+<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (gap; gap&gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">3</span>)) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; len; i++) &#123;</div><div class="line">            temp = arr[i];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i-gap; j &gt; <span class="number">0</span> &amp;&amp; arr[j]&gt; temp; j-=gap) &#123;</div><div class="line">                arr[j+gap] = arr[j];</div><div class="line">            &#125;</div><div class="line">            arr[j+gap] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h4><p>快速排序是目前在实践中非常高效的一种排序算法，它不是稳定的排序算法，平均时间复杂度为O(nlogn)，最差情况下复杂度为O(n^2)。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h4 id="最基本："><a href="#最基本：" class="headerlink" title="最基本："></a>最基本：</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//快速排序  </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr,left,right</span>)</span>&#123;</div><div class="line">&#123;  </div><div class="line">    <span class="keyword">if</span> (left &lt; right)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">let</span> i = left, j = right, x = arr[left];  </div><div class="line">        <span class="keyword">while</span> (i &lt; j)  </div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[j] &gt;= x) </div><div class="line">                j--;    </div><div class="line">            <span class="keyword">if</span>(i &lt; j)   </div><div class="line">                arr[i++] = arr[j];  </div><div class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; arr[i] &lt; x)</div><div class="line">                i++;    </div><div class="line">            <span class="keyword">if</span>(i &lt; j)   </div><div class="line">                arr[j--] = arr[i];  </div><div class="line">        &#125; </div><div class="line">        arr[i] = x;  </div><div class="line">        quick_sort(arr, left, i - <span class="number">1</span>); <span class="comment">// 递归调用   </span></div><div class="line">        quick_sort(arr, i + <span class="number">1</span>, right);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="改进一"><a href="#改进一" class="headerlink" title="改进一:"></a>改进一:</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr,left,right</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(left&lt;right)&#123;</div><div class="line">    <span class="keyword">let</span> x = arr[right], i = left<span class="number">-1</span>, temp</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = left; j&lt;=right;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(arr[j]&lt;=x)&#123;</div><div class="line">        i++</div><div class="line">        temp = arr[i]</div><div class="line">        arr[i]=arr[j]</div><div class="line">        arr[j]=temp</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    quickSort(arr, left, i<span class="number">-1</span>)</div><div class="line">    quickSort(arr, i+<span class="number">1</span>, right)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> arr</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="改进二"><a href="#改进二" class="headerlink" title="改进二:"></a>改进二:</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span> (<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(arr.length &lt;=<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> arr</div><div class="line">  &#125; <span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>)</div><div class="line">    <span class="keyword">let</span> pivot =arr.splice(pivotIndex,<span class="number">1</span>)[<span class="number">0</span>]</div><div class="line">    <span class="keyword">let</span> left =[]</div><div class="line">    <span class="keyword">let</span> right =[]</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</div><div class="line">      <span class="keyword">if</span>(arr[i]&lt;pivot)&#123;</div><div class="line">        left.push(arr[i])</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        right.push(arr[i])</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> quickSort(left).concat([pivot],quickSort(right))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习数据结构，最后接触了很多关于排序的东西。一些比较常见且使用较多的排序来总结一下。另外那些牛X的排序感觉理解还是有些难度的。。下面来写一下各种排序的JS实现。&lt;/p&gt;
&lt;p&gt;先上一张图：&lt;br&gt;&lt;img src=&quot;/imgs/sort.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>2017总结</title>
    <link href="http://stan1812.github.io/2017/12/30/2017/"/>
    <id>http://stan1812.github.io/2017/12/30/2017/</id>
    <published>2017-12-30T14:28:37.000Z</published>
    <updated>2017-12-31T18:15:16.363Z</updated>
    
    <content type="html"><![CDATA[<p>现在是2017年12月30日晚，公元2017年还有一天就要过去，公元2018年就要到来了。入坑前端正儿八经开始写代码差不多有10个月了（本来想写一年，仔细算了算还没有满一年。想来要在年度总结煽煽情都没有机会=。=），回过头来看颇有感触。虽然总觉得真正意义上的2017年还远远没有过去，但是年度总结差不多也要开始写了。关于技术，关于生活，思考事情的方式和看待问题的方式。现在先来留一个坑，可能会间隔的来写。</p><p><img src="/imgs/2017.jpg" alt=""></p><p>突然想要写点东西，那就开始写吧</p><hr><h2 id="关于技术-📐"><a href="#关于技术-📐" class="headerlink" title="关于技术 📐"></a>关于技术 📐</h2><h3 id="技术之路的开始"><a href="#技术之路的开始" class="headerlink" title="技术之路的开始"></a>技术之路的开始</h3><blockquote><p>我想我在2017年所做的最正确的事情可以说是开始学习前端并且爱上前端然后开始正儿八经的写代码。</p></blockquote><p>大概在17年初，想要尝试去加入家园工作室，在经历了第一次期末考试的突击月之后，开始了完全放松的寒假。第一个完全放松，没有一点的压力的寒假。本来计划的前端学习被抛在了脑后。可以说是很遗憾了。一个寒假很快过去，代码一点没动。可能是开学之后突然觉得自己太颓，于是在大概3月份开始正式的学习前端，并且真正的第一次意识到了写代码的乐趣。</p><p>三月份的时候过的挺有意思的，每天差不多就是看书，看mooc，敲代码。然后在腾讯云搭了个博客，开始了写博客的习惯。</p><p>有点意思。</p><p>那一段时间花了很多的时间在代码上面，学了一些东西，也写了一些东西，当时的想法也都在之前的博客里有写。</p><h3 id="家园"><a href="#家园" class="headerlink" title="家园"></a>家园</h3><p>在4月份上旬的某个周末躺尸的下午突然收到了钟伟杰老哥的一个信息，问我要不要来试下家园的笔试，于是就去参加了家园的春招。</p><p>感谢成成和子健收留了我。</p><p>家园工作室可以说是我的真正的技术启蒙的地方了。4月10日收到了家园的录用邮件，那个下午记得还挺清楚的，因为刚考完电工期中考试，嗯。</p><p>在进入家园的两个月基本上是处于放养阶段，没有写项目，就是自由的想学什么学什么。那段时间应该是学了挺多关于前端的一些挺杂的基础的东西了，然后玩些自己想玩的东西，用CSS写了一些自认为有点意思的东西。看了挺多的书，也写了一些页面，过的还算充实。</p><h3 id="暑期"><a href="#暑期" class="headerlink" title="暑期"></a>暑期</h3><p>这个时候差不多就来到了６、７月份，期末考试，然后开始了留校写项目。</p><p>暑假留校，每天７点起床，叫上老田钟伟杰等天健众基佬，然后骑去机房敲代码。到了晚上9点，天健摩拜车队浩浩荡荡从休闲骑回天健。暑假开始上车Vue，以及Vue的全家桶，然后开始接触家园的项目。这些之前的博客也有写，所以现在就不再详细写了~</p><p>在留校的那一个多月，应该是技术进步最快的一段时间了吧。</p><p>大概8月初的时候，回了家，在家养鱼了一段时间，补了留校所欠的懒觉。很舒服。然后出去玩了一段时间，也很舒服。看了一些mysql的东西，书看的倒不多。</p><h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>9月又开学了。emmm，然后开始完善云家园综测的相关模块，看了学长所搭的云家园的整个架构方面的东西，云家园算是个挺大的spa项目了，然后发现很多地方不理解=。= 除此之外对Vue的一些坑也有了一些经验。除此之外就是招新and学校运动会的尬舞。整个学院，大一到大三，一个月，浪费别人的时间就是谋财害命，但愿学院领导心中会有一丝不安（虽然知道他们不会）。一个月浪费了很多时间，很多的精力，技术方面没有看多少东西.</p><p>10月份开始接触NodeJS，跟着书敲了一些小demo，然后用node写了一些有意思的小爬虫，爬了点不可描述的东西，🙈还有些可以描述的东西，也写了点解放双手比如签到什么的小爬虫，然后去了解了下linux的定时任务，开个定时任务，很舒服。使用express写了一个小小的小东西，使用的是ejs模板，了解了后端的一些东西。之后尝试着试一下前后端分离，前端使用Vue，图方便用了MuseUI，后台使用node，写的是restful的api，然后数据库用的是mongodb。</p><p>12月份，开始写工作室的几个项目，时间过的很快，差不多就是这些了吧。</p><h2 id="关于生活-🎉"><a href="#关于生活-🎉" class="headerlink" title="关于生活  🎉"></a>关于生活  🎉</h2><p>可以说开始写代码之后，生活方式还是发生了很大的变化的。大一上学期的时候，每天看看书打打游戏睡睡觉，然后参加参加一些社团活动，按部就班，但是却总觉得差点东西。之后开始写代码，然后生活其实变化了挺多的变化的，比如睡觉时间明显的推后😂<br>然后就是在家园认识了这么多的志同道合的伙伴们。我发现了一个规律，就是开发的同志们，每次遇到基本上都会问一句话，最近在搞什么。大家一块儿吹吹水开开车很有意思。</p><p>除此之外，看了一些非技术类的书，看了好多小说and电影，各种类型。</p><p>看待事情的方式好像也有了点变化，从之前的可能有些时候很有些偏激或者片面，现在看问题可能学会了更全面一些也随和了许多，可能也归于佛系了吧。</p><p>另外，终于结束了2017年的单身生活，</p><p>迎来2018年的单身生活。</p><p>突然发现想写的挺多的，但是生活却又太复杂太零碎，就写这些吧。</p><p>新年快乐！！！🎉🎉🎉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是2017年12月30日晚，公元2017年还有一天就要过去，公元2018年就要到来了。入坑前端正儿八经开始写代码差不多有10个月了（本来想写一年，仔细算了算还没有满一年。想来要在年度总结煽煽情都没有机会=。=），回过头来看颇有感触。虽然总觉得真正意义上的2017年还远远
      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
      <category term="生活" scheme="http://stan1812.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Merry Xmas</title>
    <link href="http://stan1812.github.io/2017/12/23/Xmas/"/>
    <id>http://stan1812.github.io/2017/12/23/Xmas/</id>
    <published>2017-12-23T15:33:53.000Z</published>
    <updated>2017-12-25T11:53:20.411Z</updated>
    
    <content type="html"><![CDATA[<p>现在是2017年12月23日晚23:35分，刚看完了芳华原著，电影改编的地方还是挺多的，原著所写的很多东西比电影要不堪的多。现在听着电影芳华的配乐。因为选修的mooc明天考试截止，而我可还有很多没有刷完，想写个脚本刷一刷发现有点麻烦。。又怕控制不好被后台监测到，遂放弃。现在决定手刷。有些无聊，又不想写代码，便想着好久没有写过博客了，现在正好来写一篇。一些思考，和一些牢骚。</p><h2 id="这是第一个小标题"><a href="#这是第一个小标题" class="headerlink" title="这是第一个小标题"></a>这是第一个小标题</h2><p>想一想上一篇博客，2017.12.15，时间已经过去了很久。快十天了。而距离上一篇真正意义上的总结不知道已经距离了多长时间。不知道每天都做了些什么，想想已经很久没有完整的看过一本非技术类的书了，技术类的书也好久没有专注的研究一本，虽然也看了一些，但总觉得没有专注。除了写代码，基本处于每天放羊的阶段。这段时间总是被需求追着跑，写不完的需求。我能怎么办。我也很绝望啊。。</p><p>最近两周肝了两个晚上了，一个是要写摇一摇，一个是因为要提前保密以给大家圣诞节惊喜的小项目，所以项目组只有一个前端和一个后端。前端兼设计，后端兼产品。（UI设计很酷，但是没有一点专业知识还是挺难的，前端真的需要了解一些设计的东西）突然要上线，所以昨天晚上和小黑老哥肝到了4、5点，为什么要说4、5点呢？因为我4点睡了，而小黑5点睡。然后又有bug，然后突然来了设计要改图。。于是我们从11点又肝到了下午2点。然后小黑的女朋友来陪她吃了饭，而我则和肘子睿吃了一盆狗粮&amp;一份盖浇饭。</p><p>=。= 说起来，我什么时候才会有个女朋友。</p><h2 id="还是有一些开心的事情"><a href="#还是有一些开心的事情" class="headerlink" title="还是有一些开心的事情"></a>还是有一些开心的事情</h2><p>看了芳华的预告片，就很想看这个电影，最初对这个电影留下的最深的印象是女主角长的真的很仙儿，一种好像不属于这个年代的美。但是被项目缠身，一直拖着，终于在周三晚上的时候下定决心买了票和肘子睿在周四的晚上看了这部电影。看完之后感觉很庆幸。庆幸暂时放下了代码来看了这部电影，同时内心又很安静，不像之前看过电影时要么骂电影拍的烂，要么表面平静，内心澎湃不能自已，回味电影。看完这个电影之后，想说很多，但又不知从何说起，不如不说。芳华的配乐可以说是相当的好，氛围很好，而且之后如果你单独拿出来听，你真的会惊叹于这部电影的配乐。还有芳华的舞蹈，真的是很美，虽然我并不懂舞蹈，但还是让人感受到了舞蹈的美，可能艺术真的是来自于人们本身对美的追求，而人类本性中对美是有种本能的鉴赏和体会的吧。这个电影可能是最近最开心的一件事情了。虽然它可能间接导致了周五晚上的肝到4点。</p><h2 id="有点难受的事情"><a href="#有点难受的事情" class="headerlink" title="有点难受的事情"></a>有点难受的事情</h2><p>一件事情，最终的结果，不管是好是坏，你尽力做了和你没有尽力做或者说根本没有尝试去尽力做，最终你的感受是完全不一样的。这是一个很浅显的东西，从小就有人教育我们这个道理，但是我们依然做不好。是的，我们听了很多话，依然不容易过好这一生，是的这句话我改了一些，因为我觉得其实还是有可能过好这一生的。可能由于种种原因，一件事情你没有尽力去做，之后不管遗憾还是什么，也都这样了。遗憾请藏在心中。</p><h2 id="放在最后"><a href="#放在最后" class="headerlink" title="放在最后"></a>放在最后</h2><p>最后想分享刚刚看芳华感触最深的一句话：</p><blockquote><p>这回是我和郝淑雯笑得嘎嘎响。不快乐的人，都懂得我们这样的笑。放下了包袱，破碎了梦想，就是那种笑。笑我们曾经认真过的所有事儿。前头没有值得期盼的好事，身后也没有留下值得自豪的以往，就是无价值的流年，也所剩不多，明明破罐子，也破摔不起，摔了连破的都没了，那种笑。就是热诚情愿邀请人家摸，也没人摸了，既然最终没人摸，当时吝啬什么? 反正最终要残剩，最终是狗剩儿，当时神圣什么? 对，就那种笑。</p></blockquote><p>然后祝自己圣诞快乐</p><p><img src="/imgs/xmas2.png" alt=""></p><p>然后还有一句话：</p><blockquote><p>life runs on the code</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是2017年12月23日晚23:35分，刚看完了芳华原著，电影改编的地方还是挺多的，原著所写的很多东西比电影要不堪的多。现在听着电影芳华的配乐。因为选修的mooc明天考试截止，而我可还有很多没有刷完，想写个脚本刷一刷发现有点麻烦。。又怕控制不好被后台监测到，遂放弃。现在
      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
      <category term="生活" scheme="http://stan1812.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>我为何如此垃圾</title>
    <link href="http://stan1812.github.io/2017/12/15/why-am-i-so-laji/"/>
    <id>http://stan1812.github.io/2017/12/15/why-am-i-so-laji/</id>
    <published>2017-12-15T14:17:13.000Z</published>
    <updated>2017-12-15T14:38:57.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Why-are-you-so-diao？"><a href="#Why-are-you-so-diao？" class="headerlink" title="Why are you so diao？"></a>Why are you so diao？</h2><h3 id="Why-am-i-so-laji"><a href="#Why-am-i-so-laji" class="headerlink" title="Why am i so laji?"></a><strong>Why am i so laji?</strong></h3><h3 id="That’s-a-question"><a href="#That’s-a-question" class="headerlink" title="That’s a question"></a><strong>That’s a question</strong></h3><p>只有一个问题，我为什么还是这么辣鸡。</p><p>转眼都8102年了，可是我还是这么垃圾。</p><p>值得反思了。</p><p>唉。</p><p><img src="/imgs/fuck.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Why-are-you-so-diao？&quot;&gt;&lt;a href=&quot;#Why-are-you-so-diao？&quot; class=&quot;headerlink&quot; title=&quot;Why are you so diao？&quot;&gt;&lt;/a&gt;Why are you so diao？&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
      <category term="生活" scheme="http://stan1812.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>JS运算符和类型转换</title>
    <link href="http://stan1812.github.io/2017/11/19/JSLogicalOperators/"/>
    <id>http://stan1812.github.io/2017/11/19/JSLogicalOperators/</id>
    <published>2017-11-18T16:49:58.000Z</published>
    <updated>2017-11-19T06:35:27.103Z</updated>
    
    <content type="html"><![CDATA[<p>之前真的是小瞧了JS的运算符，再看《JS高级程序设计》的时候，甚至都没有深入的了解JS的逻辑运算符，只是走马观花的边跳边看。。今天晚上闲着没事，不想写代码，就想看看一些小框架的源码学习学习。看到了大量的关于运算符骚操作之后，发现原来逻辑表达式还能这么玩，羞愧不已，于是重新搬出红宝书，又查了一些文档，对逻辑表达式来稍微深入探讨一下。因为涉及了很多类型转换，所以对类型转换也来总结一下。（虽然一个===可以解决几乎所有问题。。但还是要了解一下的~）</p><hr><h2 id="逻辑表达式基本知识补充"><a href="#逻辑表达式基本知识补充" class="headerlink" title="逻辑表达式基本知识补充"></a>逻辑表达式基本知识补充</h2><ul><li><p>逻辑非 ！</p><p>逻辑非可以用于ECMAScript中任何值，无论用于任何值都会返回一个布尔值，也就是说，他会先操作数变为一个布尔值，之后对其取反。而同时使用！！则可以达到使用Boolean()的效果了</p><ul><li><p>如果一个操作数是一个对象，返回false;</p></li><li><p>如果一个操作数是一个空字符串，返回false;</p></li><li><p>如果一个操作数是一个非空字符串，返回false;</p></li><li><p>如果一个操作数是一个数值0，返回true;</p></li><li><p>如果一个操作数是任意的非零字符，返回false;</p></li><li><p>如果一个操作数是null，返回true;</p></li><li><p>如果一个操作数是NaN，返回true;</p></li><li><p>如果一个操作数是undefined，返回true;</p></li><li>能够转换为false的表达式有:<ul><li>null;</li><li>NaN;</li><li>0;</li><li>空字符串（””）;</li><li>undefined.</li></ul></li></ul><p>(其实这些东西可以说是很好理解了，，不过还是系统的总结一下)</p></li><li><p>逻辑与</p><p>对于不是布尔值的情况则：</p><ul><li><p>如果第一个操作数是对象，则返回第二个数</p></li><li><p>如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象；</p></li><li><p>如果第两个操作数都是对象，则返回第二个数操作数</p></li><li><p>如果有一个操作数是null，则返回null</p></li><li><p>如果有一个操作数是NaN，则返回第NaN</p></li><li><p>如果第一个操作数是undefined，则返回undefined</p></li></ul><p>逻辑运算符操作对象遵循从左到右的顺序来判断，逻辑与操作符（&amp;&amp;）先判断第一个数，如果第一个数的逻辑判断是true，则还需判断第二个数，结果输出第二个操作数；同理，如果第一个数为false，则不用考虑第二个数了，直接输出第一个数的逻辑判断结果.</p></li><li><p>逻辑或</p></li></ul><p>对于不是布尔值的情况则：</p><ul><li><p>如果第一个操作数是对象，则返第一个操作数</p></li><li><p>如果第一个操作数的求值结果为false，则返回第二个操作数</p></li><li><p>如果两个操作数都是对象，则返回第一个操作数</p></li><li><p>如果两个操作数是null，则返回null</p></li><li><p>如果两个操作数是NaN，则返回NaN</p></li><li><p>如果两个操作数是undefined，则返回undefined </p></li></ul><p>逻辑或(||)的判断是如果第一个操作数的逻辑判断为true，则直接输出第一个操作数，不用再考虑第二个操作数；如果第一个操作数的逻辑判断为false，则还得去判断第二个操作数的逻辑。</p><p>尽管 &amp;&amp; 和 || 运算符能够使用非Boolean值的操作数, 但它们依然被看作是Boolean操作符，因为它们的返回值总是能够被转换为Boolean值。</p><h3 id="短路计算"><a href="#短路计算" class="headerlink" title="短路计算"></a>短路计算</h3><p>由于逻辑表达式的运算的顺序是从左到右,也可以用以下规则进行”短路”计算:</p><p>false &amp;&amp; (anything)  短路计算的结果为false.</p><p>true || (anything)  短路计算的结果为 true.</p><p>该规则确保这些计算的准确性. 注意如果上述表达式中的 anything 部分不能被计算的话,  两边都不会生效.还需要注意的是,上述表达式中的 anything 部分是任意的单个逻辑表达式(小括号中).</p><hr><h2 id="JS表达式中的类型转换"><a href="#JS表达式中的类型转换" class="headerlink" title="JS表达式中的类型转换"></a>JS表达式中的类型转换</h2><p>相信很多前端都会觉得==的设计可以说是很糟糕了，，<br>一直以来都在刻意避免使用== 只用===,就是因为其中的类型转换,但是并不理解其中的具体的原因</p><p>相等本来可以说是很简单的操作了,但是也是对于基本的字符串,数字,布尔值来说,一旦涉及到对象的比较,就复杂了,早期的es的相等和不等都会先进行类型转换.之后的解决方案是使用== and ===</p><p>先来看看红宝书是怎么具体的说的</p><h3 id="amp"><a href="#amp" class="headerlink" title="== != &amp; ===  !=="></a>== != &amp; ===  !==</h3><h4 id=""><a href="#" class="headerlink" title="== !="></a>== !=</h4><p>ECMAScript 中的相等操作符由两个等于号（==）表示，如果两个操作数相等，则返回 true。而不相等操作符由叹号后跟等于号（!=）表示，如果两个操作数不相等，则返回 true。这两个操作符都会<br>先转换操作数（通常称为强制转型），然后再比较它们的相等性。<br>在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：</p><ul><li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false 转换为 0，而true 转换为 1；</li><li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；</li><li>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类<br>型值按照前面的规则进行比较；<br>这两个操作符在进行比较时则要遵循下列规则。</li><li>null 和 undefined 是相等的。</li><li>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li><li>如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示：<br>即使两个操作数都是 NaN，相等操作符也返回 false；因为按照规则，NaN 不等于 NaN。</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，<br>则相等操作符返回 true；否则，返回 false。</li></ul><h4 id="amp-1"><a href="#amp-1" class="headerlink" title="=== &amp; !=="></a>=== &amp; !==</h4><p>除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符由 3 个等于号（===）表示，它只在两个操作数未经转换就相等的情况下返回 true.</p><p>记住：null == undefined 会返回 true，因为它们是类似的值；但 null === undefined 会返回 false，因为它们是不同类型的值</p><hr><p>这里有一篇好文:<br>作者：林建入<br>链接：<a href="https://www.zhihu.com/question/20348948/answer/19601270" target="_blank" rel="external">https://www.zhihu.com/question/20348948/answer/19601270</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h4 id="严格相等运算符"><a href="#严格相等运算符" class="headerlink" title="严格相等运算符"></a>严格相等运算符</h4><p>=== 被称为 Strict Equals Operator，假设有表达式 a === b，则它的实际运算过程如下</p><ol><li>计算出表达式 a 的结果，并存入 lref 变量</li><li>将 GetValue(lref) 的结果存入 lval 变量</li><li>计算出表达式 b 的结果，并存入 rref 变量</li><li>将 GetValue(rref) 的结果存入 rval 变量</li><li>执行 Strict Equality Comparison 算法判断 rval === lval 并将结果直接返回</li></ol><p>这里的 Strict Equality Comparison 算法很关键，假设要计算的是 x === y，则过程如下</p><ol><li>如果 Type(x) 和 Type(y) 不同，返回 false</li><li>如果 Type(x) 为 Number，则进入下面的判断逻辑<ol><li>如果 x 为 NaN，返回 false</li><li>如果 y 为 NaN，返回 false</li><li>如果 x 的数字值和 y 相等，返回 true</li><li>如果 x 是 +0 且 y 是 -0，返回 true</li><li>如果 x 是 -0 且 y 是 +0，返回 ture</li><li>返回 false</li></ol></li><li>如果 Type(x) 为 String，则当且仅当 x 与 y 的字符序列完全相同（长度相等，每个位置上的字符相同）时返回 true，否则返回 false</li><li>如果 Type(x) 为 Boolean，则若 x 与 y 同为 true 或同为 false 时返回 true，否则返回 false</li><li>如果 x 和 y 引用的是同一个对象，返回 true，否则返回 false</li></ol><h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>== 的实现好了，当你明白了 === 的实现之后，我们再来看看 == 的实现，比较一下他们有何不同？<br>== 被称为 Equals Operator （注意看没有 Strict 了），</p><p>假设有表达式 a == b，则它的实际运算过程如下</p><ol><li>计算出表达式 a 的结果，并存入 lref 变量</li><li>将 GetValue(lref) 的结果存入 lval 变量</li><li>计算出表达式 b 的结果，并存入 rref 变量</li><li>将 GetValue(rref) 的结果存入 rval 变量</li><li>执行 Abstract Equality Comparison 算法判断 rval == lval 并将结果直接返回</li></ol><p>注意，其中的前 4 个步骤是和 === 完全相同的。唯独 5 不同。对于 === 来说，调用的是 Strict Equality Comparison 算法，但是 == 则调用的是 Abstract Equality Comparison 算法。虽然仅一词之差，但是却有质的不同，我们下面就来看看到底它是怎么实现的</p><p>假设要计算的是 x == y，Abstract Equality Comparison 计算的过程如下（很冗长，但是每个步骤都很简单）</p><ol><li><p>如果 Type(x) 和 Type(y) 相同，则</p><ol><li>如果 Type(x) 为 Undefined，返回 true</li><li>如果 Type(x) 为 Null，返回 true</li><li><p>如果 Type(x) 为 Number，则</p><ol><li>如果 x 是 NaN，返回 false</li><li>如果 y 是 NaN，返回 false</li><li>如果 x 的数值与 y 相同，返回 true</li><li>如果 x 是 +0 且 y 是 -0，返回 true</li><li>如果 x 是 -0 且 y 是 +0，返回 true</li><li>返回 false</li></ol></li><li><p>如果 Type(x) 为 String，则当且仅当 x 与 y 的字符序列完全相同（长度相等，每个位置上的字符相同）时返回 true，否则返回 false</p></li><li>如果 Type(x) 为 Boolean，则若 x 与 y 同为 true 或同为 false 时返回 true，否则返回 false</li><li>如果 x 和 y 引用的是同一个对象，返回 true，否则返回 false</li></ol></li><li>如果 x 是 null 且 y 是 undefined，返回 true</li><li>如果 x 是 undefined 且 y 是 null，返回 ture</li><li>如果 Type(x) 为 Number 且 Type(y) 为 String，以 x == ToNumber(y) 的比较结果作为返回</li><li>如果 Type(x) 为 String 且 Type(y) 为 Number，以 ToNumber(x) == y 的比较结果作为返回值</li><li>如果 Type(x) 为 Boolean，以 ToNumber(x) == y 的比较结果作为返回值</li><li>如果 Type(y) 为 Boolean，以 x == ToNumber(y) 的比较结果作为返回值</li><li>如果 Type(x) 为 String 或 Number 且 Type(y) 为 Object，以 x == ToPrimitive(y) 的比较结果作为返回值</li><li>如果 Type(x) 为 Object 且 Type(y) 为 String 或 Number，以 ToPrimitive(x) == y 的比较结果作为返回值10. 返回 false</li></ol><p>从上面的算法流程可以看出，a ===  b 是最简单的。如果 a 和 b 的类型不同，那么一定会返回 false。而 a == b 则要灵活得多。JavaScript 会尝试调整 a 和 b 的类型，例如若 a 为字符串 b 为数字，则将字符串先转化为数字再与 b 比较，等等。这在很多时候简化了程序员的代码量。</p><p>还有一篇:<a href="https://segmentfault.com/a/1190000006012804" target="_blank" rel="external">https://segmentfault.com/a/1190000006012804</a></p><h2 id="JS逻辑运算符的一些骚操作"><a href="#JS逻辑运算符的一些骚操作" class="headerlink" title="JS逻辑运算符的一些骚操作"></a>JS逻辑运算符的一些骚操作</h2><p>其实也不骚hhh，很实用的操作<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//判断类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="built_in">String</span>(obj) :</div><div class="line">    [<span class="built_in">String</span>.prototype.toString.call(obj)] || <span class="string">"object"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 判断是否是 window对象（注意，w为小写）指当前的浏览器窗口，window对象的window属性指向自身。</span></div><div class="line"><span class="comment">// 即 window.window === window</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWindow</span>(<span class="params">obj</span>)</span></div><div class="line"><span class="function"></span>&#123; <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; obj == obj.window &#125;</div><div class="line"> <span class="comment">// 判断是否是数组或者对象数组</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">likeArray</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = !!obj &amp;&amp; <span class="string">'length'</span> <span class="keyword">in</span> obj &amp;&amp; obj.length,</div><div class="line">    type = $.type(obj)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">'function'</span> != type &amp;&amp; !isWindow(obj) &amp;&amp; (</div><div class="line">    <span class="string">'array'</span> == type || length === <span class="number">0</span> ||</div><div class="line">      (<span class="keyword">typeof</span> length == <span class="string">'number'</span> &amp;&amp; length &gt; <span class="number">0</span> &amp;&amp; (length - <span class="number">1</span>) <span class="keyword">in</span> obj)</div><div class="line">  )</div><div class="line">&#125;</div><div class="line"><span class="comment">//有没有要看晕了。。我也要晕了，，实际工程里要这样写的话，会被打死吧。。</span></div></pre></td></tr></table></figure><p>还有一个非常优雅的<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//形如:</span></div><div class="line"><span class="comment">//如果X则_x,如果y则_y,如果z则_z等等等</span></div><div class="line"><span class="comment">//比如一岁给1个苹果,且增长无规律</span></div><div class="line"><span class="comment">//将swictch或者链式ifelse改写</span></div><div class="line"><span class="keyword">var</span> res = (age==<span class="number">5</span> &amp;&amp; <span class="number">1</span>) || (age==<span class="number">10</span> &amp;&amp; <span class="number">2</span>) || (age==<span class="number">12</span> &amp;&amp; <span class="number">3</span>) || (age==<span class="number">15</span> &amp;&amp; <span class="number">4</span>) || <span class="number">0</span>;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前真的是小瞧了JS的运算符，再看《JS高级程序设计》的时候，甚至都没有深入的了解JS的逻辑运算符，只是走马观花的边跳边看。。今天晚上闲着没事，不想写代码，就想看看一些小框架的源码学习学习。看到了大量的关于运算符骚操作之后，发现原来逻辑表达式还能这么玩，羞愧不已，于是重新搬
      
    
    </summary>
    
      <category term="技术" scheme="http://stan1812.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS中的各种继承</title>
    <link href="http://stan1812.github.io/2017/11/06/JSOO/"/>
    <id>http://stan1812.github.io/2017/11/06/JSOO/</id>
    <published>2017-11-06T07:10:24.000Z</published>
    <updated>2017-11-06T07:20:43.347Z</updated>
    
    <content type="html"><![CDATA[<p>先留坑，回头来写</p><h3 id="Before-talking"><a href="#Before-talking" class="headerlink" title="Before talking"></a>Before talking</h3><p>自己对于JS中的原型以及各种玄乎的继承一直理解都比较模糊，感觉这一块一直都是自己的一个坑，最近在重新看《JavaScript高级程序设计》中关于原型和继承的一部分。结合着《JavaScript面向对象编程指南》对于JS中的各种继承来总结一下</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><h4 id="复习一下原型："><a href="#复习一下原型：" class="headerlink" title="复习一下原型："></a>复习一下原型：</h4><h3 id="各种继承"><a href="#各种继承" class="headerlink" title="各种继承"></a>各种继承</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先留坑，回头来写&lt;/p&gt;
&lt;h3 id=&quot;Before-talking&quot;&gt;&lt;a href=&quot;#Before-talking&quot; class=&quot;headerlink&quot; title=&quot;Before talking&quot;&gt;&lt;/a&gt;Before talking&lt;/h3&gt;&lt;p&gt;自己对于JS
      
    
    </summary>
    
      <category term="技术" scheme="http://stan1812.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>浅析struct</title>
    <link href="http://stan1812.github.io/2017/10/17/structDef/"/>
    <id>http://stan1812.github.io/2017/10/17/structDef/</id>
    <published>2017-10-17T08:47:35.000Z</published>
    <updated>2017-10-18T03:43:49.470Z</updated>
    
    <content type="html"><![CDATA[<p>先留坑，空下来来写</p><h3 id="typedef是什么"><a href="#typedef是什么" class="headerlink" title="typedef是什么"></a>typedef是什么</h3><p>typedef为C语言的关键字，作用是为一种数据类型定义一个新名字。这里的数据类型包括内部数据类型（int,char等）和自定义的数据类型（struct等）。</p><p>在编程中使用typedef目的一般有两个，一个是给变量一个易记且意义明确的新名字，另一个是简化一些比较复杂的类型声明。</p><h3 id="使用struct"><a href="#使用struct" class="headerlink" title="使用struct"></a>使用struct</h3><h4 id="结构声明"><a href="#结构声明" class="headerlink" title="结构声明"></a>结构声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></div><div class="line"><span class="keyword">int</span> age;</div><div class="line"><span class="keyword">int</span> height;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>该声明描述了一个由两个整形所组成的结构，但并未创建实际的数据对象，只是描述了该对象由什么组成（可称之为“模板”，因为他勾勒出该结构是如何存数数据的，突然想起js的构造函数。。）</p><p>下面来分析一下细节：<br>首先：关键字struct，它表明跟在后面的是一个结构，后面是一个可选的标记“S1”，稍后程序中可以使用该标记引用该结构，例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">me</span>;</span></div></pre></td></tr></table></figure></p><p>这把<code>me</code>声明为一个使用<code>person</code>结构的结构变量</p><h4 id="定义结构变量"><a href="#定义结构变量" class="headerlink" title="定义结构变量"></a>定义结构变量</h4><p>结构有两层含义：一是结构布局，结构布局告诉编译器如何表示数据，但是并未让编译器为数据分配空间。 之后就是需要创建一个结构变量，即是另外一个含义。<br>在<code>struct person me;</code>中，<code>struct person</code>所起的作用就是相当于一般声明中的int float<br>可以定义两个<code>struct person</code>类型的变量，甚至是一个指向<code>struct person</code>类型结构的指针。<br><code>struct person me, xiaoming ,*xiaohong;</code></p><p>就计算机而言：<code>struct person me</code>是以下声明的简化：<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> &#123;</span></div><div class="line"><span class="keyword">int</span> age;</div><div class="line"><span class="keyword">int</span> height;</div><div class="line">&#125; me;</div></pre></td></tr></table></figure></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>以上，可知，声明结构的过程和定义结构变量的过程可以组合长一个步骤<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line"><span class="keyword">int</span> age;</div><div class="line"><span class="keyword">int</span> height;</div><div class="line">&#125; me;</div></pre></td></tr></table></figure></p><p>然而，如果需要多次使用，就必须使用带标记的形式，或者使用接下来要介绍的<code>typedef</code></p><p>ps：这只是定义结构变量，并未初始化结构变量</p><h3 id="使用typedef"><a href="#使用typedef" class="headerlink" title="使用typedef"></a>使用typedef</h3><h4 id="typedef与结构结合使用"><a href="#typedef与结构结合使用" class="headerlink" title="typedef与结构结合使用"></a>typedef与结构结合使用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMyStruct</span></span></div><div class="line"><span class="class">&#123;</span> </div><div class="line">　<span class="keyword">int</span> iNum;</div><div class="line">　<span class="keyword">long</span> lLength;</div><div class="line">&#125; MyStruct;</div></pre></td></tr></table></figure><p>这语句实际上完成两个操作：</p><p>1) 定义一个新的结构类型<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagMyStruct</span></span></div><div class="line"><span class="class">&#123;</span> </div><div class="line">　<span class="keyword">int</span> iNum; </div><div class="line">　<span class="keyword">long</span> lLength; </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>分析：tagMyStruct称为“tag”，即“标签”，实际上是一个临时名字，struct 关键字和tagMyStruct一起，构成了这个结构类型，不论是否有typedef，这个结构都存在。</p><p>我们可以用struct tagMyStruct varName来定义变量，但要注意，使用tagMyStruct varName来定义变量是不对的，因为struct 和tagMyStruct合在一起才能表示一个结构类型。</p><p>2) typedef为这个新的结构起了一个名字，叫MyStruct。</p><p>  <code>typedef struct tagMyStruct MyStruct;</code></p><p>因此，MyStruct实际上相当于struct tagMyStruct，我们可以使用MyStruct varName来定义变量</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">x1</span> &#123;</span> ...&#125;x1; </div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">x2</span>&#123;</span> ...&#125; x2;</div><div class="line">``` </div><div class="line">有什么不同？ </div><div class="line">其实, 前者是定义了类`_x1`和`_x1`的对象实例`x1`, 后者是定义了类`_x2`和`_x2`的类别名`x2`</div><div class="line"></div><div class="line">所以它们在使用过程中是有区别的</div><div class="line">实例：</div><div class="line">```C++</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">int</span> num;</div><div class="line"><span class="keyword">int</span> age;</div><div class="line">&#125;aaa,bbb,ccc;</div></pre></td></tr></table></figure><p>这算什么呢？<br>这相当于<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">int</span> num;</div><div class="line"><span class="keyword">int</span> age;</div><div class="line">&#125;aaa；</div><div class="line"><span class="keyword">typedef</span> aaa bbb;</div><div class="line"><span class="keyword">typedef</span> aaa ccc;</div></pre></td></tr></table></figure></p><p>也就是说aaa,bbb,ccc三者都是结构体类型。声明变量时用任何一个都可以,在c++中也是如此。但是你要注意的是这个在c++中如果无typedef关键字，那么aaa，bbb，ccc将是截然不同的三个对象。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>(这个问答是在CSDN看到的，<a href="http://blog.csdn.net/haiou0/article/details/6877718" target="_blank" rel="external">链接在此</a>因为对C和C++学习的并不深入，所以直接拿来了~)<br>Q：用struct和typedef struct 定义一个结构体有什么区别？为什么会有两种方式呢？<br><figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span></div><div class="line"><span class="class">&#123;</span> </div><div class="line"><span class="keyword">int</span> a; </div><div class="line">&#125; stu;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student2</span> </span></div><div class="line"><span class="class">&#123;</span> </div><div class="line"><span class="keyword">int</span> a; </div><div class="line">&#125;stu2;</div></pre></td></tr></table></figure></p><p>A：</p><p>事实上，这个东西是从C语言中遗留过来的，typedef可以定义新的复合类型或给现有类型起一个别名，在C语言中，如果你使用 <code>struct xxx {...};</code> 的方法，使用时就必须用<code>struct xxx var</code> 来声明变量，而使用 <code>typedef struct {...}</code>的方法 就可以写为<code>xxx var</code>;<br>不过在C++中已经没有这回事了，无论你用哪一种写法都可以使用第二种方式声明变量，这个应该算是C语言的糟粕。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先留坑，空下来来写&lt;/p&gt;
&lt;h3 id=&quot;typedef是什么&quot;&gt;&lt;a href=&quot;#typedef是什么&quot; class=&quot;headerlink&quot; title=&quot;typedef是什么&quot;&gt;&lt;/a&gt;typedef是什么&lt;/h3&gt;&lt;p&gt;typedef为C语言的关键字，作用是为一
      
    
    </summary>
    
      <category term="技术" scheme="http://stan1812.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据结构" scheme="http://stan1812.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
