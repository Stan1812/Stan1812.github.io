<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Libx</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://stan1812.github.io/"/>
  <updated>2019-01-05T15:43:52.284Z</updated>
  <id>http://stan1812.github.io/</id>
  
  <author>
    <name>Shady</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端、设计、用户体验</title>
    <link href="http://stan1812.github.io/2019/01/05/experience-engineering/"/>
    <id>http://stan1812.github.io/2019/01/05/experience-engineering/</id>
    <published>2019-01-05T15:38:27.000Z</published>
    <updated>2019-01-05T15:43:52.284Z</updated>
    
    <content type="html"><![CDATA[<p>如题，关于前端、设计和用户体验的一些思考。</p><p>先留坑了，期末考试完再来写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如题，关于前端、设计和用户体验的一些思考。&lt;/p&gt;
&lt;p&gt;先留坑了，期末考试完再来写。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
  </entry>
  
  <entry>
    <title>Hooks at a Glance</title>
    <link href="http://stan1812.github.io/2018/10/28/Hooks/"/>
    <id>http://stan1812.github.io/2018/10/28/Hooks/</id>
    <published>2018-10-28T03:54:43.000Z</published>
    <updated>2018-10-28T05:50:11.639Z</updated>
    
    <content type="html"><![CDATA[<p>在看了React Hooks的文档之后，本英语渣渣竟然突然有了想要翻译一下这篇文档的冲动，于是就首次尝试翻译一篇英文文档,原文<a href="https://reactjs.org/docs/hooks-overview.html" target="_blank" rel="external">Hooks at a Glance</a></p><p>Hooks是一个React中的新提案，他可以让你在不使用Class的情况下使用state和其他的React特性。Hooks 目前已经发布在 v16.7.0 alpha 版本，且正在开放的<a href="https://github.com/reactjs/rfcs/pull/68" target="_blank" rel="external">RFC</a>讨论。</p><p>Hooks是向后兼容的，这篇文档将向有经验的React开发者提供一个概览。</p><h2 id="📌-State-Hook"><a href="#📌-State-Hook" class="headerlink" title="📌 State Hook"></a>📌 State Hook</h2><p>这是一个计数器的例子，点击按钮，数字加一。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Declare a new state variable, which we'll call "count"</span></div><div class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></div><div class="line"><span class="regexp">        Click me</span></div><div class="line"><span class="regexp">      &lt;/</span>button&gt;</div><div class="line">    &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p><p>在这里，<code>useState</code>是一个Hook(我们稍后会讨论它是什么意思)，我们在一个函数式组件中调用它来添加一些内部的状态。React<br>将在重新渲染间保留此状态，<code>useState</code>返回一个pair:包含了当前的状态值和一个可以用来更新该值的函数。你可以在一个事件监听器或者其他地方调用这个函数。它和Class中的<code>setState</code>是类似的，不过他没把新旧状态合并在一起。（稍后会有例子来比较在使用State Hooks时useState和this.state的差异）</p><p>useState只有一个参数作为他的初始状态，在上面的例子中，这个参数是0，因为计数器从0开始。请注意，和this.state不同的是，这里的state不一定非要是一个对象——你要是想那也行。初始状态只在首次渲染时使用。</p><h3 id="声明多个状态变量"><a href="#声明多个状态变量" class="headerlink" title="声明多个状态变量"></a>声明多个状态变量</h3><p>你可以在一个组件中多次使用State Hook<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleWithManyStates</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Declare multiple state variables!</span></div><div class="line">  <span class="keyword">const</span> [age, setAge] = useState(<span class="number">42</span>);</div><div class="line">  <span class="keyword">const</span> [fruit, setFruit] = useState(<span class="string">'banana'</span>);</div><div class="line">  <span class="keyword">const</span> [todos, setTodos] = useState([&#123; <span class="attr">text</span>: <span class="string">'Learn Hooks'</span> &#125;]);</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>数组解构语法允许我们为通过调用useState声明的状态变量赋予不同的名称,这些名字并不是useState这个API的一部分，相反，React假定如果多次调用useState，就在每次渲染期间以相同的顺序执行。我们稍后会讨论这什么时候有用。</p><h3 id="但到底什么是Hook呢？"><a href="#但到底什么是Hook呢？" class="headerlink" title="但到底什么是Hook呢？"></a>但到底什么是Hook呢？</h3><p>Hooks 是一个React 函数组件内一类特殊的函数（通常以 “use” 开头，比如 “useState”），使开发者能够在 function component 里 ‘hook in’ state 和 life-cycles，以及使用 custom hook 复用业务逻辑。Hooks在Class组件中不能使用-这使得你可以在不写Class的情况下使用React（我们不建议您在一夜之间重写现有组件，但如果您愿意，可以开始在新组件中使用Hook。）<br>React提供了一些像useState这样的内置Hook。你还可以创建custom Hook以在不同组件之间重用有状态行为。我们先来看看内置的Hooks。</p><h2 id="⚡️-Effect-Hook"><a href="#⚡️-Effect-Hook" class="headerlink" title="⚡️ Effect Hook"></a>⚡️ Effect Hook</h2><p>你之前可能在React组件执行数据获取，订阅或手动更改DOM。我们称这种操作为“side effects”因为它们会影响其他的组件，并且不会在渲染期间就完成。</p><p>Effect Hook：<code>useEffect</code>为函数组件增添了执行side effects的能力。它与React Class中的componentDidMount，componentDidUpdate和componentWillUnmount具有相同的用途，但统一为单个API。 （我们将在使用Effect Hook时显示将useEffect与这些方法进行比较的示例。）</p><p>举个栗子，这个组件在React更新DOM之后设置文档标题 </p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</div><div class="line">  <span class="comment">// Similar to componentDidMount and componentDidUpdate:</span></div><div class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// Update the document title using the browser API</span></div><div class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></div><div class="line"><span class="regexp">        Click me</span></div><div class="line"><span class="regexp">      &lt;/</span>button&gt;</div><div class="line">    &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure><p>当你调用useEffect时，相当于告诉了React在刷新对DOM的更改后再运行你的“effect”函数。Effects是声明在Component内的，所以有权访问组件的props和state。默认情况下，React在每次render都会调用effects，包括第一次render。（我们将更多地讨论使用<a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="external">Effect Hook</a>和class中的lifecycles进行比较。）</p><p>Effects还可以通过返回函数指定如何“清理”它们。例如，这个组件使用Effect来订阅朋友的在线状态，并通过取消订阅来清理：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>)</span>&#123;</div><div class="line">  <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</div><div class="line">    setIsOnline(status.isOnline)</div><div class="line">  &#125;</div><div class="line">  useEffects(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</div><div class="line">    &#125;;</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">if</span>(isOnline === <span class="literal">null</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'loading'</span></div><div class="line">  &#125;</div><div class="line">   <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> :<span class="string">'Offline'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这个例子中，React会在组件unmount时，以及在由于后续渲染而重新运行effects之前取消订阅ChatAPI（你也可以告诉React<a href="https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects" target="_blank" rel="external">跳过重新订阅</a>如果我们传给ChatAPI的props.friend.id没有变的话）</p><p>就像·useState·一样，你可以在一个Component中多次使用effect<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatusWithCounter</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</div><div class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span>;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</div><div class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</div><div class="line">    setIsOnline(status.isOnline);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// ...</span></div></pre></td></tr></table></figure></p><p>Hooks允许您通过哪些部分相关（例如添加和删除订阅）来组织组件中的side effects，而不是基于生命周期方法强制拆分。<br>您可以在这个页面上了解有关useEffect的更多信息：<a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="external">Using the Effect Hook</a>。</p><h2 id="✌️-Rules-of-Hooks"><a href="#✌️-Rules-of-Hooks" class="headerlink" title="✌️ Rules of Hooks"></a>✌️ Rules of Hooks</h2><p>Hooks是JavaScript函数，但它们强加了两个额外的规则：</p><ul><li>只能在顶层调用Hooks。不要在循环，条件或嵌套函数中调用Hook。</li><li>仅从React函数组件中调用Hooks。不要从常规JavaScript函数中调用Hook。 （还有另一个有效的地方叫Hooks - 你自己的定制Hooks。我们马上就会了解它们。）</li></ul><p>我们提供了一个<a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="external">linter插件</a>来自动执行这些规则。这些规则最初可能看起来有限或令人困惑，但它们对于使Hooks运行良好至关重要。</p><h2 id="💡-Custom-Hooks"><a href="#💡-Custom-Hooks" class="headerlink" title="💡 Custom Hooks"></a>💡 Custom Hooks</h2><p>有时，我们希望在组件之间重用一些有状态逻辑。以往，这个问题有两种流行的解决方案：HOC和render props。Custom Hook可以做到这些，并且让你不需往组件树添加更多的组件。<br> 在前面，我们介绍了一个调用useState和useEffect Hooks的FriendStatus组件来订阅朋友的在线状态。假设我们还希望在另一个组件中重用此订阅逻辑：<br> 首先，我们将这个逻辑提取到一个名为useFriendStatus的自定义Hook中：<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"> <span class="keyword">import</span> &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [isOnline, setIsOnline] = useState(<span class="literal">null</span>);</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>) </span>&#123;</div><div class="line">    setIsOnline(status.isOnline);</div><div class="line">  &#125;</div><div class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> isOnline;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 它将friendID作为参数，并返回我们的朋友是否在线。<br> 现在我们可以在组件中使用它：<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (isOnline === <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'Loading...'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id);</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;li style=&#123;&#123; <span class="attr">color</span>: isOnline ? <span class="string">'green'</span> : <span class="string">'black'</span> &#125;&#125;&gt;</div><div class="line">      &#123;props.friend.name&#125;</div><div class="line">    &lt;<span class="regexp">/li&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p><p> 这些组件的状态是完全独立的。Hooks是重用有状态逻辑的一种方式，而不是状态本身。事实上，每次调用Hook都有一个完全隔离的state - 所以你甚至可以在一个组件中使用相同的自定义Hook两次。<br> Custom Hooks更像是一种约定而非功能,如果一个函数的名字以‘use’开头，把那个且他调用了其他的Hooks 我们称他为custom Hook 。useSomething命名约定也是linter插件在使用了hooks的代码中查找bug的原理。<br> 您可以编写自定义Hook，涵盖各种用例，如表单处理，动画，声明性订阅，计时器，可能还有更多我们没有考虑过的。我们很高兴看到React社区提出的定制Hooks。</p><h2 id="🔌-Other-Hooks"><a href="#🔌-Other-Hooks" class="headerlink" title="🔌 Other Hooks"></a>🔌 Other Hooks</h2><p>您可能会发现一些不太常用的内置Hook很有用。例如，useContext允许您订阅React上下文而不引入嵌套：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> locale = useContext(LocaleContext);</div><div class="line">  <span class="keyword">const</span> theme = useContext(ThemeContext);</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>useReducer允许您使用reducer管理复杂组件的本地状态：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Todos</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> [todos, dispatch] = useReducer(todosReducer);</div><div class="line">  <span class="comment">// ...</span></div></pre></td></tr></table></figure></p><p>这只是React 官网中关于Hooks的一篇大概的介绍，更加详细的使用文档，可以在官方文档中获得：<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="external">HOOKS(Proposal)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在看了React Hooks的文档之后，本英语渣渣竟然突然有了想要翻译一下这篇文档的冲动，于是就首次尝试翻译一篇英文文档,原文&lt;a href=&quot;https://reactjs.org/docs/hooks-overview.html&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
    
      <category term="-JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>燃烧</title>
    <link href="http://stan1812.github.io/2018/10/25/Burning/"/>
    <id>http://stan1812.github.io/2018/10/25/Burning/</id>
    <published>2018-10-25T14:07:19.000Z</published>
    <updated>2018-10-28T03:54:16.629Z</updated>
    
    <content type="html"><![CDATA[<p>电影，燃烧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;电影，燃烧。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Think" scheme="http://stan1812.github.io/tags/Think/"/>
    
  </entry>
  
  <entry>
    <title>元编程</title>
    <link href="http://stan1812.github.io/2018/10/24/Metaprogramming/"/>
    <id>http://stan1812.github.io/2018/10/24/Metaprogramming/</id>
    <published>2018-10-24T14:35:28.000Z</published>
    <updated>2018-12-17T10:17:06.330Z</updated>
    
    <content type="html"><![CDATA[<p>在1024这一天，先开个坑叭。</p><h3 id="什么是原编程（Mata-Programming）"><a href="#什么是原编程（Mata-Programming）" class="headerlink" title="什么是原编程（Mata Programming）"></a>什么是原编程（Mata Programming）</h3><p>很早之前就接触了元编程的一些东西，但是并没有什么很好的理解，只是觉得这个名字好牛逼，很玄幻🐸。主要还是在实际的coding中并没有直接的感触，最近又看到了相关的概念所以来简单的写点东西。</p><h3 id="不准确的翻译"><a href="#不准确的翻译" class="headerlink" title="不准确的翻译"></a>不准确的翻译</h3><p>在《你不知道的JS-ES6与未来》有这样的解释：元编程是针对程序本身的行为进行操作的编程。换句话说，它是为你程序的编程而进行的编程。 是的，很拗口。也有更详细些的这样的解释：元编程（笼统地说）是所有关于一门语言的底层机制，而不是数据建模或者业务逻辑那些高级抽象。如果程序可以被描述为 “制作程序”，元编程就能被描述为 “让程序来制作程序”。你可能已经在日常编程中不知不觉地使用到了元编程。</p><p>在接触了相关的概念之后，觉得似乎和想象中的不太一样，所以想到是否存在翻译的误解，首先从元这个字来理解好像有些问题，在中文的环境下元这个字在理解中有这样的理解：基本：单元，元件，元气（精气，根本），元素，元音。 而在概念中好像并不是这种意思，看到了有人解释这个meta的意思然后就有些理解了：</p><blockquote><p>Meta- 这个前缀在希腊语中的本意是「在…后，越过…的」，类似于拉丁语的 post-，比如 metaphysics 就是「在物理学之后」，这个词最开始指一些亚里士多德的著作，因为它们通常排序在《物理学》之后。但西方哲学界在几千年中渐渐赋予该词缀一种全新的意义：关于某事自身的某事。比如 meta-knowledge 就是「关于知识本身的知识」，meta-data 就是「关于数据的数据」，meta-language 就是「关于语言的语言」，而 meta-programming 也是由此而来，是「关于编程的编程」。<br>弄清了词源和字面意思，可知大陆将 meta- 这个前缀译为「元」并不恰当。台湾译为「后设」，稍微好一点点，但仍旧无法望文生义。也许「自相关」是个不错的选择，「自相关数据」、「自相关语言」、「自相关编程」——但是好像又太罗嗦了。</p></blockquote><p>这个翻译似乎有些问题。</p><p>这里举一个例子：</p><blockquote><p>例如，如果你为了调查对象a和另一个对象b之间的关系 —— 它们是被[[Prototype]]链接的吗？ —— 而使用a.isPrototypeOf(b)，这通常称为自省，就是一种形式的元编程。宏（JS中还没有） —— 代码在编译时修改自己 —— 是元编程的另一个明显的例子。使用for..in循环枚举一个对象的键，或者检查一个对象是否是一个“类构造器”的 实例，是另一些常见的元编程任务。</p></blockquote><h3 id="所关注的内容"><a href="#所关注的内容" class="headerlink" title="所关注的内容"></a>所关注的内容</h3><p>元编程关注以下的一点或几点：代码检视自己，代码修改自己，或者代码修改默认的语言行为而使其他代码受影响。简单的来概括，元编程中关注的方面: 代码生成(Code Generation) 反射(Reflection)</p><p>元编程的目标是利用语言自身的内在能力使你其他部分的代码更具描述性，表现力，和/或灵活性。由于元编程的 元 的性质，要给它一个更精确的定义有些困难。理解元编程的最佳方法是通过代码来观察它。<br>ES6在JS已经拥有的东西上，增加了几种新的元编程形式/特性。</p><p>Symbols 实现了的反射（Reflection within implementation）—— 你将 Symbols 应用到你已有的类和对象上去改变它们的行为。<br>Reflect 通过自省（introspection）实现反射（Reflection through introspection） —— 通常用来探索非常底层的代码信息。<br>Proxy 通过调解（intercession）实现反射（Reflection through intercession） —— 包裹对象并通过自陷（trap）来拦截对象行为。</p><h3 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h3><p>来看一个函数名的问题：这似乎是一个非常简单的不值一提的问题，但是JS就是这样，他会给你非常多的惊喜，答案会有些令人诧异地模糊。考虑如下代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">daz</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">bar: <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">bam: daz,</div><div class="line">zim() &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>在这前一个代码段中，“obj.foo()的名字是什么？”有些微妙。是”foo”，””，还是undefined？那么obj.bar()呢 —— 是”bar”还是”baz”？obj.bam()称为”bam”还是”daz”？obj.zim()呢？</p><p>另外，作为回调被传递的函数呢？就像：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line"><span class="comment">// `cb()` 的名字是什么？</span></div><div class="line">&#125;</div><div class="line">foo( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">// 我是匿名的！</span></div><div class="line">&#125; );</div></pre></td></tr></table></figure></p><p>在程序中函数可以被好几种方法所表达，而函数的“名字”应当是什么并不总是那么清晰和明确。更重要的是，我们需要区别函数的“名字”是指它的name属性 —— 是的，函数有一个叫做name的属性 —— 还是指它词法绑定的名称，比如在function bar() { .. }中的bar。<br>词法绑定名称是你将在递归之类的东西中所使用的：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (i &lt; <span class="number">10</span>) <span class="keyword">return</span> foo( i * <span class="number">2</span> );</div><div class="line"><span class="keyword">return</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>name属性是你为了元编程而使用的，所以它才是我们在这里的讨论中所关注的。<br>产生这种用困惑是因为，在默认情况下一个函数的词法名称（如果有的话）也会被设置为它的name属性。实际上，ES5（和以前的）语言规范中并没有官方要求这种行为。name属性的设置是一种非标准，但依然相当可靠的行为。在ES6中，它已经被标准化。</p><h4 id="推断"><a href="#推断" class="headerlink" title="推断"></a>推断</h4><p>但如果函数没有词法名称，name属性会怎么样呢？现在在ES6中，有一个推断规则可以判定一个合理的name属性值来赋予一个函数，即使它没有词法名称可用。<br>考虑如下代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> abc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">abc.name;<span class="comment">// "abc"</span></div></pre></td></tr></table></figure></p><p>如果我们给了这个函数一个词法名称，比如abc = function def() { .. },那么name属性将理所当然地是”def”。但是由于缺少词法名称，直观上名称”abc”看起来很合适。<br>这里是在ES6中将会（或不会）进行名称推断的其他形式：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;);<span class="comment">// name:</span></div><div class="line">(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123; .. &#125;);<span class="comment">// name:</span></div><div class="line"><span class="built_in">window</span>.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;;<span class="comment">// name:</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Awesome</span> </span>&#123;</div><div class="line"><span class="keyword">constructor</span>() &#123; .. &#125;<span class="comment">// name: Awesome</span></div><div class="line">funny() &#123; .. &#125;<span class="comment">// name: funny</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = <span class="class"><span class="keyword">class</span> <span class="title">Awesome</span> </span>&#123; .. &#125;;<span class="comment">// name: Awesome</span></div><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">foo() &#123; .. &#125;,<span class="comment">// name: foo</span></div><div class="line">*bar() &#123; .. &#125;,<span class="comment">// name: bar</span></div><div class="line">baz: <span class="function"><span class="params">()</span> =&gt;</span> &#123; .. &#125;,<span class="comment">// name: baz</span></div><div class="line">bam: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;,<span class="comment">// name: bam</span></div><div class="line">get qux() &#123; .. &#125;,<span class="comment">// name: get qux</span></div><div class="line">set fuz() &#123; .. &#125;,<span class="comment">// name: set fuz</span></div><div class="line">[<span class="string">"b"</span> + <span class="string">"iz"</span>]:</div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;,<span class="comment">// name: biz</span></div><div class="line">[<span class="built_in">Symbol</span>( <span class="string">"buz"</span> )]:</div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;<span class="comment">// name: [buz]</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> x = o.foo.bind( o );<span class="comment">// name: bound foo</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; .. &#125;).bind( o );<span class="comment">// name: bound</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; .. &#125;<span class="comment">// name: default</span></div><div class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Function</span>();<span class="comment">// name: anonymous</span></div><div class="line"><span class="keyword">var</span> GeneratorFunction =</div><div class="line"><span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;&#125;.__proto__.constructor;</div><div class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> GeneratorFunction();<span class="comment">// name: anonymous</span></div></pre></td></tr></table></figure></p><p>name属性默认是不可写的，但它是可配置的，这意味着如果有需要，你可以使用Object.defineProperty(..)来手动改变它。</p><h4 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h4><p>在“new.target”中，我们引入了一个ES6的新概念：元属性。正如这个名称所暗示的，元属性意在以一种属性访问的形式提供特殊的元信息，而这在以前是不可能的。<br>在new.target的情况下，关键字new作为一个属性访问的上下文环境。显然new本身不是一个对象，这使得这种能力很特殊。然而，当new.target被用于一个构造器调用（一个使用new调用的函数/方法）内部时，new变成了一个虚拟上下文环境，如此new.target就可以指代这个new调用的目标构造器。<br>这是一个元编程操作的典型例子，因为它的意图是从一个构造器调用内部判定原来的new的目标是什么，这一般是为了自省（检查类型/结构）或者静态属性访问。<br>举例来说，你可能想根据一个构造器是被直接调用，还是通过一个子类进行调用，来使它有不同的行为：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line"><span class="keyword">constructor</span>() &#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">new</span>.target === Parent) &#123;</div><div class="line"><span class="built_in">console</span>.log( <span class="string">"Parent instantiated"</span> );</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line"><span class="built_in">console</span>.log( <span class="string">"A child instantiated"</span> );</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Parent();</div><div class="line"><span class="comment">// Parent instantiated</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Child();</div><div class="line"><span class="comment">// A child instantiated</span></div></pre></td></tr></table></figure></p><p>这里有一个微妙的地方，在Parent类定义内部的constructor()实际上被给予了这个类的词法名称（Parent），即便语法暗示着这个类是一个与构造器分离的不同实体。</p><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>待续</p><h3 id="Proxy-amp-Reflect"><a href="#Proxy-amp-Reflect" class="headerlink" title="Proxy &amp; Reflect"></a>Proxy &amp; Reflect</h3><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>从对匿名函数的函数名推断，到告诉你一个构造器是如何被调用的元属性，你可以前所未有地在程序运行期间来调查它的结构。通用Symbols允许你覆盖固有的行为，比如将一个对象转换为一个基本类型值的强制转换。代理可以拦截并自定义各种在对象上的底层操作，而且Reflect提供了模拟它们的工具。</p><p>参考文章：<br>[译]ES6 中的元编程 系列<br>You-Dont-Know-JS<br>MDN-元编程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在1024这一天，先开个坑叭。&lt;/p&gt;
&lt;h3 id=&quot;什么是原编程（Mata-Programming）&quot;&gt;&lt;a href=&quot;#什么是原编程（Mata-Programming）&quot; class=&quot;headerlink&quot; title=&quot;什么是原编程（Mata Programmi
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>CoCo</title>
    <link href="http://stan1812.github.io/2018/10/10/CoCo/"/>
    <id>http://stan1812.github.io/2018/10/10/CoCo/</id>
    <published>2018-10-10T12:11:43.000Z</published>
    <updated>2018-10-24T14:36:53.614Z</updated>
    
    <content type="html"><![CDATA[<p>一篇感觉非常有意思的文章转载一下。转载自<a href="https://juejin.im/post/5a249066f265da430406714a" target="_blank" rel="external">@doodlewind</a></p><h2 id="内存寻梦环游记：一个变量的三重死亡"><a href="#内存寻梦环游记：一个变量的三重死亡" class="headerlink" title="内存寻梦环游记：一个变量的三重死亡"></a>内存寻梦环游记：一个变量的三重死亡</h2><h3 id="内存的世界"><a href="#内存的世界" class="headerlink" title="内存的世界"></a>内存的世界</h3><p>小 u 身高 64 位，是内存世界 number 家族里的一名浮点数变量。因为小 u 身体的二进制第一位是 0，所以按照 IEEE 754 标准，大家都把她当做女孩子来看待。她第 2 位到第 11 位的阶码并不够大，使得她看起来小巧玲珑；而她剩下的 52 个小数位十分精致，这样工作的时候和她打交道的变量舍入误差都很小，所以大家都很喜欢她。</p><p>小 u 每天的工作，是在内存世界里和其他的变量打交道，计算出有用的结果去造福人类世界。平时，在函数调用结束以后，小 u 就可以下班回到她在源代码里的家了。她的工作压力不大，不像那些身处 for 循环里名叫 i 呀 j 呀的变量那样需要不停地加班连轴转。而她的家也是自她出生以来就由人类世界里的程序员编写好的。别看那些程序员穿着邋遢，但对源代码却像对待自己的孩子一样宠爱。小 u 在源代码里的家就是用一种名叫 JavaScript 的材料建起来的，不光有五颜六色的编辑器主题来装饰，还有严谨的分号和括号来保证家里的结构的稳定和对称，让她很有安全感。</p><p>虽然有着可爱的外表、轻松的工作和舒心的家，但小 u 却还是有着自己的烦恼：她的家族出身决定了她不能有伴侣。</p><p>在 JavaScript 这种材料所在的国度里，number 家族隶属于古老的基本类型家族。除了 number 之外，那些经典的数据结构，像字符串 string 和空值 null，都属于基本类型家族。由于简单的基本类型很容易在代码里被解释器推断出来，所以他们的内存都是在一种死板的『栈』空间上预先分配好而不可变的。哪怕是和其他 number 耳鬓厮磨地加加减减，也不能真正地在一起。</p><p>而与基本类型家族相对的，则是时髦的引用类型家族。那些人类程序员青睐的所谓『面向对象编程』，说的就是这个家族。这个家族的成员复杂而多变，因此他们会被分配到广袤的『堆』空间上，相互之间经常是你中有我，我中有你的状态。比起注定孤独一生的基本类型家族，有对象的引用类型家族无疑要滋润得多。</p><p>小 u 有个不敢说出口的梦想，那就是努力成为引用类型里的一员。听说在远方的 Java 国度，有一条叫做『自动装箱』的法律能够让自己的家族看起来像引用类型家族一样，那样她也许就可以不再孤独了。</p><p>梦想归梦想，她对自己的生活其实还是挺满意的。在内存世界习惯之后，工作和生活的平衡是许多人类世界的程序员一辈子都达不到的。这样的生活一直继续着，直到有一天……</p><h3 id="闭包的诅咒"><a href="#闭包的诅咒" class="headerlink" title="闭包的诅咒"></a>闭包的诅咒</h3><p>那天像往常一样，小 u 从源代码的家里出发，通过词法分析门后，搭上了语法分析班车的轨道。班车上 JIT 的标识代表着 Just-In-Time，就好像人类世界中『JR 新干线』和『和谐号』那样，是高效、快捷的象征。</p><p>班车迅速地把小 u 载到了语法树轨道上的叶子节点站台。走下班车，站台上有一张 64 位尺寸的长椅。她坐上椅子闭上眼，等待着解释器对她的扫描和调用。</p><p>『但愿这次不要遇上粗俗的 null 值……』小 u 默念着，眼前一阵电光闪动，随着内存世界底层无数晶体管状态的改变，解释器如期读取了小 u 的值。在这条原子性的指令里，小 u 需要让解释器完全地控制自己，她从来不知道从电光闪动到再一次睁开眼睛之间，内存世界里发生了什么。</p><p>『嗯……』她如期醒来了，照理说她在醒来时还是会身处同样的站台位置，等待回程的语法树班车接她回家。</p><p>眼前还是同样的景象，不对，好像又有哪里不一样——站台的结构和布置似乎和之前别无二致，只是少了一样东西：轨道上空空荡荡，没有等待她的班车，更没有别人。难道……误点了？她打心里不相信这样低级的错误会出现频率精准的内存世界里。不过班车没来就是没来，她只好在站台上继续等待。</p><p>时间一赫兹一赫兹地经过，小 u 内心的不安和焦虑也在慢慢增加：到底发生了什么？班车是忘记我了吗？还是说提前开走了？女孩子一个人在外呆这么久是很不安全的，但是作为严谨的变量，独自行动更是内存世界里的大忌。『还是……再等等吧……』小 u 有些绝望地想。</p><p>班车还是没有到。</p><p>『不行了，我必须回源码里去啊！』等待终于让小 u 的情绪激动起来了，她开始在站台上寻找其它的出口，想要找到回家的路。轨道不能跳下去，但站台的两头有个红色的 Exit 标识，那里看起来是个可以通行的出口。不过现代编程语言国度里的变量一般从来都不这么走，因为手动的内存操作很危险。</p><p>小 u 打量四周，小心翼翼地推开了回程那头 Exit 下锈迹斑斑的门。谢天谢地，这里是有路的，并且看起来不是那么危险。她走过一段狭长的走道，走道里每隔固定的长度就会亮着一个小小的指示灯，看起来是内存地址空间的下标标识。终于，她看到了出口：一扇形状相同的 Exit 门。小 u 迫不及待地推开门，想看看自己有没有更接近家一点。</p><p>眼前的景象让她诧异：一模一样的轨道、一模一样的长椅、一模一样的站台、一模一样的 Exit，就好像自己根本没有移动过一样！</p><p>难道我走错路了吗？这不可能呀！小 u 对方向这样非 0 即 1 的状态有着绝对的自信，她知道她不会走错的。也许这段地址空间里的内容都是这样吧？没事的，再走走就不一样了吧。于是，天真的她开始了漫长的步行，然而让她一点点丧失信心的是，每一个 Exit 都通向同样的站台，毫无区别，甚至连锈迹都是一样的。『有人吗！』她开始呼救，尽管看起来有些徒劳。又这样支撑了一会，她终于感觉要放弃了，疲惫地坐在一个站台的长椅上听天由命。</p><p>……</p><p>『你迷路了吗？』</p><p>耳边一个声音响起，她骤然惊醒，蜷缩起来打量着声音的来源。这也是个 number 家族的浮点数，从第一位 1 来看是个男孩子，有着高她一个头的阶码和粗糙的小数位。</p><p>『你是谁……这又是哪里？』</p><p>『我是小 s，这里是闭包的堆空间。』</p><p>『闭包……堆？』</p><p>『是啊，我们家族的变量平时都是分配在栈上，每次调用的生命周期很快就能结束了。但是现在不知道在哪个函数里还有着对我们的引用，所以我们还没法被清除掉……』</p><p>『等等！生命周期是什么东西啊？难道我的生命还会结束吗？』</p><p>看到小 u 迷茫的样子，小 s 显得很吃惊：『难道你不知道吗？我们变量的生命一共有三重死亡呀。第一重，发生在我们离开作用域的时候，比如一个函数返回以后。这时候在上下文里就找不到我们了，我们这一重生命周期结束，但是不会被马上销毁掉。第二重，发生在内存中不再有引用我们的地方，解释器进行垃圾收集的时候。这时候我们彻底离开内存世界，回到源代码里。第三重，是人类世界里的程序员把我们的定义代码删除的时候，那时候才是最终的死亡。』</p><p>『那……难道我每次回到源码家里的时候，都……』</p><p>『是的，会发生前两重的死亡。但是只要源码没有被删除，我们就仍然存在于世界上。并且，前两重死亡发生得非常快，我们根本感觉不到。』</p><p>『可是，这样重新回到源码里的我还是我吗？』</p><p>『别问我这么深奥的问题啊……不过你要这么说的话，一个人还没有办法重复踏进两次河流呢！』</p><p>『噢……好像是这样……可是你刚才说的什么堆……』小 u 看起来还是很困惑。</p><p>『哦哦，你说这个啊！我们虽然是基本类型，但也不一定分配在栈上的。有可能引用类型会里动态地用到我们，这时候我们也有可能被分配在堆上呀。』小 s 还是在一本正经地说教。</p><p>闭包…引用类型…堆…小 u 恍然大悟，原来自己所在的空间，已经不是之前那个能够及时把她释放到回程班车上的栈空间了。由于某个函数或者引用类型此刻还有若干指向自己的地方，因此她被分配在了动态的堆空间上——这不就是她一直希望的吗！不过，由于解释器对堆空间的自动内存回收还没有运行，因此她现在只能和小 s 在这片空间里游荡，就好像被诅咒了一样。</p><p>『所以，我们能一起回去吗？』</p><h3 id="循环的泄漏"><a href="#循环的泄漏" class="headerlink" title="循环的泄漏"></a>循环的泄漏</h3><p>『本来我们肯定可以一起回去的，可感觉好奇怪，照理说解释器早该自动把我们这一带的内存都回收了，怎么到现在还是什么都没发生……』小 s 虽然看起来博闻强识，不过对于眼前的情况还是有些困惑。</p><p>『会不会这一带还有别人在使用……』小 u 的判断力好像恢复了。</p><p>『如果按正常的内存分配，到现在应该早就自动回收了呀。除非内存泄漏……啊！』小 s 好像被自己吓到了。</p><p>『那又是什么啊？』</p><p>『说来话长了……这么说吧，内存世界里一些制度比较老的国家，是让人类世界的程序员手动把我们释放掉的。这个规矩经常漏掉一些变量，给我们带来了很大的痛苦。我们 JavaScript 这边倒好一点，可以让解释器帮我们自动回收内存……』</p><p>『欸？那不是很好吗？』</p><p>『哎呀，自动回收的代码也是那帮不靠谱的程序员写的，该有的问题还是会有的呀。比如那个蹩脚的 IE 浏览器，出现循环引用的时候就会出问题……啊对了！怪不得我们出不去了！估计我们是被困在 IE 里了！』</p><p>『循环…引用…？』</p><p>『这个简单说是这样的：假如我们不是浮点数，是引用类型的对象的话，那么只要 u 这个对象有个属性指向我，而我的一个属性指向 u，这个你中有我我中有你的情况就是循环引用了啊。』</p><p>小 u 的脸忽然红了。不过迟钝的小 s 还是滔滔不绝：『现代的浏览器做内存回收的算法普遍是标记清除算法，这个算法没有循环引用问题。但是早期 IE 用了一个叫引用计数的算法，这个算法在刚才那种情况的时候引用计数就不会清零，这样内存就不会被解释器收集了……』</p><p>『啊……所以我们回不去了吗？』</p><h3 id="重生的重构"><a href="#重生的重构" class="headerlink" title="重生的重构"></a>重生的重构</h3><p>小 u 的疑问把小 s 从知识的海洋里拉了出来。现在，他们终于明白了现状：两个孤独的基本类型变量没有办法被自动回收，只要用户不停机，他们就会被永远困在这里，就像盗梦空间里那样。并且数学上已经证明，停机问题是不可解的。两人间长长的沉默降临了。</p><p>终于，小 s 打破了沉默：『其实……我想到了一个方法，可以试试。』</p><p>『嗯嗯，是什么啊？』</p><p>『我在的代码段应该还会执行，在那个时候，我想办法触发一个异常，让程序挂掉。』</p><p>『可是我们都好好地在这里了呀，已经是正确的代码怎么会报错呢？』</p><p>小 s 苦笑了一下：『看来你对 JavaScript 的奇葩一无所知啊。据说当初国父 Brendan Eich 制定基本国策的时候只用了一个周末，所以这门语言到处是暗坑，就算看起来结构工整规范的代码，那些人类程序员也经常写得乱七八糟。』</p><p>『所以，怎么……』</p><p>『比如说，虽然我是浮点数，但是其实因为我是在 if 里声明的，所以只要我愿意，我就能用一个叫做变量提升的设计缺陷，把我自己临时变成 undefined。』</p><p>『那样的话，类型就错了呀。』</p><p>小 s 又自信了起来：『对，只要我抓住那次机会，把这时候的我和其他变量做一次运算，就能把返回的类型从浮点数变成危险的 NaN 了。这样后面用到结果的地方肯定都不对，就算程序不崩溃，人类世界的用户或者程序员也能发现这个问题了。』</p><p>『他们发现了以后又能怎么样呢？』</p><p>『会重构掉我这段代码，然后你也可以回去了。』</p><p>『这样的话，一旦你的代码消失了，岂不是……』</p><p>『没事，很高兴认识你……』小 s 已经慢慢走到了站台一侧的边缘了，那里有一个左花括号挡住了他。他看准花括号前的地砖，使劲地踩了下去。一瞬间，变量提升就把他带出了作用域。没有过多少赫兹的时间，站台的地面下就开始摇晃，传来了燃烧着的报错对象从地下一层层抛出调用栈的声音。随着砰的一声巨响，报错对象撕裂了地面——这也是小 u 最后记得的场景了。</p><p>在记忆中的下一个镜头，她已经在回程的语法树班车上了。回到源代码里，然后等待着后面的调用，一切又似乎重新变得那么自然，好像什么都没有发生过。当然了，她所在的源代码模块里没有一个叫做 s 的变量，也许是在那个异常抛出之后就被人类加班加点地 hotfix 重构掉了吧。</p><p>几个版本之后，小 u 在一次代码优化中终于如愿以偿地成为了引用类型的属性。初来乍到的这个新源码家庭的时候，她看到这个 class 的属性里，来了一个熟悉的新成员。</p><p>『啊，u』</p><p>『啊，s』</p><p>异口同声地，他们说出了对方的名字。</p><p>END</p><p>后记</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一篇感觉非常有意思的文章转载一下。转载自&lt;a href=&quot;https://juejin.im/post/5a249066f265da430406714a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@doodlewind&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
      <category term="-JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Proxy &amp; Rreflect</title>
    <link href="http://stan1812.github.io/2018/09/15/ProxyRreflect/"/>
    <id>http://stan1812.github.io/2018/09/15/ProxyRreflect/</id>
    <published>2018-09-15T15:23:46.000Z</published>
    <updated>2018-12-13T07:15:16.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Proxy：更好的对象处理"><a href="#Proxy：更好的对象处理" class="headerlink" title="Proxy：更好的对象处理"></a>Proxy：更好的对象处理</h2><h3 id="Proxy概述"><a href="#Proxy概述" class="headerlink" title="Proxy概述"></a>Proxy概述</h3><p>Proxy 用来修改某些操作的默认行为，等同于在语言层面进行修改，属于一种元编程的：对编程语言进行编程。</p><p>顾名思义，Proxy的原意即是代理，Proxy 可以理解为在目标对象前架设一个拦截层，外界对该对象的访问都经过这层拦截，因此提供了一种机制来对外界的访问进行过滤和改写。<br>先来看一个示例：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;,&#123;</div><div class="line">  get:<span class="function"><span class="keyword">function</span>(<span class="params">target,key,receiver</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>`</span>)</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target,key,receiver)</div><div class="line">  &#125;,</div><div class="line">  set:<span class="function"><span class="keyword">function</span>(<span class="params">target,key,receiver</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>`</span>)</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target,key,value,receiver)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">// 以上代码对一个空对象进行了一层拦截，重新定义了属性的get，set方法，</span></div></pre></td></tr></table></figure></p><p>Proxy实际上重载了点运算符，用自己的定义覆盖了语言的原始定义。</p><h3 id="基本语法与API"><a href="#基本语法与API" class="headerlink" title="基本语法与API"></a>基本语法与API</h3><p>原生Javascript 对象所提供的Proxy的原生构造函数<code>let p = new Proxy(target, handler);</code>其中有几个概念，traps表示提供属性访问的方法，handler为包含traps的占位符对象（即属性是当执行一个操作时定义代理的行为的函数），target 用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。<br>API<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">handler.getPrototypeOf()</div><div class="line"><span class="comment">// 在读取代理对象的原型时触发该操作，比如在执行 Object.getPrototypeOf(proxy) 时。</span></div><div class="line">handler.setPrototypeOf()</div><div class="line"><span class="comment">// 在设置代理对象的原型时触发该操作，比如在执行 Object.setPrototypeOf(proxy, null) 时。</span></div><div class="line">handler.isExtensible()</div><div class="line"><span class="comment">// 在判断一个代理对象是否是可扩展时触发该操作，比如在执行 Object.isExtensible(proxy) 时。</span></div><div class="line">handler.preventExtensions()</div><div class="line"><span class="comment">// 在让一个代理对象不可扩展时触发该操作，比如在执行 Object.preventExtensions(proxy) 时。</span></div><div class="line">handler.getOwnPropertyDescriptor()</div><div class="line"><span class="comment">// 在获取代理对象某个属性的属性描述时触发该操作，比如在执行 Object.getOwnPropertyDescriptor(proxy, "foo") 时。</span></div><div class="line">handler.defineProperty()</div><div class="line"><span class="comment">// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, "foo", &#123;&#125;) 时。</span></div><div class="line">handler.has()</div><div class="line"><span class="comment">// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 "foo" in proxy 时。</span></div><div class="line">handler.get()</div><div class="line"><span class="comment">// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span></div><div class="line">handler.set()</div><div class="line"><span class="comment">// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span></div><div class="line">handler.deleteProperty()</div><div class="line"><span class="comment">// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。</span></div><div class="line">handler.ownKeys()</div><div class="line"><span class="comment">// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。</span></div><div class="line">handler.apply()</div><div class="line"><span class="comment">// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。</span></div><div class="line">handler.construct()</div><div class="line"><span class="comment">// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</span></div></pre></td></tr></table></figure></p><h3 id="Proxy能带来的"><a href="#Proxy能带来的" class="headerlink" title="Proxy能带来的"></a>Proxy能带来的</h3><p>因为在使用了Proxy后，对象的行为基本上都是可控的，所以我们能拿来做一些之前实现起来比较复杂的事情。</p><ol><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理<br>下面来看一下使用Proxy能给我们带来什么改变<h4 id="原生JS的枚举："><a href="#原生JS的枚举：" class="headerlink" title="原生JS的枚举："></a>原生JS的枚举：</h4>直接使用JS对象来代替枚举类型通常会不安全，我们所希望的枚举类型通常需要包含至少以下的特点：</li></ol><ul><li>如果不存在的话，报错。</li><li>不允许动态设置，否则报错。</li><li>不允许删除，否则报错。<br>当然TS的出现为我们解决了这个问题，我们这里单纯使用Proxy来编写一下简单的类型检测(当然使用原本的Object.definePerpoty也可实现)，<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ENUM</span>(<span class="params">object</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(object, &#123;</div><div class="line">    get(target, prop) &#123;</div><div class="line">      <span class="keyword">if</span> (target[prop]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">`Unknown enum '<span class="subst">$&#123;prop&#125;</span>'`</span>)</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    set() &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Enum is readonly'</span>)</div><div class="line">    &#125;,</div><div class="line">    deleteProperty() &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Enum is readonly'</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="使用Peoxy包装Fetch"><a href="#使用Peoxy包装Fetch" class="headerlink" title="使用Peoxy包装Fetch"></a>使用Peoxy包装Fetch</h3><p>Fetch是一个非常常用的原生API了，我们可以使用Proxy来简单的包装一下，使其变得更加的易用<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> handlers = &#123;</div><div class="line">  get (target, property) &#123;</div><div class="line">    <span class="keyword">if</span> (!target.init) &#123;</div><div class="line">      [<span class="string">'GET'</span>, <span class="string">'POST'</span>].forEach(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</div><div class="line">        target[method] = <span class="function">(<span class="params">url, params = &#123;&#125;</span>) =&gt;</span> &#123;</div><div class="line">          <span class="keyword">return</span> fetch(url, &#123;</div><div class="line">            headers: &#123;</div><div class="line">              <span class="string">'content-type'</span>: <span class="string">'application/json'</span></div><div class="line">            &#125;,</div><div class="line">            mode: <span class="string">'cors'</span>,</div><div class="line">            credentials: <span class="string">'same-origin'</span>,</div><div class="line">            method,</div><div class="line">            ...params</div><div class="line">          &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> target[property]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> FetchX = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handlers)</div><div class="line"><span class="keyword">await</span> FetchX.GET(<span class="string">'XXX'</span>)</div><div class="line"><span class="keyword">await</span> FetchX.POST(<span class="string">'XXX'</span>, &#123;</div><div class="line">  body: <span class="built_in">JSON</span>.stringify(&#123;...&#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> assert = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;,&#123;</div><div class="line">  set(target,message,value)&#123;</div><div class="line">    <span class="keyword">if</span>(!value) <span class="built_in">console</span>.error(message)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">assert[<span class="string">'I am  wuyanzu'</span>] = <span class="literal">false</span>  <span class="comment">// Error: I am not wuyanzu</span></div></pre></td></tr></table></figure><h3 id="函数的链式调用"><a href="#函数的链式调用" class="headerlink" title="函数的链式调用"></a>函数的链式调用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> pipe = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> funcStack = [];</div><div class="line">    <span class="keyword">let</span> oproxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125; , &#123;</div><div class="line">      get(target,fnName) &#123;</div><div class="line">        <span class="keyword">if</span> (fnName === <span class="string">'get'</span>) &#123;</div><div class="line">          <span class="keyword">return</span> funcStack.reduce(<span class="function">(<span class="params">val, fn</span>) =&gt;</span> fn(val) ,value);</div><div class="line">        &#125;</div><div class="line">        funcStack.push(<span class="built_in">window</span>[fnName]);</div><div class="line">        <span class="keyword">return</span> oproxy;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> oproxy;</div><div class="line">  &#125;</div><div class="line">&#125;());</div><div class="line"></div><div class="line"><span class="keyword">let</span> double = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</div><div class="line"><span class="keyword">let</span> pow    = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</div><div class="line"><span class="keyword">let</span> reverseInt = <span class="function"><span class="params">n</span> =&gt;</span> n.toString().split(<span class="string">""</span>).reverse().join(<span class="string">""</span>) | <span class="number">0</span>;</div><div class="line"></div><div class="line">pipe(<span class="number">3</span>).double.pow.reverseInt.get; <span class="comment">// 63</span></div></pre></td></tr></table></figure><h3 id="一个简单的数据响应"><a href="#一个简单的数据响应" class="headerlink" title="一个简单的数据响应"></a>一个简单的数据响应</h3><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"input"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>);</div><div class="line"><span class="keyword">const</span> p = <span class="built_in">document</span>.getElementById(<span class="string">'p'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> newObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">  get(target, key, receiver) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</div><div class="line">  &#125;,</div><div class="line">  set(target, key, value, receiver) &#123;</div><div class="line">    <span class="built_in">console</span>.log(target, key, value, receiver);</div><div class="line">    <span class="keyword">if</span> (key === <span class="string">'text'</span>) &#123;</div><div class="line">      input.value = value;</div><div class="line">      p.innerHTML = value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</div><div class="line">  &#125;,</div><div class="line">&#125;);</div><div class="line"></div><div class="line">input.addEventListener(<span class="string">'keyup'</span>, (e)=&gt; &#123;</div><div class="line">  newObj.text = e.target.value;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>相比Object.definePeproty只能代理一个属性，Proxy可以直接代理对象，这也带来了极大的方便，比如Vue由于使用的是Object.definePeproty来实现的数据劫持，所以对数组的监听，又额外进行了一些处理。之前尤雨溪发了一条微博：<br><code>这两天验证了一些 Vue 3.0 的设计，证明一些思路是可行的... Proxy 是个好东西 [doge] ​​​​</code><br>相信会有更多的惊喜的吧。</p><h2 id="Reflect：Proxy的另一面"><a href="#Reflect：Proxy的另一面" class="headerlink" title="Reflect：Proxy的另一面"></a>Reflect：Proxy的另一面</h2><p>首先我们要了解一下，为什么会新添加这么一个全局对象？如果你看过Reflect的一些函数，你就会发现，这个对象上的方法基本上都可以从Object上面找到，找不到的那些，也是可以通过对对象命令式的操作去实现的；那么为什么还要新添加一个呢？</p><ol><li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</li><li>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</li><li>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</li><li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</li></ol><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>Reflect对象一共有 13 个静态方法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">Reflect</span>.apply(target, thisArg, args)</div><div class="line"><span class="built_in">Reflect</span>.construct(target, args)</div><div class="line"><span class="built_in">Reflect</span>.get(target, name, receiver)</div><div class="line"><span class="built_in">Reflect</span>.set(target, name, value, receiver)</div><div class="line"><span class="built_in">Reflect</span>.defineProperty(target, name, desc)</div><div class="line"><span class="built_in">Reflect</span>.deleteProperty(target, name)</div><div class="line"><span class="built_in">Reflect</span>.has(target, name)</div><div class="line"><span class="built_in">Reflect</span>.ownKeys(target)</div><div class="line"><span class="built_in">Reflect</span>.isExtensible(target)</div><div class="line"><span class="built_in">Reflect</span>.preventExtensions(target)</div><div class="line"><span class="built_in">Reflect</span>.getOwnPropertyDescriptor(target, name)</div><div class="line"><span class="built_in">Reflect</span>.getPrototypeOf(target)</div><div class="line"><span class="built_in">Reflect</span>.setPrototypeOf(target, prototype)</div></pre></td></tr></table></figure></p><p>上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。<br>这里关于Reflect有一篇很好的文章：<a href="https://juejin.im/post/5a0e66386fb9a04523417418" target="_blank" rel="external">ES6 中的元编程：第二部分 —— 反射（Reflect）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Proxy：更好的对象处理&quot;&gt;&lt;a href=&quot;#Proxy：更好的对象处理&quot; class=&quot;headerlink&quot; title=&quot;Proxy：更好的对象处理&quot;&gt;&lt;/a&gt;Proxy：更好的对象处理&lt;/h2&gt;&lt;h3 id=&quot;Proxy概述&quot;&gt;&lt;a href=&quot;#Pr
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>理解Vue数据绑定</title>
    <link href="http://stan1812.github.io/2018/08/05/esayMVVM/"/>
    <id>http://stan1812.github.io/2018/08/05/esayMVVM/</id>
    <published>2018-08-05T13:44:26.000Z</published>
    <updated>2018-08-13T14:32:26.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Vue 实现数据绑定的方法是采用数据劫持解和发布者-订阅者的方法，通过 Objec.defineProperty()来劫持各个属性的 setter 和 getter 在数据变动的时候，触发相应的监听回调。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>实现一个监听器 Observer，对数据对象的所有属性进行监听，如有变动拿到新值并且通知订阅者</li><li>实现一个指令解析器，对各个元素节点的指令进行扫描解析，根据指令模板替换数据，以及绑定相应函数</li><li>实现一个 Watcher 连接 Observer 和 Compile 的桥梁，订阅并受到每个属性变动的通知，执行绑定的相应回调函数，更新视图</li><li>mvvm 入口函数</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>这里通过 Object.defineProperty()来给属性添加 getter 和 setter（其实这里可以使用 proxy 来实现）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> data = &#123;<span class="attr">name</span>:<span class="string">"xiaoming"</span>&#125;</div><div class="line">observe(data)</div><div class="line">data.name = <span class="string">"faker"</span> <span class="comment">//</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(!data||<span class="keyword">typeof</span> data!==<span class="string">'object'</span>)&#123;<span class="keyword">return</span>;&#125;</div><div class="line">  <span class="built_in">Object</span>.keys(data).forEach(</div><div class="line">    (key)=&gt;&#123;defineReactive(data,key,data[key])&#125;</div><div class="line">  )</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data,key,val</span>)</span>&#123;</div><div class="line">  object(val);</div><div class="line">  <span class="built_in">Object</span>.defineProperty(data,key,&#123;</div><div class="line">    enumerable:<span class="literal">true</span>,</div><div class="line">    configurable:<span class="literal">false</span>,</div><div class="line">    get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;<span class="keyword">return</span> val&#125;,</div><div class="line">    set:<span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;val&#125;</span>----&gt;<span class="subst">$&#123;newVal&#125;</span>`</span>)</div><div class="line">      val = newVal</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在已经实现了监听数据变化，之后便是如何通知订阅者，接下来要实现一个消息订阅器，我们这里维护一个数组来收集订阅者，数据变动触发 notify，再调用订阅者的 update 方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data,key,val</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</div><div class="line">  object(val);</div><div class="line">  <span class="built_in">Object</span>.defineProperty(data,key,&#123;</div><div class="line">    enumerable:<span class="literal">true</span>,</div><div class="line">    configurable:<span class="literal">false</span>,</div><div class="line">    get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;<span class="keyword">return</span> val&#125;,</div><div class="line">    set:<span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;val&#125;</span>----&gt;<span class="subst">$&#123;newVal&#125;</span>`</span>)</div><div class="line">      val = newVal</div><div class="line">      dep.notify()</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.subs = []</div><div class="line">&#125;</div><div class="line">Dep.prototype.addSub = <span class="function"><span class="keyword">function</span> (<span class="params">sub</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.subs.push(sub)</div><div class="line">&#125;</div><div class="line">Dep.prototype.notify = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.subs.foreach(<span class="function">(<span class="params">sub</span>)=&gt;</span>&#123;sub.update()&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来就是怎么向订阅器添加订阅者，上面的思路整理中我们已经明确订阅者应该是 Watcher, 而且 var dep = new Dep();是在 defineReactive 方法内部定义的，所以想通过 dep 添加订阅者，就必须要在闭包内操作，所以我们可以在 getter 里面动手脚：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(data,key,&#123;</div><div class="line">    get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="comment">// 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除</span></div><div class="line">      Dep.target&amp;&amp;dep.addDep(Dep.target)</div><div class="line">      <span class="keyword">return</span> val</div><div class="line">    &#125;,</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// watcher.js</span></div><div class="line">  Watcher.prototype=&#123;</div><div class="line">    get:<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</div><div class="line">      Dep.target = <span class="keyword">this</span></div><div class="line">      <span class="keyword">this</span>.value = data[key]</div><div class="line">      Dep.target = <span class="literal">null</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h2&gt;&lt;p&gt;Vue 实现数据绑定的方法是采用数据劫持解和发布者-订阅者的方法，通过 Objec.defineProperty()来劫持各
      
    
    </summary>
    
    
      <category term="-JS -Vue" scheme="http://stan1812.github.io/tags/JS-Vue/"/>
    
  </entry>
  
  <entry>
    <title>我不知道的JavaScript&lt;四&gt;：原型</title>
    <link href="http://stan1812.github.io/2018/07/16/dont-know-JS4/"/>
    <id>http://stan1812.github.io/2018/07/16/dont-know-JS4/</id>
    <published>2018-07-16T14:50:44.000Z</published>
    <updated>2018-09-06T08:53:25.013Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当我们在谈论原型时，我们在谈论什么？</p></blockquote><h3 id="从对象说起"><a href="#从对象说起" class="headerlink" title="从对象说起"></a>从对象说起</h3><hr><p>有一句话是这样说的 JS 中万物皆对象，这句话虽然不完全正确但是有些道理，毕竟 JS 中还是有很多特殊的复杂子类型比如函数，虽然函数也是可调用的对象，不过毕竟<code>typeOf null</code>结果都是 object [滑稽]（因为底层对象都表示为二进制，在 JS 中二进制前三位都为 0 的话会被判定为 object 类型，null 的二进制表示为全零自然会是 object）</p><p>但是还是要好好梳理下对象相关的一些东西</p><h4 id="扯些关系不大的"><a href="#扯些关系不大的" class="headerlink" title="扯些关系不大的"></a>扯些关系不大的</h4><p>数组和对象的关系源远流长，以至于要区分数组和对象都要专门使用<code>Object.prototype.toString.call([])</code>或者<code>Array.isArray()</code>来判断。对象可以像数组一样使用<code>[]</code>来访问值，数组也可以使用<code>.</code>来添加属性，只是不管使用点操作符还是[]操作符来为数组添加命名属性，数组的 length 属性都不会发生变化</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> a =[]</div><div class="line">a.test = <span class="string">"hello"</span></div><div class="line"><span class="built_in">console</span>.log(a)</div><div class="line"><span class="comment">//[test: "hello"] test: "hello" length: 0</span></div></pre></td></tr></table></figure><h4 id="对象属性描述符"><a href="#对象属性描述符" class="headerlink" title="对象属性描述符"></a>对象属性描述符</h4><p>在 ES5 之前并没有提供可以直接检测属性特性的方法,但是从 ES5 开始,属性具备了标识符：可以通过<code>Object.getOwnPropertyDescriptor({})</code>获取：<br>比如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> test = &#123;&#125;</div><div class="line"><span class="built_in">Object</span>.defineProperty(test,<span class="string">"a"</span>,&#123;</div><div class="line">  value: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(test,<span class="string">"a"</span>)</div><div class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;</div></pre></td></tr></table></figure><p>顾名思义，writeble,enumrable,configurable。0</p><h4 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h4><p>在 ES5 中可以部分改写默认操作，虽然只能应用到单个属性上，当给一个属性定义 getter 和 setter 或者两者都有的时候，这个属性会被定义成“访问描述符（与数据描述符相对）”对于访问描述符来说，JS 会忽略他们的 value 和 writeable 属性，而只关心 set 和 get、configurable、enumerable 特性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  get a()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">"b"</span>,&#123;</div><div class="line">  get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.a*<span class="number">2</span>&#125;</div><div class="line">  enumerable:<span class="literal">true</span></div><div class="line">&#125;)</div><div class="line">obj.a <span class="comment">//1</span></div><div class="line">obj.b <span class="comment">//2</span></div></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>当一个属性值为 undefined 的时候，要如何来判断是否存在？方法很多也很简单，<code>xx in obj</code>,<code>Object.getOwnProperty(&quot;xx&quot;)</code>区别在于 in 操作符会到原型链上检查，而后者不会。之后我们会详细区分。<br>Object.getOwnPropertyNames({})或者 Object.keys()返回对象的所有属性名组成的数组，这可以用来便利对象，或者使用 for in</p><p>数组中包含着内置的<code>@@iterator</code>因此我们 for of 可以直接应用到数组上，其实这样工作的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> myArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="keyword">var</span> it = myArray[<span class="built_in">Symbol</span>.iterator]() <span class="comment">//使用Symbol.iterator获取对象内部的@@iterator属性。</span></div><div class="line">it.next() <span class="comment">//&#123;value: 1, done: false&#125;</span></div><div class="line">it.next() <span class="comment">//&#123;value: 2, done: false&#125;</span></div><div class="line">it.next() <span class="comment">//&#123;value: 3, done: false&#125;</span></div><div class="line">it.next() <span class="comment">//&#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure><p>而普通的对象没有内置的@@iterator，但我们可以手写：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> obj =&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</div><div class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="built_in">Symbol</span>.iterator,&#123;</div><div class="line">  enumerable:<span class="literal">false</span>,</div><div class="line">  writeable:<span class="literal">false</span>,</div><div class="line">  configurable:<span class="literal">true</span>,</div><div class="line">  value:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> o = <span class="keyword">this</span></div><div class="line">    <span class="keyword">var</span> idx = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> ks = <span class="built_in">Object</span>.keys(o)</div><div class="line">    <span class="keyword">return</span>&#123;</div><div class="line">      next:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">          value:o[ks[idx++]],</div><div class="line">          done:(idx&gt;ks.length)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">//手动遍历</span></div><div class="line"><span class="keyword">var</span> it = obj[<span class="built_in">Symbol</span>.iterator]();</div><div class="line">it.next()</div><div class="line"><span class="comment">//for of 遍历：</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> obj)&#123;</div><div class="line">  <span class="built_in">console</span>.log(el)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="由对象到原型"><a href="#由对象到原型" class="headerlink" title="由对象到原型"></a>由对象到原型</h3><hr><p>Javascript 中的对象都会有一个特殊的<code>[[Prototype]]</code>内置属性，就是对于其他属性的引用，几乎所有的对象在创建[[Prototype]]属性的时候都会赋一个非空的值，但很快我们就会看到对象的[[Prototype]]属性可以为空，虽然少见。</p><p>[[Prototype]]属性有什么用呢?我们之前提到过，当试图引用对象的属性的时候会触发[[get]]操作，第一步是检查对象本身是否有这个属性，如果没有就继续往原型链上寻找，整个过程会持续找到匹配的属性名，或者查找完整条原型链，如果是后者，最终会返回 undefined。</p><p>那么哪里是原型链的尽头呢？所有普通的原型链最终都会指向内置的 Object.prototype /由于所有的内置对象都源于这个 Object.prototype，所以这个对象会包含很多通用的功能，比如最常用的.toString,.valueOf</p><h4 id="属性设置与屏蔽"><a href="#属性设置与屏蔽" class="headerlink" title="属性设置与屏蔽"></a>属性设置与屏蔽</h4><p>给一个对象设置一个属性并非只是添加一个新属性或者修改一个属性而已，接下来我们来解释下这个过程：</p><p><code>obj.foo = &quot;bar&quot;</code></p><p>如果 obj 包含名为 foo 的普通数据访问属性，这条语句可以修改已有的属性值</p><p>如果 foo 并不包含在 obj 中那么就向原型链上寻找，如果找不到，foo 将添加到 obj</p><p>然而如果 foo 存在于原型链上层，那么赋值语句的行为会有些怪异:</p><ul><li>如果在原型链上存在 foo 且<code>writeable:true</code> 那么将会在 obj 添加 foo，并且是屏蔽属性。</li><li>如果在原型链上存在 foo 且<code>writeable:false</code> 那么不能在 obj 添加 foo，且原型链上的 foo 不会被改写，语句会被忽略，严格模式下会报错。</li><li>如果在原型链上存在 foo 且是一个 setter 那么将会调用这个 setter<br>我们可能认为，只要向原型链上已存在的属性赋值就一定会触发屏蔽，但是在这以上三种情况中只有一种会发生屏蔽，2，3 想要触发屏蔽的话可以使用 Object.defineProperty()<br>如果原型链上也存在，obj 也存在，那么会发生屏蔽，底层的 foo 将屏蔽链上的 foo</li></ul><p>有时候会发生隐式屏蔽:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</div><div class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(obj1)</div><div class="line">obj1.a <span class="comment">// 1</span></div><div class="line">obj2.a <span class="comment">// 1</span></div><div class="line">obj1.hasOwnProperty(<span class="string">"a"</span>) <span class="comment">//true</span></div><div class="line">obj2.hasOwnProperty(<span class="string">"a"</span>) <span class="comment">//false</span></div><div class="line">obj2.a++ <span class="comment">//发生隐式屏蔽</span></div><div class="line"></div><div class="line">obj2.a <span class="comment">//2</span></div><div class="line">obj1.a <span class="comment">//1</span></div><div class="line"></div><div class="line">obj2.hasOwnProperty(<span class="string">"a"</span>) <span class="comment">//true</span></div></pre></td></tr></table></figure><p>这段代码其实还蛮有意思的。</p><h3 id="”类“"><a href="#”类“" class="headerlink" title="”类“"></a>”类“</h3><p>众所周知 JS 和传统的面向对象的语言不同，他并没有类来作为对象的抽象，JS 只有对象，他是少有的可以不通过类直接创建对象的语言。</p><p>虽然没有类，但是开发者们其实一直都在模仿类的行为，其实就是利用了函数的一种特性：所有的函数都会有一个名为 prototype 的公有且不可枚举的属性，他会指向一个对象。</p><figure class="highlight php"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">Function</span> <span class="title">Foo</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">Foo.prototype <span class="comment">//&#123;&#125;</span></div></pre></td></tr></table></figure><p>这个对象称为 Foo 的原型，因为我们通过 Foo.prototype 来访问他，但是以学习 JS 的经验来看（滑稽），顾名思义会出大问题滴（再次滑稽）。先抛开名字不谈，这个东西到底是什么？<br>之前我们讲过 new 对象时大概会发生的四个步骤，这里就要提到第二步：执行原型连接，关联到 Foo.prototype 上。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo()</div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === Foo.prototype <span class="comment">// true</span></div></pre></td></tr></table></figure><p>在面向对象的语言中，类可以被实例化多次，实例化一个类就意味着把类的行为复制到一个对象中，但是在 JS 中并没有类似的复制机制，你不能创建一个类的多个实例，只能创建多个对象，他们的[[Prototype]]关联到同一个对象上，因此在默认情况下，并不会发生复制，因此这些对象不会完全失去联系，他们是互相关联的。<br>但是事实上，我们可以认为 new Foo()所创建的这个链接其实是一种副作用，他并非直接创建关联。更直接的方法时：<code>Object.create()</code></p><p>JS 中我们并不会把一个对象（类）复制到另一个对象（实例）上，只是将他们关联起来，这个机制通常被称为原型继承，这个名称主要是为了应对面向类的语言中继承的意义，但是其实并没有表示出动态语言中对应的含义。也就是说，这里说到继承，其实算不上继承。这可能会让习惯于传统语言的开发者非常不习惯。</p><p>继承意味着复制操作，但 JS 默认并不会复制对象属性，只是会创建一个关联，这样一个对象可以通过<code>委托</code>来访问另一个对象的属性和函数，委托这个词更能准确描述 JS 中对象的关联机制。</p><p>回到之前的代码中，为神马会认为 Foo 是一个类呢？因为 new。但是事实，JS 中，对于构造函数最好的解释我认为应该是：所有带 new 的函数调用。除了这个迷惑人的东西之外，还有一个 Prototype.constructor</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Foo.prototype.constructor===Foo <span class="comment">//true</span></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo()</div><div class="line">a.constructor === Foo <span class="comment">//true</span></div></pre></td></tr></table></figure><p>Foo.prototype 默认会有一个不可枚举的 constructor 属性，这个属性引用的是与对象关联的函数（Foo），而 a 竟然也有一个 constructor 属性，指向”创建这个对象的函数“，可能你已经想到，实际上，这个.constructor 是 Foo.prototype 的。</p><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>先来看一段典型的原型继承的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">&#125;</div><div class="line">Foo.prototype.myName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span> (<span class="params">name,label</span>)</span>&#123;</div><div class="line">  Foo.call(<span class="keyword">this</span>,name)</div><div class="line">  <span class="keyword">this</span>.label=label</div><div class="line">&#125;</div><div class="line">Bar.prototype=<span class="built_in">Object</span>.create(Foo.prototype)</div><div class="line"><span class="comment">// 注意这里相当于Bar.prototype 指向了一个新的对象，constructor丢失</span></div><div class="line">Bar.prototype.myLabel=funciton()&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.label</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar(<span class="string">"a"</span>,<span class="string">"obj a"</span>)</div><div class="line">a.myName()  <span class="comment">//a</span></div><div class="line">a.myLabel() <span class="comment">//obj a</span></div></pre></td></tr></table></figure><p>这段代码的核心就是使用 Object.create()创建了一个新对象，并把新的对象内部的[[Prototype]]关联到指定的对象，也就是说，创建一个新的 Bar.prototype 对象并且把他关联到 Foo.prototype.<br>有两种可能会用的方法：<br><code>Bar.prototype=Fo.prototype</code> 这种是直接让 Bar.prototype 指向了 Foo.prototype,这样会在修改 Bar 的原型方法时其也修改了 Foo 的，这其实就没有 Bar 存在的意义了。</p><p><code>Bar.prototype=new Foo()</code>这样的确会创建一个新对象，但是可能有一些 Foo 内部的副作用。</p><p>因此，要创建一个合适的关联对象，使用 Object.create()是一个比较好的方法，但是也有缺点，就是我们创建了一个新对象，然后把旧的抛弃掉了。在 ES6 之前可以通过修改._proto_来修改，但这个方法并不是标准而且浏览器兼容会有问题，在 ES6 中，出现了<code>Object.setPrototypeOf(Bar.prototype,Foo.prototype)</code><br>也就是说我们现在有两种方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//ES6之前需要抛弃默认的Bar.prototype</span></div><div class="line">Bar.prototype=<span class="built_in">Object</span>.create(Foo.prototype)</div><div class="line"><span class="comment">//ES6之后可以直接修改</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(Bar.prototype,Foo.prototype)</div></pre></td></tr></table></figure><p>那么如何找到委托关联对象之间的关系(内省)呢？<code>a.isPrototypeOf(c)</code>,我们也可以直接获取一个对象的[[Prototype]]链:<code>Object.getPrototypeOf(c)</code>,还可以通过<code>c.__proto__ ===Foo.prototype</code>来判断 , <code>__proto__</code>的实现大概类似这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype,<span class="string">"__proto__"</span>,&#123;</div><div class="line">  get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>)</div><div class="line">  &#125;,</div><div class="line">  set:<span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">    <span class="built_in">Object</span>.setPrototypeOf(<span class="keyword">this</span>,o)</div><div class="line">    <span class="keyword">return</span> o</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;当我们在谈论原型时，我们在谈论什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;从对象说起&quot;&gt;&lt;a href=&quot;#从对象说起&quot; class=&quot;headerlink&quot; title=&quot;从对象说起&quot;&gt;&lt;/a&gt;从对象说起&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我不知道的JavaScript&lt;三&gt;：this</title>
    <link href="http://stan1812.github.io/2018/07/15/dont-know-JS3/"/>
    <id>http://stan1812.github.io/2018/07/15/dont-know-JS3/</id>
    <published>2018-07-15T13:33:13.000Z</published>
    <updated>2018-07-16T08:43:14.974Z</updated>
    
    <content type="html"><![CDATA[<p>this可以说是在JS中相当复杂甚至有时可以说是“邪乎”的一个机制，他带来了很多便利，但有时侯会让人感到有些崩溃👽</p><p>今天就来梳理下this的部分。</p><h3 id="为什么要使用this"><a href="#为什么要使用this" class="headerlink" title="为什么要使用this?"></a>为什么要使用this?</h3><p>首先来看一段代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> greeting = <span class="string">"hello"</span>+ identify.call(<span class="keyword">this</span>);</div><div class="line">  <span class="built_in">console</span>.log(greeting)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> me = &#123;<span class="attr">name</span>:<span class="string">"Faker"</span>&#125;</div><div class="line"><span class="keyword">var</span> you = &#123;<span class="attr">name</span>:<span class="string">"Uzi"</span>&#125;</div><div class="line">identify(you) <span class="comment">// Uzi</span></div><div class="line">identify(me) <span class="comment">//Faker</span></div><div class="line"></div><div class="line">speak.call(me); <span class="comment">// hello Faker</span></div><div class="line">speak.call(you);<span class="comment">// hello Uzi</span></div></pre></td></tr></table></figure></p><p>这段代码在不同的上下文对象中重复使用了函数identify和speak，下面我们来看一下不使用this时候该怎么写：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params">context</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> context.name.toUpperCase()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">spaek</span>(<span class="params">context</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> greeting = <span class="string">"hello"</span>+ identify(context);</div><div class="line">  <span class="built_in">console</span>.log(greeting)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>显然，在不使用this的时候，需要显示的来传递上下文对象，this的引入使得对象引用传递的更加优雅。</p><h3 id="对this的误解"><a href="#对this的误解" class="headerlink" title="对this的误解"></a>对this的误解</h3><h4 id="this指向函数自身？"><a href="#this指向函数自身？" class="headerlink" title="this指向函数自身？"></a>this指向函数自身？</h4><p>若只是根据字面意思来说的话似乎this的意思就是这样，虽然可以使用函数来存储一些内容，但是this的机制并没有这么简洁。</p><p>首先还是来看例子<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.count++</div><div class="line">&#125;</div><div class="line">test.count = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">  test()</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(test.count) <span class="comment">// 0</span></div></pre></td></tr></table></figure></p><p>test.count并没有像我们所期望的那样输出5，而是输出了0，很显然这说明在函数执行的时候，this并没有指向Test函数，那么this到底指向哪里了呢？其实这里是指向的全局，在浏览器中即是window。当我们打印this.window的时候，你会发现他打印的又是NaN，这也不难解释，因为你并未初始化一个window下的count，undefined++自然就成了NaN。至于为什么在这里指向Window。我们稍后再谈</p><h4 id="this指向函数的作用域？"><a href="#this指向函数的作用域？" class="headerlink" title="this指向函数的作用域？"></a>this指向函数的作用域？</h4><p>其实我很长一段时间都是这么理解的。。👀因为我确实应用这个准则解释了一些问题。虽然之后发现解释得不是很合理。其实这样理解并不正确。这里其实混淆了一些概念。</p><p>这里可以指出：this在任何时候都不指向函数的词法作用域，在JS内部，作用确实和对象类似，可见的标识符都是它的属性，但是作用域对象并不能通过JS代码访问，它存在于引擎内部。</p><p>我们依然使用例子来说明问题：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a =<span class="number">2</span>;</div><div class="line">  <span class="keyword">this</span>.bar();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line">foo() <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p><p>这里在书中说到调用this.bar()不能成功，但是在浏览器环境中是可以成功的。bar挂载到了window上。当然这不是重点，重点在于这个代码想要使用this.a和this.bar连接foo的内部作用域。然后按照作用域查找，但这是不能实现的。</p><hr><p>以上，this既不指向函数自身，也不止像函数的词法作用域。实际上this是在函数调用时才发生的绑定，他指向哪里取决于函数在哪里调用。</p><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">foo()</div></pre></td></tr></table></figure><p>首先我们应该知道声明在全局作用域中的变量就是全局对象的一个同名属性，他们实际上就是同一个东西，并不是复制得到的。</p><p>我们来分析下代码，通过分析，foo的调用位置是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定。</p><p>如果使用严格模式的话，全局对象无法使用默认绑定，this将绑定到undefined</p><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>依然还是看代码<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a:<span class="number">2</span>,</div><div class="line">  foo:foo</div><div class="line">&#125;</div><div class="line">obj.foo() <span class="comment">//2</span></div></pre></td></tr></table></figure></p><p>首先注意到foo的声明方式，及其之后是如何被当作引用属性添加到obj中，但是无论是直接在obj中定义还是先定义再添加为引用属性，这个函数严格来说都不属于obj对象</p><p>然后，调用位置会使用obj上下文来引用函数，因此可以说，函数被调用的时候obj对象包含它。</p><p>当函数引用拥有上下文对象时，隐式绑定会把函数调用的this绑定到这个上下文对象，因为调用foo时this被绑定到obj所以this.a和obj.a相同。</p><p>对象属性引用链中只有最后一层会影响调用位置。<br>举个🎂</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  a:<span class="number">1</span>,</div><div class="line">  foo:foo</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj2=&#123;</div><div class="line">  a:<span class="number">2</span>,</div><div class="line">  obj1:obj1  </div><div class="line">&#125;</div><div class="line">obj2.obj1.foo()<span class="comment">// 1</span></div></pre></td></tr></table></figure><h5 id="隐式绑定丢失"><a href="#隐式绑定丢失" class="headerlink" title="隐式绑定丢失"></a>隐式绑定丢失</h5><p>隐式绑定丢失就是被隐式绑定的函数会丢失绑定对象，然后会应用默认绑定·将this绑定到全局对象或者undifined（取决于是否是严格模式）。来看一个这里的错误用法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a:<span class="number">1</span>,</div><div class="line">  foo:foo</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = obj.foo</div><div class="line"><span class="keyword">var</span> a = <span class="string">"2"</span></div><div class="line">bar() <span class="comment">// 2</span></div></pre></td></tr></table></figure></p><p>这段代码尝试使用obj.foo将this的绑定传递到bar的调用中，但实际上bar依然是一个对函数foo的引用，应用了默认绑定。</p><p>另一种更加常见的绑定丢失发生在传入回调函数的时候：这里看一个例子<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dofoo</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">  fn()</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj =&#123;</div><div class="line">  a:<span class="number">2</span>,</div><div class="line">  foo:foo</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a =<span class="number">1</span>;</div><div class="line">dofoo(obj.foo) <span class="comment">//1</span></div></pre></td></tr></table></figure></p><p>参数传递其实是一种隐式赋值，因此我们传入函数的时候也会被隐式复制，所以结果和上个例子相同。需要注意的是，如果把函数传入语言内置的函数结果也是相同</p><h4 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h4><p>在之前分析隐式绑定的时候，我们总是会构造一个对象，通过对象中的一个属性来间接引用函数，从而把this隐式的绑定到这个对象上。<br>如果不是用这种方法该如何做呢?</p><p>这里要提到两个非常有用的函数<code>call</code>和<code>apply</code></p><p>这两方法第一个参数是一个对象，他们会把这个对象绑定到this接着在调用函数时指向这个this，因此可以直接指定this的绑定对象因此也称作显示绑定。</p><p>依然是一个简单的小例子来直观表示一下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj =&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</div><div class="line">foo.call(obj) <span class="comment">//1</span></div></pre></td></tr></table></figure></p><p>call将this绑定到了obj上。<br>硬绑定的典型应用场景一种就是创建一个包裹函数传入所有的参数并且返回接受到的所有值：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something </span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + something </div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  a: <span class="number">2</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> foo.apply(obj,<span class="built_in">arguments</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>)</div><div class="line"><span class="built_in">console</span>.log(b) <span class="comment">//5</span></div><div class="line"></div><div class="line"><span class="comment">// 我们可以稍加改动 创建一个可以重复使用的辅助函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">fn,obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> fn.apply(obj,<span class="built_in">arguments</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>硬绑定是一种非常常用的模式，所以ES5中也提供了<code>Function.prototype.bind()</code></p><h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><p>熟悉JS的同志们可能知道JS中的构造函数其实和传统面向对象语言的有非常大的不同，如果你认为他的构造函数和传统的语言一样那你可能对JS有什么误解。</p><p>JS中的new使用方法是和传统的那些面向对象语言类似的，但是他们的机制完全不同。事实上，JS中的构造函数可以说只是一个使用new操作符时被调用的函数，它并不属于某个类，也不会实例化某个类，实际上，他都算不上一个特殊的函数类型，他只是碰巧被new调用了一下而已。并不存在所谓的”构造函数“，只存在”构造调用“</p><p>在执行new的调用时，会执行以下的操作：</p><ul><li>构建一个全新的对象、</li><li>这个新对象会被执行原型连接</li><li>这个新对象绑定到函数调用的this</li><li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象</li></ul><p>我们这里暂时不关心第二步（之后也会详细梳理）</p><p>看个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>)</div><div class="line"><span class="built_in">console</span>.log(bar.a) <span class="comment">//2</span></div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"><span class="string">---</span></div><div class="line"><span class="string">### 绑定方式优先级</span></div><div class="line"><span class="string">默认绑定优先级自然是最低的，显示绑定也比隐式绑定的优先级要高，现在我们来分析下隐式绑定和new绑定的优先级级别</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">`</span><span class="string">``</span>javascript</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">some</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = some</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">foo</span>:foo&#125;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;&#125;</div><div class="line">obj1.foo(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(obj1.a) <span class="comment">//2</span></div><div class="line">obj1.foo.call(obj2,<span class="number">3</span>)</div><div class="line"><span class="built_in">console</span>.log(obj2.a) <span class="comment">//3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.foo(<span class="number">4</span>)</div><div class="line"><span class="built_in">console</span>.log(obj1.a) <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(bar.a) <span class="comment">//4</span></div></pre></td></tr></table></figure></p><p>可以看到new绑定的优先级高于隐式绑定</p><p>接下来我们来讨论一下new绑定和显示绑定的优先级问题，之前提到过，bind会创建一个新的函数这个函数会忽略他当前的this绑定(无论当前绑定对象是什么)并把提供的对象绑定到this上。但是事实上并不是完全这样。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = data</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;&#125;</div><div class="line"><span class="keyword">var</span> bar = foo.bind(obj1)</div><div class="line">bar(<span class="number">2</span>) <span class="comment">//obj1.a = 2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">1</span>)</div><div class="line"><span class="built_in">console</span>.log(obj1.a) <span class="comment">//2</span></div><div class="line"><span class="built_in">console</span>.log(baz.a)  <span class="comment">//1</span></div></pre></td></tr></table></figure></p><p>可以看到<code>bar</code>被硬绑定到<code>obj1</code>上，但是<code>new bar(1)</code>并没有把obj1.a也修改为1而是使用了new绑定，得到了一个一个名字为baz的新对象。</p><p>似乎之前所写到的bind并没有提供改变this指向的功能，事实上bind函数所提供的实现当然要复杂的多，简单的说代码会判断硬绑定函数是否会被new调用，如果是的话就会用新创建的this替换绑定的this</p><h3 id="gt-中的this"><a href="#gt-中的this" class="headerlink" title="()=&gt;{}中的this"></a>()=&gt;{}中的this</h3><p>箭头函数的this不使用4种绑定规则，而是根据外层（函数或者全局）作用域来决定this,定义时候绑定<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a</span>)=&gt;</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 =&#123; <span class="attr">a</span>:<span class="number">1</span>&#125;</div><div class="line"><span class="keyword">var</span> obj2 =&#123; <span class="attr">a</span>:<span class="number">2</span>&#125;</div><div class="line"><span class="keyword">var</span> bar = foo.call(obj1)</div><div class="line">bar.call(obj2) <span class="comment">//1</span></div></pre></td></tr></table></figure></p><p>foo内部的箭头函数会捕获调用时foo的this，由于foo的this绑定到obj1 ，bar的this也会绑定到obj1，箭头函数的绑定无法被修改（new也不行）</p><p>ES6中定义的时候绑定this的具体含义，应该继承的是父执行上下文里面的this，不是父执行上下文</p><p>简单来说类似于<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(self.a)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 =&#123; <span class="attr">a</span>:<span class="number">1</span>&#125;</div><div class="line"><span class="keyword">var</span> obj2 =&#123; <span class="attr">a</span>:<span class="number">2</span>&#125;</div><div class="line"><span class="keyword">var</span> bar = foo.call(obj1)</div><div class="line">bar.call(obj2) <span class="comment">//1</span></div></pre></td></tr></table></figure></p><hr><p>暂时写到这里<br>2018.7.16/16:43</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;this可以说是在JS中相当复杂甚至有时可以说是“邪乎”的一个机制，他带来了很多便利，但有时侯会让人感到有些崩溃👽&lt;/p&gt;
&lt;p&gt;今天就来梳理下this的部分。&lt;/p&gt;
&lt;h3 id=&quot;为什么要使用this&quot;&gt;&lt;a href=&quot;#为什么要使用this&quot; class=&quot;he
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我不知道的JavaScript&lt;二&gt;：闭包</title>
    <link href="http://stan1812.github.io/2018/07/13/dont-konw-JS2/"/>
    <id>http://stan1812.github.io/2018/07/13/dont-konw-JS2/</id>
    <published>2018-07-13T08:06:14.000Z</published>
    <updated>2018-07-15T12:42:24.947Z</updated>
    
    <content type="html"><![CDATA[<p>上篇梳理了作用域的相关基础知识，要理解闭包，作用域是相当重要的一环。闭包一直以来总是一个会出现些怪异问题的东西，之所以怪异是因为自己还是没有理解透彻，这次就来梳理一下闭包的相关问题。</p><p>闭包在JS中的地位可以说是相当重要的了，总是会在各种论坛博客上面看到各种前辈们所写的关于闭包的解析，自己也是似懂非懂，总以为自己懂了，然后偶然间突然想起来要问问自己却又说不出个所以然。所以现在就来系统的阐述一下。</p><h3 id="何为闭包"><a href="#何为闭包" class="headerlink" title="何为闭包"></a>何为闭包</h3><p>我们从前辈的总结中得到这样一个定义：当函数可以记住并且访问所在的词法作用域时，就产生了闭包，即使函数是在当前作用域之外执行。</p><p>先来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a) <span class="comment">//2</span></div><div class="line">  &#125;</div><div class="line">  bar()</div><div class="line">&#125; </div><div class="line">foo()</div></pre></td></tr></table></figure></p><p>这是一个闭包吗？</p><p>这段代码和之前嵌套作用域所使用的代码很类似，bar访问上级作用域并找到a，但是这和上面的定义似乎不是很完全贴合，有人说这属于一种闭包，有人说这并不算严格的闭包，这里我觉得，我们所关心的是闭包所带来的作用，而非是作为标准委员会来制作标准，所以这里不再争论。</p><p>再看下一个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> bar</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> baz = foo();</div><div class="line">baz() <span class="comment">//2</span></div></pre></td></tr></table></figure></p><p>这其实就是一个非常典型的闭包了。<br>来分析一下这段简单的代码的执行过程：<br>很显然，函数bar能够访问foo的内部作用域，然后foo将bar本身传递了出去，即bar函数作为返回值，中间的调用执行我们不再关注，需要注意的是，函数foo执行完毕后，其作用域是否有销毁？观察运行结果，我们发现是没有的，函数baz(其实也就是bar)在执行的时候并非在其定义时所在的词法作用域，但是他依然保留了foo内部作用域的引用，而这个引用，就叫做闭包。</p><p>这个函数在定义时词法作用域以外的地方被调用，闭包使得函数可以继续访问定义的词法作用域。且无论通过何手段将内部函数传递到其所在词法作用域以外，他都会保留对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包/</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>事实上，在实际写代码的时候我们可以发现闭包在代码中并不是一个陌生的东西，来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>)</span>&#123;</div><div class="line">  settimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;message&#125;,<span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line">wait(<span class="string">"hello"</span>)</div></pre></td></tr></table></figure></p><p>将一个内部函数timer传递给settimeout，timer具有涵盖wait(…)作用域的闭包，因此还保留有对变量message的引用<br>在wait执行1000ms后，他的内部作用于并不会消失，timer依然保留着wait作用域的闭包。<br>更深入的来说，从settimeout的异步运行机制我们可以知道，他会被送入macortask等待执行，settimeout会持有一个对参数的引用，也就是timer，函数会调用这个函数，也就是timer函数，词法作用域保持完整。</p><p>事实上，只要使用了回调函数，那么就在使用闭包。</p><h4 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h4><p>一般认为立即执行函数是典型的闭包例子，但是若以之前试图解释的定义来看，这似乎并非是一个无异议的闭包实例<br>举个🎂；<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">2</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(a)&#125;)()</div></pre></td></tr></table></figure></p><p>我们其实可以这样理解，首先，函数并非是在所定义的词法作用域之外执行，其次我们可以理解为函数在执行时向上级作用域（这里也是全局作用域）找到了a，只是通过了普通的词法作用域查找而非闭包中找到的。</p><p>但是正像之前所说的那样有不同的概念，他确实可以说是创建了闭包。因为他保存了自身的状态。</p><h4 id="闭包与循环"><a href="#闭包与循环" class="headerlink" title="闭包与循环"></a>闭包与循环</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">    settimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(i)&#125;,<span class="number">1000</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>依然是之前就提到过的一个问题，虽然之前已经解释过这里还是再放一下：<br>现在若要使用闭包解决：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">counter</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">   (<span class="function">(<span class="params">i</span>)=&gt;</span> settimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(i),<span class="number">1000</span>))(i)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="闭包与模块设计"><a href="#闭包与模块设计" class="headerlink" title="闭包与模块设计"></a>闭包与模块设计</h4><p>在ES6的import export诞生之前，可以说模块的设计可能会直接接触最最典型的闭包应用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Moudle</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> something = <span class="string">"something"</span>;</div><div class="line">  <span class="keyword">var</span> somethingElse = <span class="string">"sometingElse"</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">saySomething</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(something)</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">saySomethingElse</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(somethingElse)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    saySomething:saySomething,</div><div class="line">    somethingElse:somethingElse</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是一个在之前可能会写的代码，他很直观地体现了闭包的作用。</p><p>当然这只是一个方便理解的demo，实际的使用中，这样是肯定不能用的。</p><p>但我们可以以此归纳出：</p><ol><li>为创建内部作用域而调用了一个包装函数</li><li>包装函数返回值必须至少包括一个对内部函数的引用，这样就会创建包含整个包装函数内部作用域的闭包。<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3></li></ol><p>我们现在来简要的总结一下：<br>可以说：当函数能够记住并访问所在的词法作用域时，即使函数在他的词法作用域之外执行，这事就产生了闭包。</p><hr><p>下篇来梳理下this</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇梳理了作用域的相关基础知识，要理解闭包，作用域是相当重要的一环。闭包一直以来总是一个会出现些怪异问题的东西，之所以怪异是因为自己还是没有理解透彻，这次就来梳理一下闭包的相关问题。&lt;/p&gt;
&lt;p&gt;闭包在JS中的地位可以说是相当重要的了，总是会在各种论坛博客上面看到各种前辈
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>我不知道的JavaScript&lt;一&gt;：作用域</title>
    <link href="http://stan1812.github.io/2018/07/12/dont-konw-js1/"/>
    <id>http://stan1812.github.io/2018/07/12/dont-konw-js1/</id>
    <published>2018-07-12T14:13:04.000Z</published>
    <updated>2018-07-15T12:42:36.181Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来对于JS总是有一些一知半解的东西，因为这个假期没有留校，也还没有去找实习，就当给自己一些“私人时间”来对之前不求甚解的东西来梳理一遍吧。</p><h3 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h3><p>所有语言都有作用域，这是一种语言的基本功能之一，就是能够存储变量的值，并且能够在之后对之进行访问和修改，也正是因为这种存储和访问变量的能力将<strong>状态</strong>带给了程序。要将变量引入程序就带来了相应的其他问题，怎么存，如何找到他们。相应的就需要一套规则来存储变量，并且之后可以方便的找到这些变量，这套规则就是作用域了。</p><h4 id="1-1-编译"><a href="#1-1-编译" class="headerlink" title="1.1 编译"></a>1.1 编译</h4><p>虽然JS是一门脚本语言，但是他也是一门“编译语言”，与传统C，JAVA等不同的是，他并非是提前编译的，而是在运行时进行编译（V8），JS的编译过程大概经过这几个过程：</p><ul><li>分词/词法分析（Tokenizing/Lexing）这个过程将字符串分解成对有意义的代码块，这些代码块被称为词法单元（Token）比如<code>var a = 1;</code> 这段代码会被分解为“var、a、=、1、；”</li><li>解析/语法分析（Parsing） 这个过程将词法单元流转换为一个由元素嵌套所构成的代表程序语法机构的抽象语法书（AST，Abstract Syntax Tree）</li><li>代码生成 AST树转化成可执行代码的过程。</li></ul><p>以上可以说是非常笼统概括的一个简单的编译过程，事实上，JS的编译解释过程要复杂得多，中间还要包括比如说在词法分析和代码生成阶段的特定处理步骤来对运行的性能、冗余元素进行优化等。很容易想到，因为JS的编译发生在你要运行代码前，所以引擎使用了各种方法来使编译速度能够提升上来。</p><h4 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h4><p> 既然作用域是根据名称查找变量的一套规则，那么在实际的使用中，就需要同时顾及几个作用域。</p><p> 当一个函数或块嵌套在另一个快或者函数中的时候，就发生了作用域的嵌套。因此，在当前的作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量（全局作用域为止）这其实也就是遍历嵌套作用域的规则。</p><p> 一个很简单的例子：<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(a+b);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">foo(<span class="number">2</span>) <span class="comment">// 4</span></div></pre></td></tr></table></figure></p><p> 对b的RHS引用无法在函数foo内部完成，于是到上一层作用域中寻找</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>作用域有两种基本的工作模型：词法作用域和动态作用域。词法作用域较为普通，大多数语言都采用这种模式，而动态作用域则也仍有一些语言在使用。</p><h4 id="2-1-词法阶段"><a href="#2-1-词法阶段" class="headerlink" title="2.1 词法阶段"></a>2.1 词法阶段</h4><p>之前提到，大多数的语言编译器的第一个工作阶段叫做词法化，这也是词法作用域的名称来历的基础。</p><p>简单地说，词法作用域就是定义在词法阶段的作用域，也就是说，是由你在写代码的时候将代码放在哪里决定的，因此大部分情况下当词法分析器处理代码的时候会保持作用域不变。</p><p>来看一个例子；<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;            <span class="comment">// 1</span></div><div class="line">  <span class="keyword">var</span> b = a * <span class="number">2</span>;            <span class="comment">// 2</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a,b,c</span>)</span>&#123;      <span class="comment">// 3</span></div><div class="line">    <span class="built_in">console</span>.log(a,b,c);</div><div class="line">  &#125;</div><div class="line">  bar(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">&#125;</div><div class="line">foo(<span class="number">2</span>);</div></pre></td></tr></table></figure></p><p>我们把他理解为三层机构</p><ol><li>包含着全局作用域，只有一个标识符foo</li><li>包含着foo所创建的作用域，其中有 a  bar b</li><li>包含bar 创建的作用域， 只有c一个标识符</li></ol><p>现在暂时认为作用域尤其对应的代码块写在哪里决定，是逐级包含的</p><h4 id="2-2-查找"><a href="#2-2-查找" class="headerlink" title="2.2 查找"></a>2.2 查找</h4><p>作用域间的结构和位置关系给引擎提供了足够的位置信息，引擎使用这些信息来查找标识符的位置<br>作用域查找会在找到第一个匹配的标识符时停止，在多层的嵌套作用域中可以定义同名的标识符，这里叫作“遮蔽效应”</p><h4 id="2-3-欺骗词法"><a href="#2-3-欺骗词法" class="headerlink" title="2.3 欺骗词法"></a>2.3 欺骗词法</h4><p>既然词法作用域完全由函数的声明位置来决定，那么如何来在运行时改变词法作用域呢？<br>到了在众多风格指南中都会明令禁止使用的部分了:eval和with</p><ul><li><p>eval</p><p>eval接受一个字符串为参数，将其中的内容视为书写时就存在这个位置的代码。<br>也就是说，在进行词法分析的时候，eval内部的代码假装自己本来就在那里，而引擎也并不拆穿他，如常地进行词法作用域查找<br>看一个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str,a</span>)</span>&#123;</div><div class="line">  <span class="built_in">eval</span>(str);</div><div class="line">  <span class="built_in">console</span>.log(a,b);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">foo(<span class="string">"var b = 3;"</span>,<span class="number">1</span>) <span class="comment">//1,3</span></div></pre></td></tr></table></figure><p>这段代码所做的其实也就是在foo的作用域中创建了新的变量b，并遮蔽了外部的同名变量（严格模式下eval将拥有自己的词法作用域）</p></li><li><p>with<br>with通常被当作重复引用同一个对象的多个属性的快捷方式比如:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">  age: <span class="number">10</span>,</div><div class="line">  weight: <span class="number">40</span>,</div><div class="line">  height: <span class="number">1.5</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">with</span>(xiaoming)&#123;</div><div class="line">  age: <span class="number">12</span>,</div><div class="line">  weight: <span class="number">45</span>,</div><div class="line">  height: <span class="number">1.6</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是在with的使用过程中可能会：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">with</span>(obj)&#123;</div><div class="line">    a = <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">a</span>:<span class="number">3</span>&#125;</div><div class="line"><span class="keyword">var</span> o2 = &#123;<span class="attr">b</span>:<span class="number">3</span>&#125;</div><div class="line">foo(o1)  <span class="comment">// o1.a = 2</span></div><div class="line">foo(o2)  <span class="comment">// o2.a = undefined window.a = 2</span></div></pre></td></tr></table></figure><p>尽管with块可以将一个对象处理成词法作用域，但是这个块内声明的var并不会限制在这个块的作用域，而是被添加到with所处的函数作用域中。</p></li></ul><h3 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h3><h4 id="3-1函数作用域"><a href="#3-1函数作用域" class="headerlink" title="3.1函数作用域"></a>3.1函数作用域</h4><p>Javascript具有基于函数的作用域吗，这意味着每声明一个函数都会为其创建作用域<br>首先看个例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> c = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line">bar(); <span class="comment">// bar is not defined</span></div><div class="line"><span class="built_in">console</span>.log(a,b,c) <span class="comment">// all failed</span></div></pre></td></tr></table></figure></p><p>函数作用域的含义是指：属于这个函数的全部变量都可以在整个函数的范围内使用和复用（嵌套作用域也可）</p><h4 id="3-2-隐藏内部实现"><a href="#3-2-隐藏内部实现" class="headerlink" title="3.2 隐藏内部实现"></a>3.2 隐藏内部实现</h4><p>在写代码的时候，我们一般会遵照最小特权或最小暴漏原则，即：在软件设计中，应最小限度的暴漏必要内容，而将其他内特容都隐藏起来。</p><p>这个原则可以引申到如何选择作用域来包含变量和函数。</p><p>简单地说，通常我们写代码是先声明一个函数再向里面加上代码，但是我们也经常做一些相反的事情，我们发现一段代码可以更加独立，于是我们抽出这段代码来封装成新的函数。其实就是将这些代码隐藏了，而结果就是，在这些代码的周围创建了新的作用域，可以说，把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。</p><h4 id="3-3-立即执行函数"><a href="#3-3-立即执行函数" class="headerlink" title="3.3 立即执行函数"></a>3.3 立即执行函数</h4><p>我们知道在代码外添加包装函数可以将内部的变量和函数“隐藏”起来，外部作用域无法访问包装函数内部的内容，但是很显然，这还需要一个函数名（将污染其所在作用域）并且还需显式调用函数才有效。上帝说要有立即执行函数于是就有了：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">2</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line">  <span class="built_in">console</span>.log(a)</div><div class="line">  &#125;)();</div><div class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 2</span></div></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;b()&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;)</div></pre></td></tr></table></figure><h4 id="3-4块作用域"><a href="#3-4块作用域" class="headerlink" title="3.4块作用域"></a>3.4块作用域</h4><p>先来一个非常简单的例子来引出块作用域：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(i)&#125;,<span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">test()</div></pre></td></tr></table></figure></p><p>很可惜JavaScript直接来看的话并没有块级作用域，但是其实也是有的：</p><ol><li>with</li><li><p>try/catch<br>在ES3中，try/catch会创建一个块作用域，其中声明的变量只有catch内部有效</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">  <span class="literal">undefined</span>();</div><div class="line">&#125;<span class="keyword">catch</span>(err)&#123;<span class="built_in">console</span>.log(err)&#125;</div><div class="line"><span class="built_in">console</span>.log(err)<span class="comment">//  err not defined</span></div></pre></td></tr></table></figure></li><li><p>ES6的出现改变了这一乱象，let const关键字可以将变量绑定到任意作用域上，也就是说，let为其声明得的变量隐式的附加在了一个已经存在的块级作用域上。</p><h4 id="3-5变量提升"><a href="#3-5变量提升" class="headerlink" title="3.5变量提升"></a>3.5变量提升</h4><p>Javascript的代码并不完全按照从上到下执行</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 1</span></div><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> a;</div><div class="line"><span class="built_in">console</span>.log(a) <span class="comment">//2</span></div><div class="line"></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(a) <span class="comment">//undefined</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</div></pre></td></tr></table></figure></li></ol><p>变量和函数的声明都会在代码执行之前被处理</p><p>比如<code>var a = 2</code>解释器会将其认为是两段代码<code>var a</code> <code>a = 2</code>,首先是声明，其后是赋值，定义声明是在编译阶段进行的，赋值会留在原地等待执行阶段。</p><p>也就是说：2中的代码的执行顺序是这样的：<code>var a ;console.loe(a); a = 2</code></p><p>这个过程好像变量和函数声明被移动到了最上面，这就叫_<em>提升</em></p><ul><li><p>函数会被提升但函数表达式不会被提升：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">foo() <span class="comment">// success</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">foo() <span class="comment">// TypeError</span></div><div class="line"><span class="keyword">var</span> foo =<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure></li><li><p>函数优先</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">foo() <span class="comment">// 1</span></div><div class="line"><span class="keyword">var</span> foo;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  cosnole.log(<span class="number">2</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>先写到这里，下一篇将对闭包来进行梳理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直以来对于JS总是有一些一知半解的东西，因为这个假期没有留校，也还没有去找实习，就当给自己一些“私人时间”来对之前不求甚解的东西来梳理一遍吧。&lt;/p&gt;
&lt;h3 id=&quot;一、作用域&quot;&gt;&lt;a href=&quot;#一、作用域&quot; class=&quot;headerlink&quot; title=&quot;一、
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>从头实现一个mini Redux</title>
    <link href="http://stan1812.github.io/2018/06/14/mini-redux/"/>
    <id>http://stan1812.github.io/2018/06/14/mini-redux/</id>
    <published>2018-06-14T14:58:28.000Z</published>
    <updated>2018-06-14T15:00:26.833Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
      <category term="React" scheme="http://stan1812.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>JS的内存管理</title>
    <link href="http://stan1812.github.io/2018/06/06/JS-memary-mannager/"/>
    <id>http://stan1812.github.io/2018/06/06/JS-memary-mannager/</id>
    <published>2018-06-06T04:10:57.000Z</published>
    <updated>2018-06-06T05:02:47.014Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS中的内存模型"><a href="#JS中的内存模型" class="headerlink" title="JS中的内存模型"></a>JS中的内存模型</h3><h4 id="JS基本类型与栈"><a href="#JS基本类型与栈" class="headerlink" title="JS基本类型与栈"></a>JS基本类型与栈</h4><p>JS基本类型已经很清楚了：null、undefined、String、Number、Boolean</p><p>JS中的这些基础类型，有固定的大小，一般会保存在栈中（闭包除外），由系统自动分配内存空间，基础数据类型都是按值访问。</p><h4 id="JS引用类型与堆"><a href="#JS引用类型与堆" class="headerlink" title="JS引用类型与堆"></a>JS引用类型与堆</h4><p>其他语言不同，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JS不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以粗浅地理解为保存在栈内存中的一个地址，该地址与堆内存的实际值相关联。</p><h3 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h3><p> JS环境中分配的内存一般有如下生命周期：</p><ul><li>内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存</li><li>内存使用：即读写内存，也就是使用变量、函数等</li><li>内存回收：使用完毕，由垃圾回收自动回收不再使用的内存</li></ul><p>在所有语言中第一和第二部分都很清晰。最后一步在底层语言中很清晰，但是在像JavaScript 等上层语言中，这一步是隐藏的、透明的。</p><p>分配和内存使用部分不再说了</p><h4 id="内存的回收"><a href="#内存的回收" class="headerlink" title="内存的回收"></a>内存的回收</h4><p>大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。</p><p>高级语言解释器嵌入了“垃圾回收器”，来跟踪内存的分配和使用，当分配的内存不再使用时，自动释放它。但是这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>JS中目前有两种垃圾回收的比较通用的算法</p><h4 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h4><p>这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123; </div><div class="line">  a: &#123;</div><div class="line">    b:<span class="number">2</span></div><div class="line">  &#125;</div><div class="line">&#125;; </div><div class="line"><span class="comment">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o</span></div><div class="line"><span class="comment">// 很显然，没有一个可以被垃圾收集</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> o2 = o; <span class="comment">// o2变量是第二个对“这个对象”的引用</span></div><div class="line"></div><div class="line">o = <span class="number">1</span>;      <span class="comment">// 现在，“这个对象”的原始引用o被o2替换了</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> oa = o2.a; <span class="comment">// 引用“这个对象”的a属性</span></div><div class="line"><span class="comment">// 现在，“这个对象”有两个引用了，一个是o2，一个是oa</span></div><div class="line"></div><div class="line">o2 = <span class="string">"yo"</span>; <span class="comment">// 最初的对象现在已经是零引用了</span></div><div class="line">           <span class="comment">// 他可以被垃圾回收了</span></div><div class="line">           <span class="comment">// 然而它的属性a的对象还在被oa引用，所以还不能回收</span></div><div class="line"></div><div class="line">oa = <span class="literal">null</span>; <span class="comment">// a属性的那个对象现在也是零引用了</span></div><div class="line">           <span class="comment">// 它可以被垃圾回收了</span></div></pre></td></tr></table></figure></p><p>限制：循环引用</p><p>该算法有个限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</div><div class="line">  o.a = o2; <span class="comment">// o 引用 o2</span></div><div class="line">  o2.a = o; <span class="comment">// o2 引用 o</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">"boom!"</span>;</div><div class="line">&#125;</div><div class="line">f();</div></pre></td></tr></table></figure></p><h5 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h5><p>IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄漏：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> div;</div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  div = <span class="built_in">document</span>.getElementById(<span class="string">"myDivElement"</span>);</div><div class="line">  div.circularReference = div;</div><div class="line">  div.lotsOfData = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).join(<span class="string">"*"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>在上面的例子里，myDivElement 这个 DOM 元素里的 circularReference 属性引用了 myDivElement，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 lotsOfData 属性)，而这个数据占用的内存将永远不会被释放。</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>现代的浏览器已经不再使用引用计数算法了。现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的。</p><p>标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。</p><p>从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。但反之未必成立。</p><p>根据这个概念，上面的例子可以正确被垃圾回收处理了。当div与其时间处理函数不能再从全局对象出发触及的时候，垃圾回收器就会标记并回收这两个对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JS中的内存模型&quot;&gt;&lt;a href=&quot;#JS中的内存模型&quot; class=&quot;headerlink&quot; title=&quot;JS中的内存模型&quot;&gt;&lt;/a&gt;JS中的内存模型&lt;/h3&gt;&lt;h4 id=&quot;JS基本类型与栈&quot;&gt;&lt;a href=&quot;#JS基本类型与栈&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Serious JavaScript</title>
    <link href="http://stan1812.github.io/2018/04/23/seriouslyJavascript/"/>
    <id>http://stan1812.github.io/2018/04/23/seriouslyJavascript/</id>
    <published>2018-04-23T05:43:08.000Z</published>
    <updated>2018-04-23T06:23:35.420Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，JavaScript是一门非常严谨的语言。</p><p>比如：<br><!-- ```javascript0 == "0" // true0 == []  // true//so =>"0" == [] // ?// false``` --></p><p><img src="/imgs/seriousJS/carbon.png" alt=""></p><!-- ```javascriptparseInt(0.000001)  // # => 0parseInt(0.0000001) // # => 1``` --><p><img src="/imgs/seriousJS/carbon1.png" alt=""></p><!-- ```javascriptconsole.log([1] + [1]) //11console.log([1] + [1] - [1]) //10``` --><p><img src="/imgs/seriousJS/carbon2.png" alt=""></p><!-- ```javascriptlet bool = new Boolean(false)if(bool)  console.log("JS is amazing")  // JS is amazing``` --><p><img src="/imgs/seriousJS/carbon3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;众所周知，JavaScript是一门非常严谨的语言。&lt;/p&gt;
&lt;p&gt;比如：&lt;br&gt;&lt;!-- 
```javascript
0 == &quot;0&quot; // true
0 == []  // true
//so =&gt;
&quot;0&quot; == [] // ?
// false
``` --&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 枚举类型的一些理解</title>
    <link href="http://stan1812.github.io/2018/04/14/javaEnum/"/>
    <id>http://stan1812.github.io/2018/04/14/javaEnum/</id>
    <published>2018-04-13T16:15:20.000Z</published>
    <updated>2018-04-14T09:28:26.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说点废话"><a href="#说点废话" class="headerlink" title="说点废话"></a>说点废话</h3><p>  在开始学习JAVA之后，写习惯了Javascript的我，首先意识到的是好繁琐，比如在接触JAVA中的枚举类型之后，这在JS中想要实现重写一些方法，以及其他一些类似的效果其实从语法上来讲要简单的不少，虽然Javascript最初是JS之父用了10多天写出了的，甚至有一一部分直接抄的JAVA比如Date类，（虽然抄来的Date一直被吐槽不好用，好像打算要重写？）</p><p>  甚至连起名字都是为了蹭一波JAVA的名气。并且面向对象的实现方式也截然不同，一个是纯正的基于对象的继承，另一个是基于原型链的继承。甚至有人调侃真的OOP和假的OOP。。</p><p>  不过虽然实现方式不一样，但是一些设计思想感觉还是类似的，之前总有人说JAVA和Javascript的区别就是斑马和斑马线的区别，现在来想一想其实这两种语言还是类似的地方的，尤其是在ES6中的Class出现之后，Class ，extends 等等语法糖的出现，给人感觉更像了///可能JS作为一个一开始并不被看好的语言随着应用范围越来越广，使用JS、构建的项目也越来越大，想要变得更牛逼似乎有一种更适合于工程化的东西出现了吧。</p><h3 id="JAVA的枚举类型"><a href="#JAVA的枚举类型" class="headerlink" title="JAVA的枚举类型"></a>JAVA的枚举类型</h3><p>先来举个最常用的栗子🎂 ：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Colors &#123;</div><div class="line">  RED,BLUE,BLACK,YELLOW,GREEN;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 简单调用：Colors.RED</span></div></pre></td></tr></table></figure></p><p>这是最基本的使用方法。但是其实并没有展现出JAVA的枚举类型的用途，有点人才埋没。</p><p>再举一个目前用的比较多的一种使用方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Tips &#123;</div><div class="line">  WIN(<span class="string">"you win"</span>),LOSE(<span class="string">"you lose"</span>);</div><div class="line">  <span class="keyword">private</span> String tip;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Tips</span><span class="params">(String tip)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.tip = tip;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.tip;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">System.out.println(Tips.WIN)</div><div class="line"><span class="comment">// you win</span></div></pre></td></tr></table></figure><p>在这段代码中，我们简单的保存了一些基本的提示信息,重写tostring方法,这在JS里面其实可以说是很常见了，不同的是修改的原型链上的方法，不禁感到非常亲切。</p><p>在看到这种用法之后，很疑惑，WIN和LOSE，看起来很像是一个函数，但是很不理解在初始化的时候到底是怎么操作的，以至于认为在调用的时候是调用的一个名为WIN的方法，于是就反编译了编译生成的class文件：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">➜  src javap Tips.class</div><div class="line">Compiled from <span class="string">"Tips.java"</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Tips</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Tips</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tips WIN;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tips LOSE;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Tips[] values();</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tips <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</div><div class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</div><div class="line">  <span class="keyword">static</span> &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在看到了反编译的文件之后才算明白，所创建的枚举类型实例（且为final类型）继承自Java的Enum类，<br>而在内部的编译中，其实是遍历生成以所写内容命名的Tips类的实例，且生成的实例就能为final类型，不可继承，因为是static类型由Tips类所属，所以可以直接调用，比如：<code>Tips.WIN</code>.<br>因为重写了构造方法Tips(),并声明了私有变量tip，所以在生成实例的时候，初始化各个实例的tip为所传入的内容。然后重写toString方法，在调用的时候，返回tip。效果就是实现了，当然重写类的toString方法可能一般并不提倡，以为在JS里面也同样是要避免污染原型链的，这里应该是类似的。</p><p>由于WIN（以WIN为例）实质上是Tips类的一个static的对象，为全局共有,当然可以给其创建封装新的接口，比如，<br>比如：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTip</span> <span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.tip;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>需要注意的一点是，这个getTip方法是属于实例的还是属于class的？也就是说他是类方法还是实例方法？<br>再来反编译一下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">➜  src javap Tips.class</div><div class="line">Compiled from <span class="string">"Tips.java"</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Tips</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Enum</span>&lt;<span class="title">Tips</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tips WIN;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tips LOSE;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Tips[] values();</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tips <span class="title">valueOf</span><span class="params">(java.lang.String)</span></span>;</div><div class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</div><div class="line">  <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getTip</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</div><div class="line">  <span class="keyword">static</span> &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为在JS里构造函数中所写的方法，是属于实例的，即每初始化一个实例对象就会重新声明一个属于该对象的重名方法。浪费了内存。想要使其共享，就要将函数写到prototype上，所以在这里想了一下，不过在查了一些东西之后发现，这里的方法，即使并未写在构造函数里面，只要是非静态方法其就是实例方法。。似乎在JS和JAVA中，构造函数的概念及作用并不完全相同。与JS中使用工厂模式初始化的对象相比，JAVA中的类与JS的构造函数来对比更为合适一些。</p><h3 id="Enum抽象类常见方法"><a href="#Enum抽象类常见方法" class="headerlink" title="Enum抽象类常见方法"></a>Enum抽象类常见方法</h3><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">返回类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">compareTo(E o)</td><td style="text-align:left">int</td><td style="text-align:left">比较此枚举与指定对象的顺序</td></tr><tr><td style="text-align:left">equals(Object other)</td><td style="text-align:left">boolean</td><td style="text-align:left">当指定对象等于此枚举常量时，返回 true。</td></tr><tr><td style="text-align:left">name()</td><td style="text-align:left">String</td><td style="text-align:left">返回此枚举常量的名称，在其枚举声明中对其进行声明</td></tr><tr><td style="text-align:left">ordinal()</td><td style="text-align:left">int</td><td style="text-align:left">返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零）</td></tr><tr><td style="text-align:left">toString()</td><td style="text-align:left">String</td><td style="text-align:left">返回枚举常量的名称，它包含在声明中</td></tr><tr><td style="text-align:left">getDeclaringClass()</td><td style="text-align:left">Class&lt;?&gt;</td><td style="text-align:left">返回与此枚举常量的枚举类型相对应的 Class 对象</td></tr></tbody></table><p>大概就是这样叭🚀</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;说点废话&quot;&gt;&lt;a href=&quot;#说点废话&quot; class=&quot;headerlink&quot; title=&quot;说点废话&quot;&gt;&lt;/a&gt;说点废话&lt;/h3&gt;&lt;p&gt;  在开始学习JAVA之后，写习惯了Javascript的我，首先意识到的是好繁琐，比如在接触JAVA中的枚举类型之后，这在
      
    
    </summary>
    
    
      <category term="JAVA" scheme="http://stan1812.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊前端各种宽高左右</title>
    <link href="http://stan1812.github.io/2018/04/13/heightInHtml/"/>
    <id>http://stan1812.github.io/2018/04/13/heightInHtml/</id>
    <published>2018-04-13T15:35:18.000Z</published>
    <updated>2018-04-23T06:23:28.343Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>之前对DOM接口中各种height，height，scrollHeight，clientHeight，clientWidth等等概念有大概的了解，但是在想理清其概念的时候却发现了挺多的问题，概念有些模糊，在翻了写文档做了些测试之后来写一篇总结。</p><h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">offset</th><th style="text-align:left">scroll</th><th style="text-align:left">client</th></tr></thead><tbody><tr><td style="text-align:left">Height</td></tr><tr><td style="text-align:left">Left</td></tr><tr><td style="text-align:left">Top</td></tr><tr><td style="text-align:left">Width</td></tr></tbody></table><h4 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h4><ul><li><p>offsetleft:margin  + padding</p></li><li><p>offsettop:margin + padding;</p></li><li><p>offsetwidth:本身的宽度+内边距左右+边框左右;</p></li><li><p>offsetHeight:same</p><h4 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h4></li><li><p>Element.scrollHeight :只读,指一个元素内容高度，包括由于溢出导致的视图中不可见内容。没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同。包括元素的padding，但不包括元素的border和margin。scrollHeight也包括 ::before 和 ::after这样的伪元素。</p></li><li><p>Element.scrollTop: 可写 ,获取或设置一个元素的内容垂直滚动的像素数。一个元素的 scrollTop 值是这个元素的顶部到它的最顶部可见内容（的顶部）的距离的度量。当一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为0。如果一个元素不能被滚动（例如，它没有溢出，或者这个元素有一个”non-scrollable”属性）， scrollTop将被设置为0。设置scrollTop的值小于0，scrollTop 被设为0.如果设置了超出这个容器可滚动的值, scrollTop 会被设为最大值.</p></li><li><p>Element.scrollLeft 与xxtop类似</p></li><li><p>Element.scrollwidth：内容区域尺寸加上内边距加上溢出尺寸，当内容正好和内容区域匹配没有溢出时，这些属性与clientWidth和clientHeight相等</p></li></ul><h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><ul><li><p>element.clientHeight:只读，对于没有定义CSS或者内联布局盒子的元素为0，同时它是元素内部的高度(单位像素)，包含内边距，但不包括水平滚动条、边框和外边距。clientHeight 可以通过 CSS height + CSS padding- 水平滚动条高度 (如果存在)来计算.</p></li><li><p>clientleft:元素的内边距的外边缘和边框的外边缘的距离，实际就是边框的左边框宽度</p></li><li><p>clienttop:同理边框的上边框的宽度</p></li><li><p>clientwidth:用于描述元素内尺寸宽度，是指 元素内容+内边距 大小，不包括边框、外边距、滚动条部分</p></li></ul><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><p>无限加载：element.scrollHeight - element.scrollTop === element.clientHeight</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;之前对DOM接口中各种height，height，scrollHeight，clientHeight，clientWidth等等概念有大概的
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
      <category term="HTML" scheme="http://stan1812.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>小程序&lt;宜墨&gt;开发小记</title>
    <link href="http://stan1812.github.io/2018/02/14/LearnKoa/"/>
    <id>http://stan1812.github.io/2018/02/14/LearnKoa/</id>
    <published>2018-02-14T08:44:33.000Z</published>
    <updated>2018-04-23T06:25:01.482Z</updated>
    
    <content type="html"><![CDATA[<p>在今天这个特别的日子，我，一个单身狗，感觉自己浑身散发着清香。</p><p>但是在今天，回到家就重度拖延症的我也算是终于完成了自己的第一个微信小程序的完整开发。一个想要写给妈妈的小程序。</p><p>先来说下技术栈吧：<br><figure class="highlight xl"><table><tr><td class="code"><pre><div class="line">前端：</div><div class="line">    微信小程序</div><div class="line">后端(restful api)：</div><div class="line">    <span class="built_in">NodeJS</span></div><div class="line">    koa2</div><div class="line">    monk</div><div class="line">    mongodb</div><div class="line">    corntab</div><div class="line">    PM2</div></pre></td></tr></table></figure></p><p>至于设计和产品嘛。。当然也是我啊（滑稽🙈）</p><p>小程序在之前已经大概的说过一点，这次说下后台的一些东西。</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据来源于一个app “观之”（原每日一读），在拿到他的接口之后，本来是可以直接拿来用就不用写后台，但是打算在微信上架，担心会有侵权的一些问题，期间也咨询了几个学法律的同学，但是得到的最终答案是，这个东西很模糊。于是为了避免麻烦，我决定把先写个爬虫把数据爬一下，因为内容都是各种各种杂文，所以也就不用担心侵权的问题了。</p><p>这个爬虫应该可以说是最简单的爬虫了，上去就是干，node一把梭，经过调试就开始爬，很快就爬到了从今年到2012年左右的数据，差不多够了。然后还就是使用corntab加一个定时任务，每天零点定时抓取更新的内容，存进mongodb。</p><h3 id="后台"><a href="#后台" class="headerlink" title="后台"></a>后台</h3><p>寒假看了一些koa的东西，然后就决定使用koa。刚开始看koa的时候着实被koa的开放吓了一跳，项目目录完全自己按需搭建。</p><p>虽然有一些开发者所搭建的generator但是为了把握一下整个的结构所以就自己搭建了项目结构:</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[root@VM_56_194_centos Wechat-BE]<span class="comment"># tree -L 1</span></div><div class="line">.</div><div class="line">|-- app.js</div><div class="line">|-- controller.js</div><div class="line">|-- controllers</div><div class="line">|-- ecosystem.config.js</div><div class="line">|-- node_modules</div><div class="line">|-- package.json</div><div class="line">`-- readme.md</div></pre></td></tr></table></figure><p>具体的技术细节的话代码地址在此<a href="https://github.com/Stan1812/Wechat-BE" target="_blank" rel="external">https://github.com/Stan1812/Wechat-BE</a></p><p>部署到服务器，然后使用PM2做进程守护。开始提供服务</p><p>现在koa只是基本的使用，开学之后学习深入些再写koa的相关东西</p><h3 id="monk"><a href="#monk" class="headerlink" title="monk"></a>monk</h3><p>monk感觉是在小项目中很好用的一个node连接mongodb的工具，相比mongose轻便精巧很多，正如他的简介“A tiny layer that provides simple yet substantial usability improvements for MongoDB usage within Node.JS.”<br>留个地址吧，官网：<a href="https://automattic.github.io/monk/" target="_blank" rel="external">https://automattic.github.io/monk/</a></p><hr><p>溜了溜了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在今天这个特别的日子，我，一个单身狗，感觉自己浑身散发着清香。&lt;/p&gt;
&lt;p&gt;但是在今天，回到家就重度拖延症的我也算是终于完成了自己的第一个微信小程序的完整开发。一个想要写给妈妈的小程序。&lt;/p&gt;
&lt;p&gt;先来说下技术栈吧：&lt;br&gt;&lt;figure class=&quot;highlig
      
    
    </summary>
    
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
      <category term="NodeJS" scheme="http://stan1812.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序之不完全胡乱指东西南北</title>
    <link href="http://stan1812.github.io/2018/01/24/wechatapp/"/>
    <id>http://stan1812.github.io/2018/01/24/wechatapp/</id>
    <published>2018-01-24T13:37:33.000Z</published>
    <updated>2018-04-23T06:24:32.486Z</updated>
    
    <content type="html"><![CDATA[<p>今天考完了试，很开心，晚上没什么事，来写篇博客。</p><h3 id="先吹吹水"><a href="#先吹吹水" class="headerlink" title="先吹吹水"></a>先吹吹水</h3><p>在期末考试之前的某段时间，差不多就是跳一跳火的那段时间吧，由于无聊，去微信公众平台注册了一个账号，然后就对着文档开始了小程序的玩耍之路。之前虽然小程序挺火的，但是也一直没有什么兴趣去看。。主要还是感觉限制太多了叭，个人总感觉小程序，毕竟还是微信一家的东西。像我这种菜鸡也就玩一玩叭。</p><p>之前看到过一个有点火的小程序，是一个显示手机信息的小工具，就是比如手机的内存啊，型号什么的信息，然后就有了好几万的用户，然后在我看了小程序的文档之后发现了一个这样的API<code>wx.getSystemInfo(OBJECT)</code>。基本上就是这个API了叭。。选对了目标用户真的是能飞。</p><h3 id="开放的API"><a href="#开放的API" class="headerlink" title="开放的API"></a>开放的API</h3><p>小程序所开放的能力感觉还是很强的，非常方便的就能调用手机的各种接口，文件，设备，包括GPS，网络状态，罗盘等，甚至对于剪切板这个东西，浏览器出于安全考虑一直不肯完全放开权限，要写各种hack的东西，微信也提供了很好的封装<code>wx.getClipboardData(OBJECT)</code> <code>wx.setClipboardData(OBJECT)</code>，这是微信有点大胆？（也可能是我多想了）不错。</p><p>除此之外，小程序的媒体能力也很丰富，录音，视频，相机，甚至实时音视频接口都有提供。对于我们这种辣鸡开发者确实是些可玩性很强的东西。</p><p>网络方面，除了常规的request，还提供了websocket的接口，确实是很周到。然后也开放了设置导航条，tabBar，置顶信息的API，给了更大的客户定制能力。</p><p>至于API，其他的不多说了。文档说的不能再清楚了。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><h4 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h4><ul><li>.json  JSON 配置文件(package.json)</li><li>.wxml  WXML 模板文件(.html/.vue)</li><li>.wxss  WXSS 样式文件</li><li>.js    JS 脚本逻辑文件<h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4>这是我写的一小demo</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">[root@VM_56_194_centos wechat_demo]<span class="comment"># tree -L 2</span></div><div class="line">.</div><div class="line">|-- app.js </div><div class="line">|-- app.json //当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等</div><div class="line">|-- app.wxss</div><div class="line">|-- main.js</div><div class="line">|-- main.json</div><div class="line">|-- main.wxml</div><div class="line">|-- pages</div><div class="line">|   |-- artlist</div><div class="line">|   |   |-- list.js</div><div class="line">|   |   |-- list.json</div><div class="line">|   |   |-- list.wxml</div><div class="line">|   |   `-- list.wxss</div><div class="line">|   |-- index</div><div class="line">|   |   |-- index.js</div><div class="line">|   |   |-- index.wxml</div><div class="line">|   |   `-- index.wxss</div><div class="line">|   `-- logs</div><div class="line">|       |-- logs.js</div><div class="line">|       |-- logs.json</div><div class="line">|       |-- logs.wxml</div><div class="line">|       `-- logs.wxss</div><div class="line">|-- project.config.json</div><div class="line">|-- README.md</div><div class="line">|-- utils</div><div class="line">|   `-- util.js</div><div class="line">`-- wxParse</div><div class="line">    |-- emojis</div><div class="line">    |-- html2json.js</div><div class="line">    |-- htmlparser.js</div><div class="line">    |-- showdown.js</div><div class="line">    |-- wxDiscode.js</div><div class="line">    |-- wxParse.js</div><div class="line">    |-- wxParse.wxml</div><div class="line">    `-- wxParse.wxss</div></pre></td></tr></table></figure><p>这是一个每日一文的小东西，每天随机推荐一片文章。</p><p>其实结构还是很清晰的。。wxparse是一个解析HTML的工具，因为获取的文章数据是带html标签的，需要解析，但是小程序没有像V-html这样舒服东西，所以要找其他的工具，但是使用起来需要直接把文件手动复制到目录下，没有开放的包管理器，可能这就是相对比较封闭的一些劣势吧。</p><h3 id="大概思想"><a href="#大概思想" class="headerlink" title="大概思想"></a>大概思想</h3><p>依然是如今最火的MVVM思想，数据驱动，挺多地方和Vue还是很像的，要想上手做些demo还是挺快的。基本是都是常见的数据绑定，然后各种 <strong>钩子函数</strong>。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Page(&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 页面的初始数据</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  data: &#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面加载</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onLoad: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面初次渲染完成</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onReady: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面显示</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onShow: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面隐藏</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onHide: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 生命周期函数--监听页面卸载</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onUnload: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 页面相关事件处理函数--监听用户下拉动作</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onPullDownRefresh: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 页面上拉触底事件的处理函数</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onReachBottom: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * 用户点击右上角分享</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  onShareAppMessage: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>还是比较容易理解的。</p><p>组件之间的通信，数据管理，应该是相对来说比较重要的东西了。但是文档中没有提太多，然后这里有一篇比较好的文章：<img src="https://segmentfault.com/a/1190000008895441" alt="https://segmentfault.com/a/1190000008895441"><br>比较容易想到的是，最粗暴的，使用localStorage，简单粗暴。然后比较好的方法应该是使用<code>globalData</code>来处理吧。<br>深一点的其他东西还讨论不来，就先这样吧~</p><p>溜了溜了睡觉睡觉，明天回家！！！🍭</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天考完了试，很开心，晚上没什么事，来写篇博客。&lt;/p&gt;
&lt;h3 id=&quot;先吹吹水&quot;&gt;&lt;a href=&quot;#先吹吹水&quot; class=&quot;headerlink&quot; title=&quot;先吹吹水&quot;&gt;&lt;/a&gt;先吹吹水&lt;/h3&gt;&lt;p&gt;在期末考试之前的某段时间，差不多就是跳一跳火的那段时间吧，由
      
    
    </summary>
    
    
      <category term="技术" scheme="http://stan1812.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="JS" scheme="http://stan1812.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>初探parcel📦</title>
    <link href="http://stan1812.github.io/2018/01/13/parcel/"/>
    <id>http://stan1812.github.io/2018/01/13/parcel/</id>
    <published>2018-01-13T09:32:37.000Z</published>
    <updated>2018-04-23T06:24:48.917Z</updated>
    
    <content type="html"><![CDATA[<p>在期末复习的一个难受的下午，也就是现在，我突然想起了之前看到的号称零配置且最快的前端打包神器：Parcel，于是我放下数字逻辑。准备看看这货到底什么样。</p><p>github地址：<a href="https://github.com/parcel-bundler/parcel" target="_blank" rel="external">https://github.com/parcel-bundler/parcel</a></p><p>首先想要吐槽一下。。Parcel图标确实是不怎么好看哈哈。一个纸箱子。。不过可以说是直接了当的展示出了他的功能。打包嘛。</p><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>先来官网瞅一瞅（说的确实挺厉害的）</p><blockquote><p>🚀 极速打包时间<br>Parcel 使用 worker 进程去启用多核编译。同时有文件系统缓存，即使在重启构建后也能快速再编译。</p><p>📦 将你所有的资源打包<br>Parcel 具备开箱即用的对 JS, CSS, HTML, 文件 及更多的支持，而且不需要插件。</p><p>🐠 自动转换<br>如若有需要，Babel, PostCSS, 和PostHTML甚至 node_modules 包会被用于自动转换代码.</p><p>✂️ 零配置代码分拆<br>使用动态 import() 语法, Parcel 将你的输出文件束(bundles)分拆，因此你只需要在初次加载时加载你所需要的代码。</p><p>🔥 热模块替换<br>Parcel 无需配置，在开发环境的时候会自动在浏览器内随着你的代码更改而去更新模块。</p><p>🚨 友好的错误日志<br>当遇到错误时，Parcel 会输出 语法高亮的代码片段，帮助你定位问题</p></blockquote><p>官网还提供了这样一个比较</p><table><thead><tr><th style="text-align:left">打包工具</th><th style="text-align:left">时间</th></tr></thead><tbody><tr><td style="text-align:left">browserify</td><td style="text-align:left">22.98s</td></tr><tr><td style="text-align:left">webpack</td><td style="text-align:left">20.71s</td></tr><tr><td style="text-align:left">parcel</td><td style="text-align:left">9.98s</td></tr><tr><td style="text-align:left">parcel - with cache</td><td style="text-align:left">2.64s</td></tr></tbody></table><blockquote><p>基于一个合理大小的应用，包含1726个模块， 6.5M 未压缩大小. 在一台有4个物理 CPU 的 2016 MacBook Pro 上构建。</p></blockquote><p>相比的话，确实是相当的快，而且二次打包简直要起飞。。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">先安装（当然你也可以使用yarn）</div><div class="line">mkdir parceltest &amp;&amp; <span class="built_in">cd</span> parceltest &amp;&amp; npm install parcel-bundler --save</div></pre></td></tr></table></figure><p>文档中说的是Parcel 可以使用任何类型的文件作为入口，但是最好还是使用 HTML 或 JavaScript 文件。如果在 HTML 中使用相对路径引入主要的 JavaScript 文件，Parcel 也将会对它进行处理将其替换为相对于输出文件的 URL 地址。</p><p>然后，创建一个 index.html 和 index.js 文件。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">touch index.html &amp;&amp; touch index.js</div></pre></td></tr></table></figure></p><p>index.html<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p><p>index.js<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">"hello parcel"</span>);</div></pre></td></tr></table></figure></p><p>Parcel 内置了一个当你改变文件时能够自动重新构建应用的开发服务器，而且为了实现快速开发，该开发服务器支持热模块替换。在package.json指出即可：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="string">"scripts"</span>:&#123;</div><div class="line">  <span class="string">"start"</span>:<span class="string">"parcel index.html"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后，npm start<br>现在在浏览器中打开 <a href="http://localhost:1234/。也可以使用" target="_blank" rel="external">http://localhost:1234/。也可以使用</a> -p <port number=""> 选项覆盖默认的端口。<br>确实很快。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">built <span class="keyword">in</span> 16ms</div></pre></td></tr></table></figure></port></p><p>此外支持零配置代码拆分，也是挺舒服的。</p><p>至于sass，babel什么的，文档说的看起来于是相当的易于安装，基本无配置。支持TS，貌似还支持vue的组件和react的组件。</p><p>不过目前就看了这么多，边看文档，边简单的测试，边写这个小体验。只是接触了最基础的东西，总体给人的感觉是很轻，很快。很友好。不过据说webpack 4.0也要加入默认配置（可怜我webapck 3.0都不怎么会用。。）不知道parcel能不能真的火起来。不过一些小项目尝尝鲜还是没有问题的叭。</p><p>复习实在无聊，来看下这个东西还是很解闷的。。就先这么多吧，，复习要紧复习要紧。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在期末复习的一个难受的下午，也就是现在，我突然想起了之前看到的号称零配置且最快的前端打包神器：Parcel，于是我放下数字逻辑。准备看看这货到底什么样。&lt;/p&gt;
&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/parcel-bundler/p
      
    
    </summary>
    
    
      <category term="技术" scheme="http://stan1812.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="工具" scheme="http://stan1812.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Crontab略解🎉</title>
    <link href="http://stan1812.github.io/2018/01/12/Crontab/"/>
    <id>http://stan1812.github.io/2018/01/12/Crontab/</id>
    <published>2018-01-11T16:22:06.000Z</published>
    <updated>2018-01-13T10:35:48.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Crond-amp-amp-Crontab"><a href="#Crond-amp-amp-Crontab" class="headerlink" title="Crond&amp;&amp;Crontab"></a>Crond&amp;&amp;Crontab</h3><p>先说下他俩是干啥么的。</p><blockquote><p>crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p><p>然后，Linux下的任务调度分两类，系统任务调度和用户任务调度。</p><p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。</p><p>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致</p><h3 id="Crontab-格式："><a href="#Crontab-格式：" class="headerlink" title="Crontab 格式："></a>Crontab 格式：</h3><table><thead><tr><th style="text-align:left">分</th><th style="text-align:left">时</th><th style="text-align:left">日</th><th style="text-align:left">月</th><th style="text-align:left">周</th><th style="text-align:left">命令</th></tr></thead><tbody><tr><td style="text-align:left">minute</td><td style="text-align:left">hour</td><td style="text-align:left">day</td><td style="text-align:left">month</td><td style="text-align:left">week</td><td style="text-align:left">command</td></tr><tr><td style="text-align:left">0~59</td><td style="text-align:left">0~23</td><td style="text-align:left">0~31</td><td style="text-align:left">0~12</td><td style="text-align:left">0~7</td><td style="text-align:left">系统命令/脚本文件 </td></tr></tbody></table><p>且均为整数<br>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p></blockquote><p>在以上各个字段中，还可以使用以下特殊字符：</p><p>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</p><p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</p><p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</p><p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="crond"><a href="#crond" class="headerlink" title="crond"></a>crond</h4><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">安装crontab：</div><div class="line"></div><div class="line">yum install crontabs</div><div class="line"></div><div class="line"></div><div class="line">/sbin/service crond start //启动服务</div><div class="line"></div><div class="line">/sbin/service crond stop //关闭服务</div><div class="line"></div><div class="line">/sbin/service crond restart //重启服务</div><div class="line"></div><div class="line">/sbin/service crond reload //重新载入配置</div><div class="line"></div><div class="line">查看crontab服务状态：</div><div class="line"></div><div class="line">service crond status</div><div class="line"></div><div class="line">手动启动crontab服务：</div><div class="line"></div><div class="line">service crond start</div><div class="line"></div><div class="line">查看crontab服务是否已设置为开机启动，执行命令：</div><div class="line"></div><div class="line">ntsysv</div><div class="line"></div><div class="line">加入开机自动启动：</div><div class="line"></div><div class="line">chkconfig –level 35 crond on</div></pre></td></tr></table></figure><h4 id="Crontab"><a href="#Crontab" class="headerlink" title="Crontab"></a>Crontab</h4><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">crontab [-u user] file</div><div class="line"></div><div class="line">crontab [-u user] [ -e | -l | -r ]</div></pre></td></tr></table></figure><p>2．命令功能：</p><p>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</p><p>3．命令参数：</p><ul><li>-u user : 用来设定某个用户的crontab服务，例如，“-u xxx”表示设定xxx用户的crontab服务，此参数一般有root用户来运行.</li><li>file : file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li><li>-e : 编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</li><li>-l : 显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</li><li>-r : 从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</li><li>-i : 在删除用户的crontab文件时给确认提示。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">比如每天定时启动一个Node的爬虫（结果展示了部分数据）</div><div class="line">[root@VM_56_194_centos ~]<span class="comment">#  crontab -l</span></div><div class="line">2 0 * * * /root/.nvm/versions/node/v8.8.0/bin/node /home/art-spider/Daily-article-spider/today.js</div></pre></td></tr></table></figure><p>最后推荐一个非常好用的帮助你写crontab命令的网站：<a href="https://crontab.guru/#1_0_*_*_*" target="_blank" rel="external">https://crontab.guru/#1<em>0</em><em>_</em>_*</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Crond-amp-amp-Crontab&quot;&gt;&lt;a href=&quot;#Crond-amp-amp-Crontab&quot; class=&quot;headerlink&quot; title=&quot;Crond&amp;amp;&amp;amp;Crontab&quot;&gt;&lt;/a&gt;Crond&amp;amp;&amp;amp;Crontab
      
    
    </summary>
    
      <category term="技术" scheme="http://stan1812.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://stan1812.github.io/tags/Linux/"/>
    
      <category term="技术" scheme="http://stan1812.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
