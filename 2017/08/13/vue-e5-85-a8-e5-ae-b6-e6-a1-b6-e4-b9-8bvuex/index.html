<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Shady"><title>VUe全家桶之VueX · Libx</title><meta name="description" content="如果你要使用Vue构建一个相对比较复杂的项目，Vuex在你的项目将占有非常重要的地位。
暑期留校总结系列&amp;lt;三&amp;gt;——VueXVuex是什么？老规矩，首先还是来放一波官方文档地址：地址在此
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><h3 title=""><a href="/">Libx</a></h3><div class="description"><p>Thoughts,stories and ideas</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>© 2017 — 2018 ❤ Shady</span></a></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>VUe全家桶之VueX</a></h3></div><div class="post-content"><p>如果你要使用Vue构建一个相对比较复杂的项目，Vuex在你的项目将占有非常重要的地位。</p>
<h2 id="暑期留校总结系列-lt-三-gt-——VueX"><a href="#暑期留校总结系列-lt-三-gt-——VueX" class="headerlink" title="暑期留校总结系列&lt;三&gt;——VueX"></a>暑期留校总结系列&lt;三&gt;——VueX</h2><h3 id="Vuex是什么？"><a href="#Vuex是什么？" class="headerlink" title="Vuex是什么？"></a>Vuex是什么？</h3><p>老规矩，首先还是来放一波官方文档地址：<a href="https://vuex.vuejs.org/zh-cn/intro.html" target="_blank" rel="external">地址在此</a></p>
<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="external">devtools extension</a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p>
<p>他的设计思想应该是类似于react中的redux的，它所实现的功能也是和redux的作用是类似的，都是对应用程序总的各种状态抽离到这个系统外层来统一进行管理，放置了数据流的混乱以及状态的不可控性。我觉得Vue对于状态的管理是非常看重的，父子组件通信中数据的单项传递也是为了增强维护数据的可控性，避免你在使用的时候因为状态的混乱而崩溃。状态的管理是非常需要重视的，因为在复杂的情况下，很有可能你不找不到你的数据在哪里发生了改变，被谁改变，然后你将花上很长时间来debug，，（反正我是遇到了。。）</p>
<p>在我的实际项目中，起初并未使用Vuex来抽离所有状态并作统一的状态管理，起初认为在父子组件之间的通信完全不需要借助第三方的工具，而同级组件之间的通信完全可以使用Event Bus来实现。但是我前期还是低估了这个项目所需要传递的数据和需要管理的状态，，（因为这个项目并不能开源，，所有，很遗憾）在前期的编写过程中还是比较可以的，但是在后来需要管理的数据越来越多，数据流越来越混乱，甚至有点想打人。然后就果断上了VUEX，之后就舒服多了。</p>
<p>[caption id=”” align=”aligncenter” width=”548”]<img src="https://vuex.vuejs.org/zh-cn/images/flow.png" alt=""> 一般的单向数据流[/caption]</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>[caption id=”” align=”aligncenter” width=”701”]<img src="https://vuex.vuejs.org/zh-cn/images/vuex.png" alt=""> 复杂情况[/caption]</p>
<p>&nbsp;</p>
<p>有一句话我非常的认同，这句话也写在了官方文档的第一页：<strong>Flux 架构就像眼镜：您自会知道什么时候需要它。</strong></p>
<h3 id="Let’s-do-it"><a href="#Let’s-do-it" class="headerlink" title="Let’s do it"></a>Let’s do it</h3><h3 id="首先安装一波"><a href="#首先安装一波" class="headerlink" title="首先安装一波"></a>首先安装一波</h3><p><code>
</code></p>
<h4 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h4><p><code>npm install vuex --save</code></p>
<p>在一个模块化的打包系统中，您必须显式地通过 <code>Vue.use()</code> 来安装 Vuex：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line">Vue.use(Vuex)</div></pre></td></tr></table></figure></p>
<h3 id="Vuex的组成"><a href="#Vuex的组成" class="headerlink" title="Vuex的组成:"></a>Vuex的组成:</h3><p>vuex主要是由这几部分组成</p>
<ul>
<li>State</li>
<li>Getters</li>
<li>Mutations</li>
<li>Actions</li>
</ul>
<hr>
<p>State：顾名思义，状态，Vuex 使用 <strong>单一状态树，</strong>用一个对象就包含了全部的应用层级状态。至此它便作为一个『唯一数据源(<a href="https://en.wikipedia.org/wiki/Single_source_of_truth" target="_blank" rel="external">SSOT</a>)』而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。具体的实例不再放出。</p>
<hr>
<p>Getters；同样的，get？获取东西的一个东西。</p>
<p>有时候我们需要从 store 中的 state 中派生出一些状态，比如需要进行的一些过滤，排序，计数等。如果有多个组件需要用到，那么重复的在各个组件中使用将不是很理想，Vuex 允许我们在 store 中定义『getters』（可以认为是 store 的计算属性）。Getters 接受 state 作为其第一个参数：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state: &#123;</div><div class="line">    todos: [</div><div class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>:<span class="literal">true</span> &#125;,</div><div class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>:<span class="literal">false</span> &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  getters: &#123;</div><div class="line">    doneTodos: state  &#123;</div><div class="line">      <span class="keyword">return</span> state.todos.filter(todo  todo.done)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>Getters 会暴露为 <code>store.getters</code> 对象：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">store.getters.doneTodos[&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;]</div></pre></td></tr></table></figure></p>
<p>Getters 也可以接受其他 getters 作为第二个参数：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">getters: &#123;</div><div class="line">  doneTodosCount: (state, getters)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> getters.doneTodos.length</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">store.getters.doneTodosCount1</div></pre></td></tr></table></figure></p>
<p>我们可以很容易地在任何组件中使用它：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  doneTodosCount () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.doneTodosCount</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>相比之下，可能getters用的不是非常的多？但是他非常有用，他为很多尴尬的场景提供了非常优雅的解决方案。</p>
<hr>
<p><strong>mutations和actions</strong>联系的非常的紧密：因为在Vuex中需要使用action来触发一个mutation，由mutation来触发状态的改变，也就是说，action并不能改变state，他只是发送一个更改状态的通知，然后将数据传过去，最终是由mutation来进行改变。</p>
<p>Action 类似于 mutation，不同在于：</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li><p>Action 可以包含任意异步操作。<br><strong>mutation 必须同步执行</strong>？Action 就不受约束！我们可以在 action 内部执行<strong>异步</strong>操作</p>
<p><strong>非常重要！</strong></p>
<p>&nbsp;</p>
<hr>
<h3 id="实际应用："><a href="#实际应用：" class="headerlink" title="实际应用："></a>实际应用：</h3><p>Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：</p>
</li>
</ul>
<ol>
<li>应用层级的状态应该集中到单个 store 对象中。</li>
<li>提交 <strong>mutation</strong> 是更改状态的唯一方法，并且这个过程是同步的。</li>
<li>异步逻辑都应该封装到 <strong>action</strong> 里面。<br>只要你遵守以上规则，如何组织代码随你便。在实际的应用中，按照你的项目大小，你可以选择使用一个单独的store.js来存放所有的state，getters，mutations，actions，当然如果你的项目足够大的话，你也可以使用模块化的方式，（对于modules。。没什么特别的体会，就是拆一拆？）将他们分别大卸八块，下面是项目结构示例：<figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">├── index.html</div><div class="line">├── main.js</div><div class="line">├── api</div><div class="line">│   └── ...  抽取出API请求</div><div class="line">├── components</div><div class="line">│   ├── App.vue</div><div class="line">│   └── ...</div><div class="line">└── store</div><div class="line">    ├── index<span class="selector-class">.js</span>           我们组装模块并导出 store 的地方</div><div class="line">    ├── actions<span class="selector-class">.js</span> 根级别的 action</div><div class="line">    ├── mutations<span class="selector-class">.js</span>   根级别的 mutation</div><div class="line">    └── modules</div><div class="line">        ├── xxx<span class="selector-class">.js</span>      </div><div class="line">        └── xxxx.js</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="一些总结："><a href="#一些总结：" class="headerlink" title="一些总结："></a>一些总结：</h3><p>事实上，我们可以看到，当然如果你写了的话会有更深的体会，在实际的操作中，如果你使用了vuex，相对复杂的流程使你只需更改一个true或false都要走一堆流程，虽然这是规范的操作方式，但是这确实有些不够优雅。。所以我做了一个测试，在组件中，使用同行this.$store.state.xxx=xxxx是可以直接改变state中的状态的。。但是，慎用。。除非你这个状态真的只是这么简单，还有你不怕被review你代码的boss打。（逃。。）</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-08-13</span><i class="fa fa-tag"></i><a class="tag" href="/categories/技术/" title="技术">技术 </a><a class="tag" href="/tags/Vue/" title="Vue">Vue </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://stan1812.github.io/2017/08/13/vue-e5-85-a8-e5-ae-b6-e6-a1-b6-e4-b9-8bvuex/,Libx,VUe全家桶之VueX,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/08/20/vue2-0-e7-94-9f-e5-91-bd-e5-91-a8-e6-9c-9f-e4-bb-a5-e5-8f-8a-e7-94-9f-e5-91-bd-e5-91-a8-e6-9c-9f-e9-92-a9-e5-ad-90-e7-9a-84-e5-bc-82/" title="Vue2.0生命周期以及生命周期钩子">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2017/08/11/vue-e5-85-a8-e5-ae-b6-e6-a1-b6-e4-b9-8bvue-resourse/" title="Vue全家桶之Vue-resource">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>