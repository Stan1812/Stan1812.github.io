<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Shady"><title>Javascript事件循环机制 · Libx</title><meta name="description" content="前言最近在学习Node.JS，而node实用的是单线程模型，对于所有的I/O都使用了异步式的请求方式。并使用事件驱动+异步式I/O来带来可观的性能提升。node大量使用了异步的处理方式，所以想了解下具体的原理，看了很多相关的博客以及文档，现在来总结一下。
从同步与异步说起学过JS的估计都知道了，JS"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><h3 title=""><a href="/">Libx</a></h3><div class="description"><p>Thoughts,stories and ideas</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>© 2017 — 2018 ❤ Shady</span></a></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Javascript事件循环机制</a></h3></div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在学习Node.JS，而node实用的是单线程模型，对于所有的I/O都使用了异步式的请求方式。并使用事件驱动+异步式I/O来带来可观的性能提升。node大量使用了异步的处理方式，所以想了解下具体的原理，看了很多相关的博客以及文档，现在来总结一下。</p>
<h3 id="从同步与异步说起"><a href="#从同步与异步说起" class="headerlink" title="从同步与异步说起"></a>从同步与异步说起</h3><p>学过JS的估计都知道了，JS的执行环境是单线程。所谓”单线程”，就是一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。</p>
<p>JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去.</p>
<ul>
<li>“同步任务（synchronous）”：后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；</li>
<li>“异步任务（asynchronous）”：则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li>
</ul>
<p>而异步编程的主要方式基本有这几种：</p>
<ol>
<li>改写回调函数</li>
<li>事件监听</li>
<li>发布/订阅（这种不了解。。好像跟设计模式有点关系，以后再去了解）</li>
<li>Promises对象</li>
<li>ES7中的await和async</li>
</ol>
<h3 id="函数调用栈与任务队列"><a href="#函数调用栈与任务队列" class="headerlink" title="函数调用栈与任务队列"></a>函数调用栈与任务队列</h3><p>主要有以下两个解释：</p>
<h4 id="解释一"><a href="#解释一" class="headerlink" title="解释一"></a>解释一</h4><ol>
<li>Javascript有一个main thread 主进程和call-stack（一个调用堆栈），在对一个调用堆栈中的task处理的时候，其他的都要等着。当在执行过程中遇到一些类似于setTimeout等异步操作的时候，会交给浏览器的其他模块(以webkit为例，是webcore模块)进行处理，当到达setTimeout指定的延时执行的时间之后，task(回调函数)会放入到任务队列之中。一般不同的异步任务的回调函数会放入不同的任务队列之中。等到调用栈中所有task执行完毕之后，接着去执行任务队列之中的task(回调函数)。</li>
</ol>
<p><img src="https://pic1.zhimg.com/v2-e902447823cf13e5a547214363233858_r.jpg" alt=""></p>
<p>在上图中，调用栈中遇到DOM操作、ajax请求以及setTimeout等WebAPIs的时候就会交给浏览器内核的其他模块进行处理，webkit内核在Javasctipt执行引擎之外，有一个重要的模块是webcore模块。对于图中WebAPIs提到的三种API，webcore分别提供了DOM Binding、network、timer模块来处理底层实现。等到这些模块处理完这些操作的时候将回调函数放入任务队列中，之后等栈中的task执行完之后再去执行任务队列之中的回调函数。<br>(内容来自<a href="https://www.zhihu.com/people/xia-yan-luo-47/activities" target="_blank" rel="external">@柳兮</a>)</p>
<h4 id="解释二"><a href="#解释二" class="headerlink" title="解释二"></a>解释二</h4><ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。(stack的第二种含义是“调用栈”（call stack），表示函数或子例程像堆积木一样存放，以实现层层调用。)</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。<br>（内容来自<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">@阮一峰</a>）</li>
</ol>
<p>以上是网上比较典型的两种说法。对此我有一个不理解的地方就是:”当到达setTimeout指定的延时执行的时间之后，task(回调函数)会放入到任务队列之中。”and “等到调用栈中所有task执行完毕之后，接着去执行任务队列之中的task(回调函数)” 这两种说法看起来好像是矛盾的，如何确定到达set的时间内调用栈内的任务执行完成呢？<br>事实证明：setTimeout和setInterval的运行机制是，将指定的代码移出本次执行，等到下一轮Event Loop时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮Event Loop时重新判断。这意味着，setTimeout指定的代码，必须等到本次执行的所有代码都执行完，才会执行。<br>每一轮Event Loop时，都会将“任务队列”中需要执行的任务，一次执行完。setTimeout和setInterval都是把任务添加到“任务队列”的尾部。因此，它们实际上要等到当前脚本的所有同步任务执行完，然后再等到本次Event Loop的“任务队列”的所有任务执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。(之前听说过settimeout的时间可能会不完全准确，现在终于知道其中的原因了)<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">setTimeout(someTask,<span class="number">100</span>);</div><div class="line">veryLongTask();</div></pre></td></tr></table></figure></p>
<p>上面代码的setTimeout，指定100毫秒以后运行一个任务。但是，如果后面立即运行的任务（当前脚本的同步任务））非常耗时，过了100毫秒还无法结束，那么被推迟运行的someTask就只有等着，等到前面的veryLongTask运行结束，才轮到它执行。</p>
<p>所以说这两种说法是并不矛盾的。</p>
<h3 id="同步与异步运行机制"><a href="#同步与异步运行机制" class="headerlink" title="同步与异步运行机制"></a>同步与异步运行机制</h3><p>目前比较浅显的解释是:”Javascript的事件分为同步任务和异步任务，遇到同步任务就放在执行栈中执行，而碰到异步任务就放到任务队列之中，等到执行栈执行完毕之后再去执行任务队列之中的事件。”<br>以上对于函数调用栈亿级任务队列的解释已经很详细了，现在来结合实例来具体的解释一下</p>
<p>以settimeout为例：</p>
<p>首先main()函数的执行上下文入栈</p>
<p><img src="https://pic2.zhimg.com/v2-9e5a3e686df7e84068575121c1ec9fcd_b.jpg" alt=""></p>
<p>代码接着执行，遇到console.log(‘Hi’),此时log(‘Hi’)入栈，console.log方法只是一个webkit内核支持的普通的方法，所以log(‘Hi’)方法立即被执行。此时输出’Hi’。</p>
<p><img src="https://pic2.zhimg.com/v2-1a9a6a95c4a7d3dc45facb5b2545640d_b.png" alt=""></p>
<p>当遇到setTimeout的时候，执行引擎将其添加到栈中。</p>
<p><img src="https://pic4.zhimg.com/v2-4a8c8a73009cc73d5efdb833fdf81b03_b.png" alt=""></p>
<p>调用栈发现setTimeout是之前提到的WebAPIs中的API，因此将其出栈之后将延时执行的函数交给浏览器的timer模块进行处理。</p>
<p><img src="https://pic3.zhimg.com/v2-37a7df54154dd521ced4dae2e3470c22_b.jpg" alt=""></p>
<p>timer模块去处理延时执行的函数，此时执行引擎接着执行将log(‘SJS’)添加到栈中，此时输出’SJS’。</p>
<p><img src="https://pic3.zhimg.com/v2-800d6abf4bcdef9a354c9d60f2882a26_b.png" alt=""></p>
<p>当timer模块中延时方法规定的时间到了之后就将其放入到任务队列之中，此时调用栈中的task已经全部执行完毕。</p>
<p><img src="https://pic2.zhimg.com/v2-e804f07a0d9b0436941e3e48550349b9_b.png" alt=""></p>
<p>调用栈中的task执行完毕之后，执行引擎会接着看执行任务队列中是否有需要执行的回调函数。这里的cb函数被执行引擎添加到调用栈中，接着执行里面的代码，输出’there’。等到执行结束之后再出栈。</p>
<p><img src="https://pic4.zhimg.com/v2-c3c2686ecfa45b21ff3bc99b0252b90b_b.png" alt=""></p>
<p><img src="https://pic4.zhimg.com/v2-f78ad9009fd2622c139f2da66f61d19b_b.png" alt=""></p>
<p>内容来自<a href="https://vimeo.com/96425312" target="_blank" rel="external">Philip Roberts: Help, I’m stuck in an event-loop.</a></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h4><p>网上有很多关于这个的面试题，其中有一道很经典的面试题：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div></pre></td></tr></table></figure></p>
<p>问题不大问题不大。</p>
<p>先来分析一下：<br>i=0时，满足条件，执行栈执行循环体里面的代码，发现是setTimeout，将其出栈之后把延时执行的函数交给Timer模块进行处理。</p>
<p>当i=1,2,3,4时，均满足条件，情况和i=0时相同，因此timer模块里面有5个相同的延时执行的函数。</p>
<p>当i=5的时候，不满足条件，for循环结束,console.log(new Date, i)入栈，此时的i已经变成了5。输出5。</p>
<p>此时1s已经过去，timer模块将5个回调函数按照注册的顺序返回给任务队列。</p>
<p>执行引擎去执行任务队列中的函数，5个function依次入栈执行之后再出栈，此时的i已经变成了5。因此几乎同时输出5个5。</p>
<p>因此等待的1s的时间其实只有输出第一个5之后需要等待1s，这1s的时间是timer模块需要等到的规定的1s时间之后才将回调函数交给任务队列。等执行栈执行完毕之后再去执行任务对列中的5个回调函数。这期间是不需要等待1s的。因此输出的状态就是：5 -&gt; 5,5,5,5,5，即第1个 5 直接输出，1s之后，输出 5个5；</p>
<p>来控制台跑一下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</div><div class="line"></div><div class="line">raven.b7b3066ebc21a63ef339.js:<span class="number">1</span> Tue Oct <span class="number">17</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">39</span> GMT+<span class="number">0800</span> (中国标准时间) <span class="number">5</span></div><div class="line"><span class="literal">undefined</span></div><div class="line">raven.b7b3066ebc21a63ef339.js:<span class="number">1</span> Tue Oct <span class="number">17</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">40</span> GMT+<span class="number">0800</span> (中国标准时间) <span class="number">5</span></div><div class="line">raven.b7b3066ebc21a63ef339.js:<span class="number">1</span> Tue Oct <span class="number">17</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">40</span> GMT+<span class="number">0800</span> (中国标准时间) <span class="number">5</span></div><div class="line">raven.b7b3066ebc21a63ef339.js:<span class="number">1</span> Tue Oct <span class="number">17</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">40</span> GMT+<span class="number">0800</span> (中国标准时间) <span class="number">5</span></div><div class="line">raven.b7b3066ebc21a63ef339.js:<span class="number">1</span> Tue Oct <span class="number">17</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">40</span> GMT+<span class="number">0800</span> (中国标准时间) <span class="number">5</span></div><div class="line">raven.b7b3066ebc21a63ef339.js:<span class="number">1</span> Tue Oct <span class="number">17</span> <span class="number">2017</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">40</span> GMT+<span class="number">0800</span> (中国标准时间) <span class="number">5</span></div></pre></td></tr></table></figure></p>
<p>well~</p>
<p>那么要如何的得到想要的效果呢？</p>
<ul>
<li><p>方法一：利用匿名函数的作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">9</span>; i++) &#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</div><div class="line">        setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.log( j );</div><div class="line">        &#125;, <span class="number">1000</span> );</div><div class="line">    &#125;)( i );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>方法二；使用let就好了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">9</span>; i++) &#123;</div><div class="line">   setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="built_in">console</span>.log( i );</div><div class="line">   &#125;, <span class="number">1000</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="实例二（更加深入）"><a href="#实例二（更加深入）" class="headerlink" title="实例二（更加深入）"></a>实例二（更加深入）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>)&#125;, <span class="number">0</span>);</div><div class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ ) &#123;</div><div class="line">            i == <span class="number">9999</span> &amp;&amp; resolve();</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="number">5</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</div><div class="line">&#125;)()</div></pre></td></tr></table></figure>
<p>promise的task会放在不同的任务队列里面，那么setTimeout的任务队列和promise的任务队列的执行顺序又是怎么的呢？</p>
<p>这里先把结论放出来：<br>一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。</p>
<ol>
<li><p>任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。</p>
</li>
<li><p>macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。</p>
</li>
<li><p>micro-task大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)</p>
</li>
<li><p>setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// setTimeout中的回调函数才是进入任务队列的任务</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'xxxx'</span>);</div><div class="line">&#125;)</div><div class="line"><span class="comment">// setTimeout作为一个任务分发器，这个函数会立即执行，而它所要分发的任务，也就是它的第一个参数，才是延迟执行</span></div></pre></td></tr></table></figure>
</li>
<li><p>来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。</p>
</li>
<li><p>事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后。循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。</p>
</li>
<li><p>其中每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成。</p>
</li>
</ol>
<p>这是一个挺复杂的东西了。。写的有点累了，先放一篇好文<a href="http://www.jianshu.com/p/12b9f73c5a4f" target="_blank" rel="external">深入核心，详解事件循环机制</a>，回头再来继续。</p>
<p>参考文章：</p>
<ul>
<li><a href="http://www.alloyteam.com/2015/10/turning-to-javascript-series-from-settimeout-said-the-event-loop-model/" target="_blank" rel="external">从setTimeout说事件循环模型</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="external">JavaScript 运行机制详解：再谈Event Loop</a></li>
<li><a href="https://vimeo.com/96425312" target="_blank" rel="external">Philip Roberts: Help, I’m stuck in an event-loop</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26229293" target="_blank" rel="external">深入浅出Javascript事件循环机制(上)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26238030" target="_blank" rel="external">深入浅出Javascript事件循环机制(下)</a></li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-10-17</span><i class="fa fa-tag"></i><a class="tag" href="/categories/技术/" title="技术">技术 </a><a class="tag" href="/tags/JS/" title="JS">JS </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://stan1812.github.io/2017/10/17/event-loop/,Libx,Javascript事件循环机制,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/10/17/structDef/" title="浅析struct">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2017/09/24/someFeelings/" title="有点不爽">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>